# 第 **24** 章 网络请求与远程资源

- 本章内容

  - 使用XMLHttpRequest对象 

  - 处理XMLHttpRequest事件 

  - 源域Ajax限制 

  - Fetch API 

  - Streams API 

- Ajax
  - Asynchronous JavaScript+XML，
  - 异步JavaScript加XML）

- 这个技术主要是什么？
  - 实现在不刷新页面的情况下从服务器获取数据，
  - 格式并不一定是XML。

- XMLHttpRequest，
  - 它实际上是过时Web规范的产物，
    - 应该只在旧版本浏览器中使用。
  - 实际开发中，应该尽可能使用fetch()

## **24.1** **XMLHttpRequest**对象 

```
let xhr = new XMLHttpRequest();
```

### **24.1.1** 使用**XHR** 

- 使用XHR对象首先要调用什么？
  - open()方法，
- open()方法接收3个参数？
  - 请求类型（"get"、"post"等
  - 请求URL，
  - 请求是否异步，（布尔值

```
xhr.open("get", "example.php", false);
```

- 这里的URL是相对于代码所在页面的，
  - 当然也可以使用绝对URL。
- 调用open()是否会发送请求？
  - 不会
  - 只是为发送请求做好准备。 

- 什么是同源URL？

  - 域名相同、
  - 端口相同、
  - 协议相同。

- 如果请求的URL与发送请求的页面在任何方面有所不同，

  则会发生什么？

  - 抛出安全错误

- 如何发送定义好的请求？
  - 调用send()方法

```
xhr.open("get", "example.txt", false); xhr.send(null);
```

- send()方法接收一个参数？
  - 作为请求体发送的数据。
    - 如果不需要发送请求体，则必须传null，
    - 因为这个参数在某些浏览器中是必需的。
- 调用send()之后，请求就会发送到哪里？
  - 服务器。 

- 收到响应后，XHR对象的哪些属性会被填充上数据？

  - responseText：
    - 作为响应体返回的文本。 

  - responseXML：
    - 如果响应的内容类型是"text/xml"或"application/xml"，
      - 那就是包含响应数据的XML DOM文档。 

  - status：
    - 响应的HTTP状态。 

  - statusText：
    - 响应的HTTP状态描述

- 收到响应后，第一步要检查什么？

  - status属性
  - 以确保响应成功返回。

- 一般来说，HTTP状态码为什么表示成功？

  - 2xx

    - 此时responseText或responseXML属性中

      会有内容。

- 如果HTTP状态码是304，则表示什么？
  - 资源未修改过，
    - 是从浏览器缓存中直接拿取的。
- HTTP状态码是304是否意味着响应有效？
  - 是
- 为确保收到正确的响应，应该检查哪些状态？

```
xhr.open("get", "example.txt", false);

xhr.send(null);

if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {

    alert(xhr.responseText);
    
} else {

    alert("Request was unsuccessful: " + xhr.status);
    
}
```

- 为确定下一步该执行什么操作，最好检查什么？

  - status 
  - 而不是statusText属性，
    - 因为statusText在跨浏览器的情况下不可靠。

- 无论是什么响应内容类型，

  responseText属性始终会保存什么？

  - 响应体， 

- responseXML对于非XML数据是什么？
  - null。 

- 但多数情况下最好使用异步还是同步请求？

  - 异步
    - 这样可以不阻塞JavaScript代码继续执行。

- XHR对象readyState属性，表示什么？

  - 当前处在请求/响应过程的哪个阶段。

- readyState属性有如下可能的值？

  - 0：未初始化（Uninitialized）。
    - 尚未调用open()方法。 

  - 1：已打开（Open）。
    - 已调用open()方法，尚未调用send()方法。 

  - 2：已发送（Sent）。
    - 已调用send()方法，尚未收到响应。 

  - 3：接收中（Receiving）。
    - 已经收到部分响应。 

  - 4：完成（Complete）。
    - 已经收到所有响应，可以使用了。

- 每次readyState从一个值变成另一个值，

  都会触发什么事件？

  - readystatechange

- 可以借readystatechange的机会做什么？

  - 检查readyState的值。

- 我们唯一关心的readyState值是什么？

  - 4
  - 表示数据已就绪。

- 为保证跨浏览器兼容，

  onreadystatechange事件处理程序应该在什么时候赋值？

  - 调用open()之前

```
let xhr = new XMLHttpRequest();

xhr.onreadystatechange = function () {

    if (xhr.readyState == 4) {
    
        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
        
            alert(xhr.responseText);
            
        } else {
        
            alert("Request was unsuccessful: " + xhr.status);
        }
    }
};

xhr.open("get", "example.txt", true);

xhr.send(null);
```

- 为什么使用DOM Level 0风格

  为XHR对象添加事件处理程序？

  - 因为并不是所有浏览器都支持DOM Level 2风格。

- onreadystatechange事件处理程序是否会收到event对象？

  - 不会

- onreadystatechange事件处理程序中，

  如何确定接下来该做什么？

  - 使用XHR对象

- 如何实现在收到响应之前取消异步请求？
  - 调用abort()方法： 

```
xhr.abort();
```

- 调用这个方法后，XHR对象会执行什么操作？
  - 停止触发事件，
  - 并阻止访问这个对象上任何与响应相关的属性。
- 中断请求后，应该做什么？
  - 取消对XHR对象的引用。
- 是否推荐重用XHR对象？
  - 不推荐
  - 由于内存问题

### **24.1.2 HTTP**头部 

- 默认情况下，XHR请求会发送哪些头部字段？

  - Accept：
    - 浏览器可以处理的内容类型。 

  - Accept-Charset：
    - 浏览器可以显示的字符集。 

  - Accept-Encoding：
    - 浏览器可以处理的压缩编码类型。 

  - Accept-Language：
    - 浏览器使用的语言。 

  - Connection：
    - 浏览器与服务器的连接类型。 

  - Cookie：
    - 页面中设置的Cookie。 

  - Host：
    - 发送请求的页面所在的域。 

  - Referer：
    - 发送请求的页面的URI。
      - 这个字段在HTTP规范中就拼错了，
      - 所以考虑到兼容性也必须将错就错。
      - （正确的拼写应该是Referrer。） 

  - User-Agent：
    - 浏览器的用户代理字符串。

- 如何发送额外的请求头部？
  - 使用setRequestHeader() 方法。
- setRequestHeader()方法接收两个参数？
  - 头部字段的名称和值。
- 为保证请求头部被发送，必须在什么时候调用？
  - open()之后、send()之前

```
let xhr = new XMLHttpRequest();

xhr.onreadystatechange = function () {

    if (xhr.readyState == 4) {
    
        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
        
            alert(xhr.responseText);
            
        } else {
        
            alert("Request was unsuccessful: " + xhr.status);
            
        }
    }
};

xhr.open("get", "example.php", true);

xhr.setRequestHeader("MyHeader", "MyValue");

xhr.send(null);
```

- 自定义头部一定要区别于浏览器正常发送的头部，
  - 否则可能影响服务器正常响应。
- 有些浏览器允许重写默认头部，有些浏览器则不允许。 

- 如何获取响应头部？
  - 使用getResponseHeader()方法
  - 传入要获取头部的名称
- 如何取得所有响应头部？
  - 使用getAllResponseHeaders()方法，
- getAllResponseHeaders()方法会返回什么？
  - 包含所有响应头部的字符串。

```
let myHeader = xhr.getResponseHeader("MyHeader"); let allHeaders xhr.getAllResponseHeaders();
```

- 服务器可以使用头部做什么？
  - 向浏览器传递额外的结构化数据。
- getAllResponseHeaders()方法通常返回什么字符串？

```
Date: Sun, 14 Nov 2004 18:04:03
GMT Server: Apache/1.3.29 (Unix) 
Vary: Accept 
X-Powered-By: PHP/4.3.8 
Connection: close 
Content-Type: text/html; 
charset=iso-8859-1
```

-  通过解析以上头部字段的输出，
  - 就可以知道服务器发送的所有头部
  - 而不需要单独去检查了

### **24.1.3 GET**请求

- 最常用的请求方法是什么？
  - GET请求，
- GET请求用于什么？
  - 向服务器查询某些信息。
- 必要时，需要在GET请求的URL后面添加什么？
  - 查询字符串参数。
- 对XHR而言，查询字符串必须怎么处理？
  - 正确编码后
  - 添加到URL后面，
  - 然后再传给open()方法。 

- 发送GET请求最常见的一个错误是什么？
  - 查询字符串格式不对。
- 查询字符串中的每个名和值都必须怎么编码？
  - encodeURIComponent()编码，
  - 所有名/值对必须以和号（&）分隔

```
xhr.open("get", "example.php?name1=value1&name2=value2", true);
```

- 如何将查询字符串参数添加到现有的URL末尾？

```
function addURLParam(url, name, value) {

    url += (url.indexOf("?") == -1 ? "?" : "&");
    
    url += encodeURIComponent(name) + "=" + encodeURIComponent(value);
    
    return url;
}
```

- 这里定义了一个addURLParam()函数，它接收3个参数：
  - 要添加查询字符串的URL、
  - 查询参数
  - 参数值。
- 这个addURLParam()函数会检查什么？
  - URL中是否已经包含问号
    - （以确定是否已经存在其他参数）。
  - 如果没有，则加上一个问号；
    - 否则就加上一个和号。
  - 分别对参数名和参数值进行编码，
    - 并添加到URL末尾。
  - 最后一步是返回更新后的URL。

- 使用这个函数可以做什么？
  - 构建请求URL

```
let url = "example.php";

// 添加参数
url = addURLParam(url, "name", "Nicholas");
url = addURLParam(url, "book", "Professional JavaScript");

// 初始化请求 
xhr.open("get", url, false);
```

- 使用addURLParam()函数可以保证什么？
  - 通过XHR发送请求的URL格式正确。

### **24.1.4 POST**请求

- POST请求用于什么？
  - 向服务器发送应该保存的数据。
- 每个POST请求都应该做什么？
  - 在请求体中携带提交的数据，
    - 而GET请求则不然。
- POST请求的请求体可以包含非常多的数据，
  - 而且数据可以是任意格式。
- 如何初始化POST请求？
  - open()方法的第一个参数要传"post"

```
xhr.open("post", "example.php", true);
```

- 给send()方法传入什么？

  - 要发送的数据。

- 请求体可以传入什么？

  - 序列化之后的XML DOM文档

  - 任意字符串

- 对服务器而言，POST请求与提交表单是否一样？

  - 不一样

- 服务器如何取得浏览器发送的数据？

  - 读取原始POST数据

- 如何使用XHR模拟表单提交？

  - 第一步需要把ContentType头部

    设置为"application/x-www-formurlencoded"，

    - 这是提交表单时使用的内容类型。

  - 第二步是创建对应格式的字符串。

    - POST数据使用与查询字符串相同的格式。
      - 使用第14章的serialize()函数序列化

```
function submitData() {
    let xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function () {
        if (xhr.readyState == 4) {
            if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
                alert(xhr.responseText);
            } else {
                alert("Request was unsuccessful: " + xhr.status);
            }
        }
    };
    xhr.open("post", "postexample.php", true);
    xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    let form = document.getElementById("user-info");
    xhr.send(serialize(form));
}
```

- PHP文件postexample.php可以通过什么取得POST的数据？
  - $_POST

```
< ? php header("Content-Type: text/plain");
echo << < EOF Name: {
    $_POST['user-name']
}
Email: {
    $_POST['user-email']
}
EOF; ? >
```

- 假如没有发送Content-Type头部，
  - PHP的全局$_POST变量中就不会包含数据，
  - 而需要通过$HTTP_RAW_POST_DATA来获取数据 

- POST请求和GET请求谁要占用更多资源？

  - POST

- 从性能方面说， 发送相同数量的数据

  GET和POST哪个更快？

  - GET请求比POST请求要快两倍

### **24.1.5 XMLHttpRequest Level 2** 

#### \01. **FormData**类型

- FormData类型便于什么？
  - 表单序列化
  - 创建与表单类似格式的数据然后通过XHR发送。 

- 如何创建了一个FormData对象，并填充了一些数据？

```
let data = new FormData();
data.append("name", "Nicholas");
```

- append()方法接收两个参数？
  - 键和值，
  - 相当于表单字段名称和值。
- 通过直接给FormData构造函数传入一个表单元素，
  - 也可以将表单中的数据作为键/值对填充进去： 

```
let data = new FormData(document.forms[0]);
```

- 有了FormData实例，
  - 可以直接传给XHR对象的send()方法

```
let xhr = new XMLHttpRequest();

xhr.onreadystatechange = function () {

    if (xhr.readyState == 4) {
    
        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
        
            alert(xhr.responseText);
            
        } else {
        
            alert("Request was unsuccessful: " + xhr.status);
        }
    }
};

xhr.open("post", "postexample.php", true);

let form = document.getElementById("user-info");

xhr.send(new FormData(form));
```

- 使用FormData，
  - 不再需要给XHR对象显式设置任何请求头部了。
- XHR对象能够识别
  - 作为FormData实例传入的数据类型
  - 并自动配置相应的头部

#### \02. 超时

- XHR对象timeout属性用于什么？

  - 表示发送请求后等待多少毫秒
    - 如果响应不成功就中断请求。

- 在给timeout属性设置了一个时间 

  且在该时间过后没有收到响应时，

  XHR对象就会触发什么事件？

  - timeout事件，
  - 调用ontimeout事件处理程序

```
let xhr = new XMLHttpRequest();

xhr.onreadystatechange = function () {
    if (xhr.readyState == 4) {
        try {
            if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
                alert(xhr.responseText);
            } else {
                alert("Request was unsuccessful: " + xhr.status);
            }
        } catch (ex) {
            // 假设由ontimeout处理
        }
    }
};

xhr.open("get", "timeout.php", true);

xhr.timeout = 1000; // 设置1秒超时

xhr.ontimeout = function () {
    alert("Request did not return in a second.");
};

xhr.send(null);
```

- 给timeout设置1000毫秒意味着什么？
  - 如果请求没有在1秒钟内返回则会中断。
  - 触发ontimeout事件处理程序，
  - readyState会变成4，
  - 调用onreadystatechange事件处理程序。
- 如果在超时之后访问status属性会发生什么？
  - 发生错误。
    - 把检查status属性的代码封装在try/catch语句中。

#### \03. **overrideMimeType()**方法

- overrideMimeType()方法用于什么？
  - 重写XHR响应的MIME类型。
- 响应返回的MIME类型决定了什么？
  - XHR对象如何处理响应

```
let xhr = new XMLHttpRequest();
xhr.open("get", "text.php", true);
xhr.overrideMimeType("text/xml");
xhr.send(null);
```

- 这个例子强制让XHR把响应当成XML

  - 而不是纯文本来处理。

- 为了正确覆盖响应的MIME类型，

  必须在什么时候调用overrideMimeType()？

  - send()之前

## **24.2** 进度事件

- 6个进度相关的事件？

  - loadstart：在接收到响应的第一个字节时触发。 

  - progress：在接收响应期间反复触发。 

  - error：在请求出错时触发。 

  - abort：在调用abort()终止连接时触发。 

  - load：在成功接收完响应时触发。 

  - loadend：在通信完成时，
    - 且在error、abort或load之后触发。 

- 每次请求都会触发什么事件？
  - 首先触发loadstart事件
  - 之后是一个或多个progress事件
  - 接着是error、abort或load中的一个
  - 最后以loadend事件结束

### **24.2.1** **load**事件

- load事件用于替代什么事件？
  - readystatechange
- load事件在什么时候触发？
  - 响应接收完成后
    - 这样就不用检查readyState属性了。
- onload事件处理程序是否会收到event对象？
  - 会
- event对象target属性是什么？
  - XHR实例
- 考虑到跨浏览器兼容，如何使用XHR对象变量？

```
let xhr = new XMLHttpRequest();

xhr.onload = function () {
    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
        alert(xhr.responseText);
    } else {
        alert("Request was unsuccessful: " + xhr.status);
    }
};

xhr.open("get", "altevents.php", true);

xhr.send(null);
```

- 只要是从服务器收到响应，无论状态码是什么，
  - 都会触发load事件。
  - 意味着还需要检查status属性才能确定数据是否有效。

### **24.2.2** **progress**事件 

- progress事件在什么时候触发？
  - 浏览器接收数据期间，
  - 这个事件会反复触发。
- 每次触发时
  - onprogress事件处理程序都会收到event对象，
  - 其target属性是XHR对象
  - 且包含3个额外属性？
    - lengthComputable
      - 表示进度信息是否可用；
      - 布尔值，
    - position
      - 接收到的字节数；
    - totalSize
      - 响应的总字节数
      - Content-Length头部

- 如何向用户展示进度？

```
let xhr = new XMLHttpRequest();

xhr.onload = function (event) {
    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
        alert(xhr.responseText);
    } else {
        alert("Request was unsuccessful: " + xhr.status);
    }
};

xhr.onprogress = function (event) {
    let divStatus = document.getElementById("status");
    
    if (event.lengthComputable) {
        divStatus.innerHTML = "Received " + event.position + " of " + event.totalSize + " bytes";
    }
};

xhr.open("get", "altevents.php", true);

xhr.send(null);
```

- 必须在什么时候添加onprogress事件处理程序？
  - open()之前

- 如何计算出已经收到响应的百分比？
  - position
  - Content-Length头部

## **24.3** 跨源资源共享 

- 通过XHR进行Ajax通信的一个主要限制是什么？
  - 跨源安全策略。
- 默认情况下， XHR只能访问什么资源？
  - 与发起请求的页面在同一个域内的
- 跨源资源共享
  - CORS
  - Cross-Origin Resource Sharing
- CORS定义了什么？
  - 浏览器与服务器如何实现跨源通信。
- CORS背后的基本思路是什么？
  - 使用自定义的HTTP头部
  - 允许浏览器和服务器相互了解，
    - 以确实请求或响应应该成功还是失败

- 对于简单的请求，比如GET或POST请求，

  - 没有自定义头部，
  - 请求体是text/plain类型，
  - 这样的请求在发送时会有一个额外的头部Origin。

- Origin头部包含什么？

  - 发送请求的页面的源
    - （协议、域名和端口） 

  - 以便服务器确定是否为其提供响应

- Origin头部的一个示例： 

```
Origin: http://www.nczonline.net
```

- 如果服务器决定响应请求，那么会发送什么头部？
  - Access-Control-Allow-Origin头部，
    - 包含相同的源
    - 如果资源是公开的，
      - 那么就包含"*"

```
Access-Control-Allow-Origin: http://www.nczonline.net
```

- 如果没有这个头部，或者有但源不匹配，则表明什么？
  - 不会响应浏览器请求。 
- 无论请求还是响应都不会包含cookie信息 

- XMLHttpRequest对象原生支持CORS
- 在尝试访问不同源的资源时，
  - CORS行为会被自动触发。
- 如何向不同域的源发送请求？
  - 使用标准XHR对象
  - 并给open()方法传入一个绝对URL

```
let xhr = new XMLHttpRequest();

xhr.onreadystatechange = function () {
    if (xhr.readyState == 4) {
        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
            alert(xhr.responseText);
        } else {
            alert("Request was unsuccessful: " + xhr.status);
        }
    }
};

xhr.open("get", "http://www.somewhere-else.com/page/", true);

xhr.send(null);
```

- 跨域XHR对象

  - 允许访问status和statusText属性，
  - 允许同步请求。

- 出于安全考虑，跨域XHR对象也施加了一些额外限制。 

  - 不能使用setRequestHeader()设置自定义头部。 

  - 不能发送和接收cookie。 

- getAllResponseHeaders()方法始终返回什么？
  - 空字符串。 

### **24.3.1** 预检请求 

- CORS通过预检请求，来允许使用
  - 自定义头部、
  - 除GET和POST之外的方法，
  - 以及不同请求体内容类型。
- 预检请求是什么？
  - （preflighted request）
  - 服务器验证机制
- 如何发送涉及上述某种高级选项的请求？
  - 先向服务器发送一个“预检”请求

- “预检”请求使用什么方法发送？

  - OPTIONS

- “预检”请求包含哪些头部？

  - Origin：
    - 与简单请求相同 

  - Access-Control-Request-Method：
    - 请求希望使用的方法

  - Access-Control-Request-Headers：
    - （可选）要使用的逗号分隔的自定义头部列表

- 下面是一个假设的POST请求，包含自定义的NCZ头部：

```
Origin: http://www.nczonline.net 
Access-Control-Request-Method: POST 
Access-Control-Request-Headers: NCZ
```

- 在这个请求发送后，

  - 服务器可以确定是否允许这种类型的请求。

- 服务器会在响应中发送哪些头部？

  - Access-Control-Allow-Origin：
    - 与简单请求相同。 

  - Access-Control-Allow-Methods：
    - 允许的方法（逗号分隔的列表）。 

  - Access-Control-Allow-Headers：
    - 服务器允许的头部（逗号分隔的列表）。 

  - Access-Control-Max-Age：
    - 缓存预检请求的秒数。 

```
Access-Control-Allow-Origin: http://www.nczonline.net 

Access-Control-Allow-Methods: POST,GET 

Access-Control-Allow-Headers: NCZ Access-Control-Max-Age: 1728000
```

- 预检请求返回后，
  - 结果会按响应指定的时间缓存一段时间。

- 只有第一次发送这种类型的请求时
  - 才会多发送一次额外的HTTP请求。 

### **24.3.2** 凭据请求

- 默认情况下，跨源请求是否提供凭据？（cookie、HTTP认证和客户端SSL证书）

  - 不提供

- 如何表明请求会发送凭据？

  - 将withCredentials属性设置为true

- 如果服务器允许带凭据的请求，

  那么会在响应中包含哪个HTTP头部？

```
Access-Control-Allow-Credentials: true
```

- 如果发送了凭据请求

  而服务器返回的响应中没有这个头部，

  则浏览器是否会把响应交给JavaScript？

  - 不会

  - （responseText是空字符串，
  - status是0，
  - onerror()被调用）

- 服务器也可以在预检请求的响应中发送这个HTTP头部，

  - 以表明这个源允许发送凭据请求。

## **24.4** 替代性跨源技术 

- 替代性跨源技术是指什么？

  - CORS出现之前，实现跨源Ajax通信

- 虽然CORS目前已经得到广泛支持，

  但这些技术仍然没有过时，

  - 因为它们不需要修改服务器。 

### **24.4.1** 图片探测

- 图片探测是什么？
  - 利用\<img>标签实现跨域通信的
- 任何页面都可以跨域加载图片而不必担心限制，

- 什么技术经常用于图片探测？

  - 动态创建图片，

  - 然后通过它们的onload和onerror事件处理程序

    得知何时收到响应。 

- 图片探测与服务器的通信是怎么样的？

  - 简单、
  - 跨域、
  - 单向的

- 浏览器通过图片探测是否能拿到数据？

  - 不能

- 如何知道什么时候能接收到响应？
  - 通过监听onload和onerror事件

```
let img = new Image();

img.onload = img.onerror = function () {
    alert("Done!");
};

img.src = "http://www.example.com/test?name=Nicholas";
```

- 什么时候请求开始？

  - 设置完src属性之后请求就开始了，

- 图片探测的缺点是什么？
  - 只能发送GET请求
  - 无法获取服务器响应的内容。
  - 这是只能实现浏览器与服务器单向通信的原因。

### **24.4.2 JSONP**

- JSONP是什么的简写？
  - “JSON with padding”
- JSONP看起来跟JSON一样，
  - 只是会被包在一个函数调用里

```
callback({ "name": "Nicholas" });
```

- JSONP格式包含两个部分？
  - 回调
  - 数据。
- 回调是什么？
  - 在页面接收到响应之后应该调用的函数，
- 通常回调函数的名称是什么？
  - 通过请求来动态指定的。
- 数据是什么？
  - 作为参数传给回调函数的JSON数据
- 下面是一个典型的JSONP请求：

```
http://freegeoip.net/json/?callback=handleResponse
```

- JSONP服务怎么指定回调函数的名称？
  - 以查询字符串形式
    - 比如这个例子就把回调函数的名字指定为handleResponse()。

- JSONP调用是怎么实现的？
  - 通过动态创建\<script>元素
  - 并为src属性指定跨域URL。
- 因为JSONP是有效的JavaScript，
  - 所以JSONP响应在被加载完成之后会立即执行。
- 比如下面这个例子：

```
function handleResponse(response) {
 console.log(`
 You're at IP address ${response.ip}, which is in
 ${response.city}, ${response.region_name}`);
}

let script = document.createElement("script");

script.src = "http://freegeoip.net/json/?callback=handleResponse";

document.body.insertBefore(script, document.body.firstChild);
```

- 相比于图片探测，

  - 使用JSONP可以直接访问响应，
  - 实现浏览器与服务器的双向通信。

- JSONP缺点？

  - JSONP是从不同的域拉取可执行代码。
    - 如果这个域并不可信，
      - 则可能在响应中加入恶意内容。
      - 此时除了完全删除JSONP没有其他办法。

  - 不好确定JSONP请求是否失败。
    - 开发者经常使用计时器来决定是否放弃等待响应。
    - 这种方式并不准确，
      - 不同用户的网络连接速度和带宽是不一样的。

## **24.5 Fetch API**

- Fetch API能够执行XMLHttpRequest对象的所有任务，但更容易使用，接 

  口也更现代化，能够在Web工作线程等现代Web工具中使 

  用。XMLHttpRequest可以选择异步，而Fetch API则必须是异步。Fetch 

  API是WHATWG的一个“活标准”（

  living standard），用规范原文说，就 

  是“Fetch标准定义请求、响应，以及绑定二者的流程：获取（

  fetch）”。 

  Fetch API本身是使用JavaScript请求资源的优秀工具，同时这个API也能 

  够应用在服务线程（

  service worker）中，提供拦截、重定向和修改通过 

  fetch()生成的请求接口。 