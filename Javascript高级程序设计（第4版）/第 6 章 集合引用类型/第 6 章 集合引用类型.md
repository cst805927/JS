# 第 6 章 集合引用类型

## 本章内容

- 对象

- 数组与定型数组 

- Map、WeakMap、Set以及WeakSet类型

## **6.1 Object** 

- Object的实例很适合做什么？
  -  存储
  -  在应用程序间交换数据。
  
- 显式地创建Object的实例有哪两种方式？
  - new Object（）
  - 对象字面量

```
let person = new Object(); 
person.name = "Nicholas"; 
person.age = 29;
```

- 对象字面量是什么？
  - 对象的简写形式
- 对象字面量的目的是什么？
  - 为了简化包含大量属性的对象的创建

```
let person = { 
	name: "Nicholas", 
	age: 29 
};
```

- 在ECMAScript中，表达式上下文指的是什么？

  - 期待返回值的上下文

- 为什么上述代码中左大括号表示一个表达式的开始？

  - 因为赋值操作符表示后面要期待一个值

- 同样是左大括号，

  如果出现在语句上下文中，比如if语句的条件后面，

  则表示什么？

  -  一个语句块的开始。 

- 在最后一个属性后面加上逗号

  在什么浏览器中会导致报错？

  - 非常老的浏览器
    - 现代浏览器都支持这种写法

- 在对象字面量表示法中，属性名可以是什么类型？

  - 字符串
  - 数值

```
let person = {
	"name": "Nicholas", 
	"age": 29, 
	5: true 
};
```

- 数值属性会自动执行什么操作？

  - 转换为字符串。 

- 如何用对象字面量表示法来定义一个

  只有默认属性和方法的对象

  - 使用一对大括号，中间留空

```
let person = {}; // 与new Object()相同 
person.name = "Nicholas";
person.age = 29;
```

- 对象字面量表示法通常只在什么场景才使用？
  - 为了让属性一目了然时 

- 在使用对象字面量表示法定义对象时

  是否会实际调用Object构造函数？

  - 不会

- 为什么开发者更倾向于使用对象字面量表示法？

  - 因为对象字面量代码更少
    - 看起来有封装所有相关数据的感觉。

- 对象字面量已经成为做什么的主要方式？
  - 给函数传递大量可选参数

```
function displayInfo(args) { 
	let output = ""; 
	if (typeof args.name == "string"){ 
		output += "Name: " + args.name + "\n"; 
	}
	if (typeof args.age == "number") { 
		output += "Age: " + args.age + "\n"; 
	}
	alert(output); 
}
displayInfo({ name: "Nicholas", age: 29 }); displayInfo({ name: "Greg" })
```

- 这种模式非常适合什么的情况？
  - 函数有大量可选参数
- 一般来说，哪种参数更直观？
  - 命名参数
    - 但在可选参数过多时就显得笨拙了。
- 处理参数的最好的方式是什么？
  - 对必选参数使用命名参数，
  - 再通过一个对象字面量来封装多个可选参数。 

- 存取属性由哪几种方式
  - 点语法
  - 中括号语法
- 在使用中括号时，要在括号内使用属性名的什么形式？
  - 字符串
- 从功能上讲，这两种存取属性的方式有什么区别？
  - 没有区别
- 使用中括号的主要优势是什么？
  - 可以通过变量访问属性

```
let propertyName = "name"; console.log(person[propertyName]); // "Nicholas"
```

- 如果属性名中

  包含可能会导致语法错误的字符，

  或包含关键字/保留字时

  或包含非字母数字字符的，

  使用什么语法存取属性？

  - 中括号语法

```
person["first name"] = "Nicholas";
```

- 为什么"first name"不能使用点语法来访问？
  - 因为"first name"中包含一个空格，

- 哪个语法是首选的属性存取方式？
  - 点语法

### 6.1.1 in操作符

- in 运算符用于什么？
  - 检测属性是否存在于对象中

### 6.1.2 toString()方法

- Object的 toString()方法返回的字符串格式是怎样的？
  - “[object Type]”
    - 其中 Type是对象的类型。
- Object的 toString()方法的规则？
  - null，
    - Type对应为“Null”;
  - undefined，
    - Type对应为“Undefined”。

## **6.2** **Array** 

- 数组中每个槽位可以存储什么类型的数据？
  - 任意类型
- ECMAScript数组的大小是怎么样的？
  - 动态的，
    - 会随着数据添加而自动增长。 

### **6.2.1** 创建数组 

- 有哪几种基本的方式可以创建数组？
  - 使用Array构造函数
  - 使用数组字面量表示法

```
let colors = new Array();
```

- 给构造函数传入一个表示数组中元素的数量数值，

  然后自动执行什么操作？

  - length属性就会被自动创建并设置为这个值。

```
let colors = new Array(20);
```

- 给Array构造函数传入要保存的元素

```
let colors = new Array("red", "blue", "green");
```

- 在使用Array构造函数时，省略new操作符，

  结果有什么区别？

  - 结果一样

```
let colors = Array(3); // 创建一个包含3个元素的数组 let names = Array("Greg"); // 创建一个只包含一个元素，即字符串"Greg"的数组
```

- 在使用数组字面量表示法创建数组是否会调用Array构造函数？

  - 不会

- Array构造函数还有哪两个ES6新增的

  用于创建数组的静态方法？

  - from()
  - of()

- from()用于什么？
  - 将类数组结构转换为数组实例
- of()用于什么？
  - 将一组参数转换为数组实例。
- Array.from()的第一个参数是什么？
  - 一个类数组对象，
    - 即任何可迭代的结构， 
  - 或者有一个length属性和可索引元素的结构

```
// 字符串会被拆分为单字符数组 console.log(Array.from("Matt")); // ["M", "a", "t", "t"] 
// 可以使用from()将集合和映射转换为一个新数组 
const m = new Map().set(1, 2) .set(3, 4); 
const s = new Set().add(1) .add(2) .add(3) .add(4); 
console.log(Array.from(m)); // [[1, 2], [3, 4]] console.log(Array.from(s)); // [1, 2, 3, 4] 
// Array.from()对现有数组执行浅复制
const a1 = [1, 2, 3, 4]; 
const a2 = Array.from(a1); 
console.log(a1); // [1, 2, 3, 4] 
alert(a1 === a2); // false
// 可以使用任何可迭代对象 
const iter = { *[Symbol.iterator]() {
		yield 1;
		yield 2; 
		yield 3; 
		yield 4; 
	} 
};
console.log(Array.from(iter)); // [1, 2, 3, 4] 
// arguments对象可以被轻松地转换为数组 
function getArgsArray() { 
	return Array.from(arguments); 
}
console.log(getArgsArray(1, 2, 3, 4)); 
// [1, 2, 3, 4] 
// from()也能转换带有必要属性的自定义对象 
const arrayLikeObject = { 0: 1, 1: 2, 2: 3, 3: 4, length: 4 };
console.log(Array.from(arrayLikeObject)); // [1, 2, 3, 4]
```

- Array.from()还接收第二个可选的映射函数参数。

  这个函数可以做什么？

  - 直接增强新数组的值

- Array.from()接收第三个可选参数，用于什么？
  - 指定映射函数中this的值
    - 但这个重写的this值在箭头函数中不适用

```
const a1 = [1, 2, 3, 4]; 
const a2 = Array.from(a1, x => x**2); 
const a3 = Array.from(a1, function(x) {
	return x**this.exponent
}, {exponent: 2});
console.log(a2); // [1, 4, 9, 16] 
console.log(a3); // [1, 4, 9, 16]
```

- Array.of()可以做什么？

  - 把一组参数转换为数组

- Array.of()方法用于替代在ES6之前常用的什么方法？

  - Array.prototype.slice.call(arguments)

    - 一种异常笨拙的

      将arguments对象转换为数组的写法： 

```
console.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4] console.log(Array.of(undefined)); // [undefined]
```

### **6.2.2** 数组空位 

- 使用数组字面量初始化数组时，可以使用什么来创建空位 ？
  - 一串逗号
- ECMAScript会将什么值当成空位？
  - 逗号之间相应索引位置的值
- 如何创建一个空位数组？

```
const options = [,,,,,];
console.log(options.length); // 5
console.log(options); // [,,,,,]
```

- ES6新增方法普遍将空位当成什么元素？
  - 存在的元素

```
const options = [1,,,,5];
for (const option of options) {
	console.log(option === undefined);
}
// false
// true
// true
// true
// false
```

```
const a = Array.from([,,,]);
for (const val of a) {
	alert(val === undefined);
}
// true
// true
// true
alert(Array.of(...[,,,]));
for (const [index, value] of options.entries()) {
	alert(value);
}
// 1
// undefined
// undefined
// undefined
// 5
```

- ES6之前的方法是否会忽略空位？
  - 会

```
const options = [1,,,,5];
// map()会跳过空位置
console.log(options.map(() => 6));// [6, undefined, undefined, undefined, 5]

// join()视空位置为空字符串
console.log(options.join('-')); // "1----5"
```

- 为什么实践中要避免使用数组空位？
  - 行为不一致
  - 存在性能隐患
- 如果确实需要空位，则可以怎么做？
  - 显式地用undefined值代替

### **6.2.3** 数组索引 

- 要取得或设置数组的值，需要做什么？
  - 使用中括号
  - 并提供相应值的数字索引，

```
let colors = ["red", "blue", "green"]; // 定义一个字符串数组 
alert(colors[0]); // 显示第一项 
colors[2] = "black"; // 修改第三项 
colors[3] = "brown"; // 添加第四项
```

- 在中括号中提供的索引表示什么？
  - 要访问的值。
- 如果索引小于数组包含的元素数，则返回什么？
  - 存储在相应位置的元素，
- 如果把一个值设置给超过数组最大索引的索引，则会发生什么？
  - 则数组长度会自动扩展到该索引值加1

- 数组中元素的数量保存在什么属性中？

  这个属性始终返回什么？

  - length属性
  - 返回0或大于0的值

```
let colors = ["red", "blue", "green"]; // 创建一个包含3个字符串的数组 
let names = []; // 创建一个空数组 alert(colors.length); // 3
alert(names.length); // 0
```

- 数组length属性的独特之处在于什么？
  - ，它不是只读的
- 通过修改length属性，可以做什么？
  - 从数组末尾删除或添加元素。

```
let colors = ["red", "blue", "green"]; // 创建一个包含3个字符串的数组 
colors.length = 2; 
alert(colors[2]); // undefined
```

- 如果将length设置为大于数组元素数的值，则会发生什么？
  - 新添加的元素都将以undefined填充，

```
let colors = ["red", "blue", "green"]; // 创建一个包含3个字符串的数组 
colors.length = 4; 
alert(colors[3]); // undefined
```

- 使用length属性可以方便地做什么？
  - 向数组末尾添加元素

```
let colors = ["red", "blue", "green"]; // 创建一个包含3个字符串的数组 
colors[colors.length] = "black"; // 添加一种颜色（位置3） 
colors[colors.length] = "brown"; // 再添加一种颜色（位置4）
```

- 数组中最后一个元素的索引始终是什么？
  - length - 1

```
let colors = ["red", "blue", "green"]; // 创建一个包含3个字符串的数组 
colors[99] = "black"; // 添加一种颜色（位置99） alert(colors.length); // 100
```

- 数组最多可以包含4 294 967 295个元素

  以这个最大值作为初始值创建数组，可能导致什么？

  - 脚本运行时间过长的错误

### **6.2.4** 检测数组 

- 在只有一个网页（因而只有一个全局作用域）的情况下，

  如何判断一个对象是不是数组？

  - 使用instanceof操作符

```
if (value instanceof Array){ // 操作数组 }
```

- 涉及两个不同的全局执行上下文，因此就会有什么？
  - 两个不同版本的Array构造函数

- 如果要把数组从一个框架传给另一个框架，则会发生什么？

  - 则这个数组的构造函数将有别于

    在第二个框架内本地创建的数组。

- Array.isArray()方法的目的就是什么？
  - 确定一个值是否为数组
    - 而不用管它是在哪个全局执行上下文中创建的。

```
if (Array.isArray(value)){ // 操作数组 }
```

### **6.2.5** 迭代器方法

- 在ES6中，Array的原型上暴露了3个用于检索数组内容的方 

  法？

  - keys()
    - 返回数组索引的迭代器
  - values()
    - 返回数组元素的迭代器
  - entries()
    - 返回索引/值对的迭代器

```
const a = ["foo", "bar", "baz", "qux"]; 
// 因为这些方法都返回迭代器，所以可以将它们的内容 
// 通过Array.from()直接转换为数组实例 
const aKeys = Array.from(a.keys()); 
const aValues = Array.from(a.values()); 
const aEntries = Array.from(a.entries()); console.log(aKeys); // [0, 1, 2, 3] console.log(aValues); // ["foo", "bar", "baz", "qux"] 
console.log(aEntries); // [[0, "foo"], [1, "bar"], [2, "baz"], [3, "qux"]]
```

- 使用ES6的解构可以非常容易地做什么？
  - 在循环中拆分键/值对

```
const a = ["foo", "bar", "baz", "qux"]; 
for (const [idx, element] of a.entries()) { 
	alert(idx); 
	alert(element); 
}
// 0 
// foo
// 1 
// bar
// 2 
// baz
// 3
// qux
```

### **6.2.6** 复制和填充方法

- ES6新增了两个复制和填充方法？
  - 批量复制方法copyWithin()，
  - 填充数组方法fill()。

- 这两个方法的函数签名相似之处？
  - 都需要指定既有数组实例上的一个范围，
    - 包含开始索引，不包含结束索引
- 使用这个方法是否会改变数组的大小？
  - 不会
- 使用fill()方法可以做什么？
  - 向一个已有的数组中插入全部或部分相同的值 

- 开始索引用于？
  - 指定开始填充的位置
  - 它是可选的
- 如果不提供结束索引？
  - 则一直填充到数组末尾

- 负值索引从哪里开始计算？
  - 数组末尾
  - 想象成数组长度加上它得到的一个正索引

```
const zeroes = [0, 0, 0, 0, 0]; // 用5填充整个数组 
zeroes.fill(5); 
console.log(zeroes); // [5, 5, 5, 5, 5] zeroes.fill(0); // 重置
// 用6填充索引大于等于3的元素 
zeroes.fill(6, 3);
console.log(zeroes); // [0, 0, 0, 6, 6] zeroes.fill(0); // 重置
// 用7填充索引大于等于1且小于3的元素 
zeroes.fill(7, 1, 3);
console.log(zeroes);// [0, 7, 7, 0, 0]; 
zeroes.fill(0); // 重置 
// 用8填充索引大于等于1且小于4的元素
// (-4 + zeroes.length = 1) 
// (-1 + zeroes.length = 4) 
zeroes.fill(8, -4, -1);
console.log(zeroes); // [0, 8, 8, 8, 0];
```

- fill()静默忽略什么的索引范围？
  - 超出数组边界、
  - 零长度
  - 方向相反的

```
const zeroes = [0, 0, 0, 0, 0]; // 索引过低，忽略 zeroes.fill(1, -10, -6); 
console.log(zeroes); // [0, 0, 0, 0, 0] 
// 索引过高，忽略 
zeroes.fill(1, 10, 15);
console.log(zeroes); // [0, 0, 0, 0, 0] 
// 索引反向，忽略 
zeroes.fill(2, 4, 2); 
console.log(zeroes); // [0, 0, 0, 0, 0]
// 索引部分可用，填充可用部分 
zeroes.fill(4, 3, 10) 
console.log(zeroes); // [0, 0, 0, 4, 4]
```

- copyWithin()会做什么？
  - 按照指定范围浅复制数组中的部分内容，
  - 然后将它们插入到指定索引开始的位置

- copyWithin()开始索引和结束索引使用什么样的计算方法？
  - 与fill()同样

```
let ints, reset = () => 
	ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; 
reset(); 
// 从ints中复制索引0开始的内容，插入到索引5开始的位置 
// 在源索引或目标索引到达数组边界时停止 ints.copyWithin(5); 
console.log(ints); // [0, 1, 2, 3, 4, 0, 1, 2, 3, 4] reset(); 
// 从ints中复制索引5开始的内容，插入到索引0开始的位置 
ints.copyWithin(0, 5); 
console.log(ints); // [5, 6, 7, 8, 9, 5, 6, 7, 8, 9] reset();
// 从ints中复制索引0开始到索引3结束的内容 
// 插入到索引4开始的位置
ints.copyWithin(4, 0, 3); 
alert(ints); // [0, 1, 2, 3, 0, 1, 2, 7, 8, 9] reset(); 
// JavaScript引擎在插值前会完整复制范围内的值 
// 因此复制期间不存在重写的风险 
ints.copyWithin(2, 0, 6); 
alert(ints); // [0, 1, 0, 1, 2, 3, 4, 5, 8, 9] reset();
// 支持负索引值，与fill()相对于数组末尾计算正向索引的过程是一样的 
ints.copyWithin(-4, -7, -3);
alert(ints); // [0, 1, 2, 3, 4, 5, 3, 4, 5, 6]
```

- copyWithin()静默忽略的索引范围？
  - 超出数组边界
  - 零长度
  - 方向相反

```
let ints, reset = () => ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; 
reset(); 
// 索引过低，忽略
ints.copyWithin(1, -15, -12); 
alert(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; reset()
// 索引过高，忽略 
ints.copyWithin(1, 12, 15); 
alert(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; reset(); 
// 索引反向，忽略 
ints.copyWithin(2, 4, 2); 
alert(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; reset(); 
// 索引部分可用，复制、填充可用部分 
ints.copyWithin(4, 7, 10) 
alert(ints); // [0, 1, 2, 3, 7, 8, 9, 7, 8, 9];
```

### **6.2.7** 转换方法

- 所有对象都有方法？
  - toLocaleString()
  - toString()
  - valueOf()
  
- 数组的转换方法返回什么？
  - valueOf()返回的还是数组本身。
  - toString()返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串
    - 对数组的每个值都会调用其toString()方法
  - toLocaleString()方法返回由数组中每个值的等效字符串拼接而成的逗号分隔的字符串
    - 对数组的每个值都会调用其toLocaleString()方法

```
let colors = ["red", "blue", "green"]; 
// 创建一个包含3个字符串的数组 
alert(colors.toString()); // red,blue,green alert(colors.valueOf()); // red,blue,green alert(colors); // red,blue,green
```

- 为什么会在后台调用数组的toString()方法，
  - 因为alert()期待字符串

```
let person1 = { 
	toLocaleString() { return "Nikolaos"; },
	toString() { return "Nicholas"; } 
};
let person2 = { 
	toLocaleString() { return "Grigorios"; },
	toString() { return "Greg"; } 
};
let people = [person1, person2]; 
alert(people); // Nicholas,Greg alert(people.toString()); // Nicholas,Greg alert(people.toLocaleString()); // Nikolaos,Grigorios
```

- 如果想使用不同的分隔符，则可以使用？
  - join()方法

- join()方法接收一个参数？
  - 字符串分隔符
- join()方法返回？
  - 包含所有项的字符串

```
let colors = ["red", "green", "blue"]; alert(colors.join(",")); // red,green,blue alert(colors.join("||")); // red||green||blue
```

-  如果数组中某一项是null或undefined

  则在join()、toLocaleString()、toString()、valueOf()返回的结果中会怎么表示

  - 空字符串

-  split()方法与join()方法有哪些区别?

   -  所属的对象不同

      - split()方法属于 String 和 RegExp对象，


      - join()方法属于Array对象


   - 功能不同

     - split()方法
       - 将字符串分割为数组，

     - join()方法
       - 将数组中的元素衔接成一个字符串

### **6.2.8** 栈方法

- ECMAScript数组提供了什么以实现类似栈的行为。？
  - push()和pop()方法

- push()方法接收参数？
  - 任意数量的参数
  - 并将它们添加到数组末尾
  
- push()方法返回什么？
  - 数组的最新长度

- pop()方法则用于？
  - 删除数组的最后一项
  - 同时减少数组的length值，

- pop()方法返回什么？
  - 被删除的项

```
let colors = new Array(); // 创建一个数组 
let count = colors.push("red", "green"); // 推入两项 alert(count); // 2 
count = colors.push("black"); // 再推入一项 alert(count); // 3 
let item = colors.pop(); // 取得最后一项 
alert(item); // black
alert(colors.length); // 2
```

```
let colors = ["red", "blue"]; 
colors.push("brown"); // 再添加一项
colors[3] = "black"; // 添加一项 alert(colors.length); // 4 
let item = colors.pop(); // 取得最后一项
alert(item); // black
```

### **6.2.9** 队列方法

- shift()会做什么？
  - 会删除数组的第一项并返回它
  - 然后数组长度减1
- 使用什么，可以把数组当成队列来使用？
  - shift()
  - push()，

```
let colors = new Array(); // 创建一个数组 
let count = colors.push("red", "green"); // 推入两项 alert(count); // 2 
count = colors.push("black"); // 再推入一项 alert(count); // 3 
let item = colors.shift(); // 取得第一项 
alert(item); // red 
alert(colors.length); // 2
```

- unshift()执行什么操作？
  - 在数组开头添加任意多个值
  - 然后返回新的数组长度

- 如何在相反方向上模拟队列？
  - 通过使用unshift()和pop()，

```
let colors = new Array(); // 创建一个数组 
let count = colors.unshift("red", "green"); // 从数组开头推入两项 
alert(count); // 2 
count = colors.unshift("black"); // 再推入一项 alert(count); // 3 
let item = colors.pop(); // 取得最后一项 
alert(item); // green 
alert(colors.length); // 2
```

### **6.2.10** 排序方法

- 数组有两个方法可以用来对元素重新排序？
  - reverse()
    - 将数组元素反向排列
  - sort()

```
let values = [1, 2, 3, 4, 5]; 
values.reverse(); 
alert(values); // 5,4,3,2,1
```

- 默认情况下，sort()会按照什么顺序重新排列数组元素？
  - 升序
- sort()是怎么比较数组元素的？
  - 在每一项上调用String()转型函数
  - 然后比较字符串来决定顺序

```
let values = [0, 1, 5, 10, 15]; 
values.sort();
alert(values); // 0,1,10,15,5
```

- sort()方法可以接收一个比较函数，用于做什么？
  - 判断哪个值应该排在前面。

- 比较函数接收两个参数，然后执行什么操作？
  - 如果第一个参数应该排在第二个参数前面
    - 返回负值
  - 如果两个参数相等
    - 返回0
  - 如果第一个参数应该排在第二个参数后面
    - 返回正值

```
function compare(value1, value2) { 
	if (value1 < value2) { 
		return -1;
	} else if (value1 > value2) {
		return 1;
	} else { 
		return 0;
	} 
}
```

```
let values = [0, 1, 5, 10, 15]; values.sort(compare); 
alert(values); // 0,1,5,10,15
```

- 如何让比较函数产生降序效果？
  - 把返回值交换一下

```
function compare(value1, value2) { 
	if (value1 < value2) {
		return 1;
	} else if (value1 > value2) { 
		return -1; 
	} else { 
		return 0;
	} 
}
let values = [0, 1, 5, 10, 15]; values.sort(compare); 
alert(values); // 15,10,5,1,0
```

- 这个比较函数还可简写为一个箭头函数

```
let values = [0, 1, 5, 10, 15]; 
values.sort((a, b) => a < b ? 1 : a > b ? -1 : 0); alert(values); // 15,10,5,1,0
```

- reverse()和sort()都返回调用它们的数组的引用？
  - 是
- 如果数组的元素是数值，或者是其valueOf()方法返回数值的对象，这个比较函数还可以写成什么？
  - 可以直接用第二个值减去第一个值

```
function compare(value1, value2){ 
	return value2 - value1; 
}
```

### **6.2.11** 操作方法

- concat()方法可以做什么？
  - 首先会创建一个当前数组的副本
  - 然后再把它的参数添加到副本末尾
  - 最后返回这个新构建的数组

- 如果传入一个或多个数组，则concat()会？
  - 把这些数组的每一项都添加到结果数组

- 如果参数不是数组，则concat()会？
  - 直接把它们添加到结果数组末尾

```
let colors = ["red", "green", "blue"]; 
let colors2 = colors.concat("yellow", ["black", "brown"]); 
console.log(colors); // ["red", "green","blue"] console.log(colors2); // ["red", "green", "blue", "yellow", "black", "brown"]
```

- 打平数组参数的行为是否可以重写？
  - 是
- 哪个符号能够阻止concat()打平参数 ？
  - Symbol.isConcatSpreadable
    - 设置为true可以强制打平类数组对象

```
let colors = ["red", "green", "blue"]; 
let newColors = ["black", "brown"]; 
let moreNewColors = { 
	[Symbol.isConcatSpreadable]: true, 
	length: 2,
	0: "pink",
	1: "cyan" 
};
newColors[Symbol.isConcatSpreadable] = false; 
// 强制不打平数组 
let colors2 = colors.concat("yellow", newColors); 
// 强制打平类数组对象 
let colors3 = colors.concat(moreNewColors); console.log(colors); // ["red", "green", "blue"] console.log(colors2); // ["red", "green", "blue", "yellow", ["black", "brown"]] 
console.log(colors3); // ["red", "green", "blue", "pink", "cyan"]
```

- 方法slice()用于什么？
  - 创建一个包含原有数组中一个或多个元素的新数组
- slice()方法可以接收什么参数？
  - 返回元素的开始索引
  - 返回元素的结束索引。
- slice()方法任何参数为NaN，会怎么处理？
  - 都会被当作0来处理。
- 如果只有一个参数，则slice()会返回什么？
  - 该索引到数组末尾的所有元素
- 如果有两个参数，则slice()返回什么？
  - 从开始索引到结束索引对应的所有元素
    - 其中不包含结束索引对应的元素
- 这个操作是否影响原始数组？
  - 不

```
let colors = ["red", "green", "blue", "yellow", "purple"];
let colors2 = colors.slice(1); 
let colors3 = colors.slice(1, 4);
alert(colors2); // green,blue,yellow,purple alert(colors3); // green,blue,yellow
```

- 如果slice()的参数有负值，那么会执行什么操作？
  - 就以数值长度加上这个负值的结果确定位置

- 如果slice()的参数结束位置小于开始位置，则？
  - 返回空数组

- splice()的主要目的是？
  - 在数组中间插入元素

- 有3种不同的方式使用splice()方法？
  - 删除
    - 需要给splice()传2个参数
      - 要删除的第一个元素的位置
      - 要删除的元素数量
    - splice(0, 2)
  - 插入
    - 需要给splice()传3个参数：
      - 开始位置
      - 0
      - 要插入的元素
    - splice(2, 0, "red", "green")
  - 替换
    - 传入3个参数
      - 开始位置
      - 要删除元素的数量
      - 要插入的任意多个元素
    - splice(2, 1, "red", "green")

- splice()方法始终返回什么样一个数组？
  - 它包含从数组中被删除的元素
  - （如果没有删除元素，则返回空数组）

```
let colors = ["red", "green", "blue"]; 
let removed = colors.splice(0,1); // 删除第一项 alert(colors); // green,blue 
alert(removed); // red，只有一个元素的数组 
removed = colors.splice(1, 0, "yellow", "orange"); // 在位置1插入两个元素 
alert(colors); // green,yellow,orange,blue alert(removed); // 空数组 
removed = colors.splice(1, 1, "red", "purple"); // 插入两个值，删除一个元素 
alert(colors); // green,red,purple,orange,blue alert(removed); // yellow，只有一个元素的数组
```

### **6.2.12** 搜索和位置方法

- ECMAScript提供两类搜索数组的方法？
  - 按严格相等搜索
  - 按断言函数搜索

#### \01. 严格相等

- ECMAScript提供了哪3个严格相等的搜索方法？
  - indexOf()
  - lastIndexOf()
  - includes()

- 这三个方法都接收哪两个参数？
  - 要查找的元素
  - 一个可选的起始搜索位置

- indexOf()和includes()方法以什么方向搜索？
  - 从数组前头（第一项）开始向后搜索

- lastIndexOf()以什么方向搜索？
  - 从数组末尾（最后一项）开始向前搜索

- indexOf()和lastIndexOf()都返回？
  - 要查找的元素在数组中的位置，
  - 如果没找到则返回-1

- includes()返回？
  - 布尔值
  - 表示是否至少找到一个与指定元素匹配的项

- 在比较第一个参数跟数组每一项时，会使用什么比较？
  - 使用全等（===）比较

```
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; 

alert(numbers.indexOf(4)); // 3 alert(numbers.lastIndexOf(4)); // 5 alert(numbers.includes(4)); // true 

alert(numbers.indexOf(4, 4)); // 5 alert(numbers.lastIndexOf(4, 4)); // 3 alert(numbers.includes(4, 7)); // false 

let person = { name: "Nicholas" }; 
let people = [{ name: "Nicholas" }]; 
let morePeople = [person]; 

alert(people.indexOf(person)); // -1 alert(morePeople.indexOf(person)); // 0 

alert(people.includes(person)); // false alert(morePeople.includes(person)); // true
```

#### \02. 断言函数

- ECMAScript也允许按照定义的断言函数搜索数组，每个索引都会做什么？
  - 调用这个函数

- 断言函数的返回值决定了？
  - 相应索引的元素是否被认为匹配

- 断言函数接收3个参数？
  - 元素
    - 数组中当前搜索的元素
  - 索引
    - 当前元素的索引
  - 数组本身
    - 正在搜索的数组
- 断言函数返回？
  - 布尔值
  - 表示是否匹配

- 什么方法使用了断言函数？
  - find()
  - findIndex()

- 这两个方法都从哪里开始？
  - 从数组的最小索引开始

- find()返回？
  - 第一个匹配的元素
- findIndex()返回？
  - 第一个匹配元素的索引

- 这两个方法也都接收第二个可选的参数，用于？
  - 指定断言函数内部this的值

```
const people = [ 
	{
		name: "Matt", 
		age: 27
	},
	{ 
		name: "Nicholas",
    	age: 29 
    } 
];
alert(people.find(
(element, index, array) => element.age < 28)); 
// {name: "Matt", age: 27} 

alert(people.findIndex(
(element, index, array) => element.age < 28)); // 0
```

- 找到匹配项后，这两个方法都是否再继续搜索？
  - 不

```
const evens = [2, 4, 6]; 
// 找到匹配后，永远不会检查数组的最后一个元素 
evens.find((element, index, array) => { 			
	console.log(element); 
	console.log(index); 
	console.log(array); 
	return element === 4; 
});
// 2 // 0 // [2, 4, 6] 
// 4 // 1 // [2, 4, 6]
```

### **6.2.13** 迭代方法

- ECMAScript为数组定义了5个迭代方法？
  - every()
    - 对数组每一项都运行传入的函数
    - 如果对每一项函数都返回true
      - 则这个方法返回true
  - filter()
    - 对数组每一项都运行传入的函数
    - 函数返回true的项会组成数组之后返回
  - forEach()
    - 对数组每一项都运行传入的函数
    - 没有返回值。
  - map()
    - 对数组每一项都运行传入的函数
    - 返回由每次函数调用的结果构成的数组。 
  - some()
    - 对数组每一项都运行传入的函数
    - 如果有一项函数返回true，
      - 则这个方法返回true。

- 这些方法是否改变调用它们的数组？
  - 不

```
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; 
let everyResult = numbers.every(
	(item, index, array) => item > 2
); 
alert(everyResult); // false 
let someResult = numbers.some(
	(item, index, array) => item > 2
); 
alert(someResult); // true
```

- filter()方法方法基于给定的函数来决定什么？
  - 某一项是否应该包含在它返回的数组中。

- 如何返回一个所有数值都大于2的数组？

```
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; 
let filterResult = numbers.filter(
	(item, index, array) => item > 2
); 
alert(filterResult); // 3,4,5,4,3
```

- filter()方法非常适合做什么？
  - 从数组中筛选满足给定条件的元素。 

- map()方法也会返回一个什么样的数组？

  - 这个数组的每一项都是

    对原始数组中同样位置的元素

    运行传入函数

    而返回的结果。

- 如何将一个数组中的每一项都乘以2，

  并返回包含所有结果的数组？

```
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; 
let mapResult = numbers.map(
	(item, index, array) => item * 2
); 
alert(mapResult); // 2,4,6,8,10,8,6,4,2
```

- map()方法适合做什么？
  - 创建一个与原始数组元素一一对应的新数组。

- forEach()方法相当于什么？
  - 使用for循环遍历数组

```
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; numbers.forEach(
	(item, index, array) => { // 执行某些操作 }
);
```

### **6.2.14** 归并方法

- ECMAScript为数组提供了两个归并方法？
  - reduce()
  - reduceRight()

- 这两个方法都会做什么？
  - 迭代数组的所有项，
  - 并在此基础上构建一个最终返回值。

- reduce()方法以什么方向遍历数组？
  - 从数组第一项开始遍历到最后一项

- reduceRight()以什么方向遍历数组？
  - 从最后一项开始遍历至第一项

- 这两个方法都接收两个参数？

  - 对每一项都会运行的归并函数

  - 可选的以之为归并起点的初始值。

- 传给reduce()和reduceRight()的函数接收4个参数？
  - 上一个归并值
  - 当前项
  - 当前项的索引
  - 数组本身

- 这个函数返回的任何值都会作为什么？
  - 下一次调用同一个函数的第一个参数

- 如果没有给这两个方法传入可选的第二个参数（作为归并起点值）则第一次迭代将从哪里开始？
  - 数组的第二项
    - 传给归并函数的第一个参数是数组的第一项，
    - 第二个参数是数组的第二项。

- 可以使用什么函数执行累加数组中所有数值的操作？
  - reduce()

```
let values = [1, 2, 3, 4, 5]; 
let sum = values.reduce(
	(prev, cur, index, array) => prev + cur
); 
alert(sum); // 15
```

- reduceRight()方法例子：

```
let values = [1, 2, 3, 4, 5]; 
let sum = values.reduceRight(
	function(prev, cur, index, array){ 
		return prev + cur; 
}); 
alert(sum); // 15
```

## **6.3** 定型数组

跳过

## **6.4** **Map** 

### **6.4.1** 基本**API**

- 如何创建一个空映射？
  - 使用new关键字和Map构造函数

```
const m = new Map();
```

- 如果想在创建的同时初始化实例，要怎么做？
  - 可以给Map构造函数传入一个可迭代对象，
  - 需要包含键/值对数组。

- 可迭代对象中的每个键/值对都会按照什么顺序插入到新映射实例中？
  - 迭代顺序

```
// 使用嵌套数组初始化映射 
const m1 = new Map([ 
	["key1", "val1"], 
	["key2", "val2"], 
	["key3", "val3"] 
]); 
alert(m1.size); // 3 
// 使用自定义迭代器初始化映射 
const m2 = new Map({ 
	[Symbol.iterator]: function*() {
		yield ["key1", "val1"];
		yield ["key2", "val2"];
		yield ["key3", "val3"]; 
	} 
}); 
alert(m2.size); // 3 
// 映射期待的键/值对，无论是否提供
const m3 = new Map([[]]); 
alert(m3.has(undefined)); // true alert(m3.get(undefined)); // undefined
```

- 初始化之后，可以使用什么方法再添加键/值对？
  - set()
- 可以使用什么方法进行查询？
  - get() 
  - has()
- 可以通过什么属性获取映射中的键/值对的数量？
  - size属性
- 可以使用什么方法删除值？
  - delete()
  - clear()

```
const m = new Map(); 
alert(m.has("firstName")); // false alert(m.get("firstName")); // undefined alert(m.size); // 0 

m.set("firstName", "Matt") 
.set("lastName", "Frisbie"); alert(m.has("firstName")); // true alert(m.get("firstName")); // Matt 
alert(m.size); // 2

m.delete("firstName"); // 只删除这一个键/值对 alert(m.has("firstName")); // false alert(m.has("lastName")); // true 
alert(m.size); // 1

m.clear(); // 清除这个映射实例中的所有键/值对 alert(m.has("firstName")); // false alert(m.has("lastName")); // false 
alert(m.size); // 0
```

- set()方法返回什么？
  - 映射实例，
    - 因此可以把多个操作连缀起来，包括初始化声明： 

```
const m = new Map().set("key1", "val1"); m.set("key2", "val2")
.set("key3", "val3"); 
alert(m.size); // 3
```

- Map可以使用什么JavaScript数据类型作为键？
  - 任何数据类型
- Map内部使用什么进行比较操作？
  - SameValueZero
    - ECMAScript规范内部定义，语言中不能使用）
    - 基本上相当于使用严格对象相等的标准来检查键的匹配性。

- 映射的值是否有限制？
  - 没有

```
const m = new Map(); 
const functionKey = function() {}; 
const symbolKey = Symbol();
const objectKey = new Object();
m.set(functionKey, "functionValue"); m.set(symbolKey, "symbolValue"); 
m.set(objectKey, "objectValue"); alert(m.get(functionKey)); // functionValue alert(m.get(symbolKey)); // symbolValue alert(m.get(objectKey)); // objectValue
// SameValueZero比较意味着独立实例不冲突 alert(m.get(function() {})) // undefined
```

- 在映射中用作键和值的对象及其他“集合”类型，

  在自己的内容或属性被修改时是否会改变？

  - 仍然保持不变

```
const m = new Map(); 
const objKey = {}, 
objVal = {}, 
arrKey = [], 
arrVal = [];
m.set(objKey, objVal);
m.set(arrKey, arrVal);
objKey.foo = "foo";
objVal.bar = "bar";
arrKey.push("foo");
arrVal.push("bar");
console.log(m.get(objKey)); // {bar: "bar"} console.log(m.get(arrKey)); // ["bar"]
```

-  SameValueZero比较也可能导致意想不到的冲突

```
const m = new Map(); 
const a = 0/"", // NaN
b = 0/"", // NaN
pz = +0, 
nz = -0; 
alert(a === b); // false 
alert(pz === nz); // true
m.set(a, "foo");
m.set(pz, "bar"); 
alert(m.get(b)); // foo 
alert(m.get(nz)); // bar
```

### **6.4.2** 顺序与迭代

- Map与Object类型的一个主要差异是什么？
  - Map实例会维护键值对的插入顺序，

- 映射实例可以提供一个迭代器（Iterator），能做什么？
  - 以插入顺序生成[key, value]形式的数组

- 可以通过什么方法取得这个迭代器？
  - entries()方法
  - Symbol.iterator属性，它引用entries()

```
const m = new Map([ 
	["key1", "val1"],
	["key2", "val2"], 
	["key3", "val3"] 
]);
alert(m.entries === m[Symbol.iterator]); // true
for (let pair of m.entries()) { 
	alert(pair); 
}
// [key1,val1] 
// [key2,val2] 
// [key3,val3] 
for (let pair of m[Symbol.iterator]()) {
	alert(pair); 
}
// [key1,val1]
// [key2,val2] 
// [key3,val3]
```

- 为什么可以直接对映射实例使用扩展操作，把映射转换为数组？
  - 因为entries()是默认迭代器

```
const m = new Map([ 
	["key1", "val1"], 
	["key2", "val2"], 
	["key3", "val3"] 
]); 
console.log([...m]);
// [[key1,val1],[key2,val2],[key3,val3]]
```

- 如果不使用迭代器，而是使用回调方式，则可以怎么做？
  - 以调用映射的forEach(callback, opt_thisArg)方法
  - 并传入回调
  - 依次迭代每个键/值对。

- 传入的回调接收可选的第二个参数，这个参数用于什么？
  - 重写回调内部this的值

```
const m = new Map([
	["key1", "val1"],
	["key2", "val2"],
	["key3", "val3"] 
]); 
m.forEach((val, key) => alert(`${key} -> ${val}`)); // key1 -> val1
// key2 -> val2
// key3 -> val3
```

- keys()和values()分别返回以什么顺序生成键和值的迭代器？
  - 插入顺序

```
const m = new Map([ 
	["key1", "val1"], 
	["key2", "val2"], 
	["key3", "val3"] ]); 
for (let key of m.keys()) {
	alert(key); 
}
// key1 
// key2 
// key3 
for (let key of m.values()) {
	alert(key); 
}
// value1
// value2 
// value3
```

- 键和值在迭代器遍历时是否可以修改的？
  - 是
- 映射内部的引用是否可以修改？
  - 无法修改
-  为什么可以修改作为键或值的对象内部的属性？
  - 因为这样并不影响它们在映射实例中的身份： 

```
const m1 = new Map([ ["key1", "val1"] ]);
// 作为键的字符串原始值是不能修改的 
for (let key of m1.keys()) {
	key = "newKey";
	alert(key); // newKey
	alert(m1.get("key1")); // val1 
}
const keyObj = {id: 1};
const m = new Map([ [keyObj, "val1"] ]); 
// 修改了作为键的对象的属性，但对象在映射内部仍然引用相同的值 for (let key of m.keys()) { 
	key.id = "newKey"; 
	alert(key); // {id: "newKey"}
	alert(m.get(keyObj)); // val1 
}
alert(keyObj); // {id: "newKey"}
```

### **6.4.3** 选择**Object**还是**Map** 

#### \01. 内存占用 

- 存储单个键/值对所占用的内存数量都会随什么线性增加？
  - 键的数量
- 但给定固定大小的内存，谁大约多存储50%的键/值对？
  - Map

#### \02. 插入性能 

- 插入谁在所有浏览器中一般会稍微快一点儿？
  - Map
- 对这两个类型来说，插入速度是否会随着键/值对数量而线性增加？
  - 不会
- 如果代码涉及大量插入操作，那么显然谁的性能更佳？
  - Map

#### \03. 查找速度 

- 如果只包含少量键/值对，则谁有时候查找速度更快？

  - Object

- 在把Object当成数组使用的情况下

  （比如使用连续整数作为属性），

  浏览器会做什么？

  - 引擎可以进行优化，在内存中使用更高效的布局。
    - 这对Map来说是不可能的。

- 对这两个类型而言，查找速度是否会随着键/值对数量增加 

  而线性增加？

  - 不会

- 如果代码涉及大量查找操作，那么某些情况下可能选 

  择谁更好一些？

  - Object

#### \04. 删除性能  

- 而对大多数浏览器引擎来说，谁的delete()操作都比插入和查找更快？
  - Map
- 如果代码涉及大量删除操作，那么毫无疑问应该选择谁？
  - Map。

## **6.5** **WeakMap**

### **6.5.1** 基本**API**

- 如何实例化一个空的WeakMap？
  - 用new关键字

```
const wm = new WeakMap();
```

- 弱映射中的键只能是什么类型？
  - Object或者继承自Object的类型
    - 尝试使用非对象设置键会抛出TypeError。

- 值的类型是否有限制？
  - 没有
- 如果想在初始化时填充弱映射，则构造函数可以接收什么？
  - 一个可迭代对象
    - 其中需要包含键/值对数组

- 可迭代对象中的每个键/值都会按照什么顺序插入新实例中？
  - 迭代顺序

```
const key1 = {id: 1},
key2 = {id: 2}, 
key3 = {id: 3};
// 使用嵌套数组初始化弱映射 
const wm1 = new WeakMap([
	[key1, "val1"],
	[key2, "val2"],
	[key3, "val3"]
]); 
alert(wm.get(key1)); // val1 
alert(wm.get(key2)); // val2 
alert(wm.get(key3)); // val3 
// 初始化是全有或全无的操作 
// 只要有一个键无效就会抛出错误，导致整个初始化失败 
const wm2 = new WeakMap([ 
	[key1, "val1"],
	["BADKEY", "val2"], 
	[key3, "val3"] ]); 
// TypeError: Invalid value used as WeakMap key typeof wm2;
// ReferenceError: wm2 is not defined 
// 原始值可以先包装成对象再用作键
const stringKey = new String("key1");
const wm3 = new WeakMap([ stringKey, "val1" ]); alert(wm3.get(stringKey)); // "val1"
```

- 初始化之后可以使用什么方法再添加键/值对？
  - set()
- 可以使用什么方法查询？
  - get()
  - has()

- 使用什么方法删除？
  - delete()

```
const wm = new WeakMap(); 
const key1 = {id: 1}, 
key2 = {id: 2}; 
alert(wm.has(key1)); // false 
alert(wm.get(key1)); // undefined
wm.set(key1, "Matt") 
.set(key2, "Frisbie"); 
alert(wm.has(key1)); // true
alert(wm.get(key1)); // Matt 
wm.delete(key1); // 只删除这一个键/值对 alert(wm.has(key1)); // false 
alert(wm.has(key2)); // true
```

- 为什么可以把多个操作连缀起来，包括初始化声明？
  - 因为set()方法返回弱映射实例 

```
const key1 = {id: 1}, 
key2 = {id: 2}, 
key3 = {id: 3};
const wm = new WeakMap().set(key1, "val1"); wm.set(key2, "val2") 
.set(key3, "val3"); 
alert(wm.get(key1)); // val1 
alert(wm.get(key2)); // val2
alert(wm.get(key3)); // val3
```

### **6.5.2** 弱键

- WeakMap中“weak”表示什么意思？
  - 这些键不属于正式的引用，不会阻止垃圾回收

- 为什么只要键存在，因此就不会被当作垃圾回收？
  - 键/值对就会存在于映射中，并被当作对值的引用，

```
const wm = new WeakMap();
wm.set({}, "val");
```

- 为什么当这行代码执行完成后，这个对象键就会被当作垃圾回收？
  - 因为没有指向这个对象的其他引用

- 然后这个键/值对就会发生什么？
  - 从弱映射中消失了，使其成为一个空映射

- 因为值也没有被引用，所以会发生什么？
  - 这对键/值被破坏以后，值本身也会成为垃圾回收的目标

```
const wm = new WeakMap(); 
const container = { key: {} };
wm.set(container.key, "val");
function removeReference() {
	container.key = null; 
}
```

- 上述代码中，为什么这个对象键不会成为垃圾回收的目标？
  - container对象维护着一个对弱映射键的引用

- 如果调用了removeReference()，就会发生什么？
  - 摧毁键对象的最后一个引用，
  - 垃圾回收程序就可以把这个键/值对清理掉

### **6.5.3** 不可迭代键 

- 为什么WakMap没必要提供迭代其键/值对的能力？
  - 因为WeakMap中的键/值对任何时候都可能被销毁，

- WeakMap实例之所以限制只能用对象作为键，是为什么？
  - 为了保证只有通过键对象的引用才能取得值。
- 如果允许原始值，那会有什么问题？
  - 没办法区分
    - 初始化时使用的字符串字面量
    - 和初始化之后使用的一个相等的字符串了

### **6.5.4** 使用弱映射

#### \01. 私有变量

- 弱映射造就了在JavaScript中实现了什么？
  - 真正私有变量的一种新方式

- 私有变量会怎么存储？
  - 存储在弱映射中，
    - 以对象实例为键，
    - 以私有成员的字典为值。 

```
const wm = new WeakMap();
class User {
    constructor(id) {
        this.idProperty = Symbol('id');
        this.setId(id);
    }
    setPrivate(property, value) {
        const privateMembers = wm.get(this) || {};
        privateMembers[property] = value;
        wm.set(this, privateMembers);
    }
    getPrivate(property) {
        return wm.get(this)[property];
    }
    setId(id) {
        this.setPrivate(this.idProperty, id);
    }
    getId() {
        return this.getPrivate(this.idProperty);
    }
}

const user = new User(123);
alert(user.getId()); // 123 
user.setId(456);
alert(user.getId()); // 456
// 并不是真正私有的 
alert(wm.get(user)[user.idProperty]); // 456
```

- 对于上面的实现，外部代码只需要什么，就可以取得“私有”变量了？
  - 拿到对象实例的引用和弱映射，

- 如何避免这种访问，？
  - 可以用一个闭包把WeakMap包装起来，
    - 这样就可以把弱映射与外界完全隔离开了： 

```
const User = (() => {
    const wm = new WeakMap();
    class User {
        constructor(id) {
            this.idProperty = Symbol('id');
            this.setId(id);
        }
        setPrivate(property, value) {
            const privateMembers = wm.get(this) || {};
            privateMembers[property] = value;
            wm.set(this, privateMembers);
        }
        getPrivate(property) {
            return wm.get(this)[property];
        }
        setId(id) {
            this.setPrivate(this.idProperty, id);
        }
        getId(id) {
            return this.getPrivate(this.idProperty);
        }
    }
    return User;
})();
const user = new User(123);
alert(user.getId()); // 123 
user.setId(456);
alert(user.getId()); // 456
```

- 上述代码中拿不到什么，也就无法取得弱映射中对应的值？
  - 弱映射中的健

#### \02. **DOM**节点元数据

- 为什么WeakMap非常适合保存关联元数据？
  - 因为WeakMap实例不会妨碍垃圾回收

```
const m = new Map(); 
const loginButton = document.querySelector('#login')
// 给这个节点关联一些元数据 
m.set(loginButton, {disabled: true});
```

- 假设在上面的代码执行后，页面被JavaScript改变了，

  原来的登录按钮从DOM树中被删掉了。

  为什么对应的DOM节点仍然会逗留在内存中？

  - 由于映射中还保存着按钮的引用

- 如果这里使用的是弱映射，

  那么当节点从DOM树中被删除后，会发生什么？

  - 垃圾回收程序就可以立即释放其内存

    （假设没有其他地方引用这个对象）

```
const wm = new WeakMap();
const loginButton = ocument.querySelector('#login'); // 给这个节点关联一些元数据
wm.set(loginButton, {disabled: true});
```

## **6.6** **Set**

### **6.6.1** 基本**API**

- 如何创建一个空集合？
  - 使用new关键字和Set构造函数

```
const m = new Set();
```

-  如果想在创建的同时初始化实例，则可以怎么做？
  - 给Set构造函数传入一个可迭代对象，
    - 其中需要包含插入到新集合实例中的元素

```
// 使用数组初始化集合 
const s1 = new Set(["val1", "val2", "val3"]); alert(s1.size); // 3 
// 使用自定义迭代器初始化集合 
const s2 = new Set({ 
	[Symbol.iterator]: function*() { 
		yield "val1";
		yield "val2"; 
		yield "val3"; 
	} 
});
alert(s2.size); // 3
```

- 可以使用什么增加值？
  - add()
- 使用什么查询？
  - has()
- 通过什么取得元素数量？
  - size

- 使用什么删除元素？
  - delete()
  - clear() 

```
const s = new Set(); 
alert(s.has("Matt")); // false 
alert(s.size); // 0 
s.add("Matt") 
.add("Frisbie"); 
alert(s.has("Matt")); // true 
alert(s.size); // 2 
s.delete("Matt");
alert(s.has("Matt")); // false alert(s.has("Frisbie")); // true
alert(s.size); // 1
s.clear(); // 销毁集合实例中的所有值 alert(s.has("Matt")); // false alert(s.has("Frisbie")); // false
alert(s.size); // 0
```

- add()返回集合的实例，所以可以进行扫描操作？
  - 将多个添加操作连缀起来，包括初始化：

```
const s = new Set().add("val1");
s.add("val2")
.add("val3"); 
alert(s.size); // 3
```

- Set可以包含什么JavaScript数据类型作为值？
  - 任何数据类型
- 集合也使用什么比较操作？
  - SameValueZero操作
  - （ECMAScript内部定义，无法在语言中使用）

```
const s = new Set();
const functionVal = function() {}; 
const symbolVal = Symbol(); 
const objectVal = new Object();
s.add(functionVal);
s.add(symbolVal);
s.add(objectVal); 
alert(s.has(functionVal)); // true alert(s.has(symbolVal)); // true alert(s.has(objectVal)); // true
// SameValueZero检查意味着独立的实例不会冲突 alert(s.has(function() {})); // false
```

- 用作值的对象和其他“集合”类型

  在自己的内容或属性被修改时是否会改变？

  - 不会

```
const s = new Set(); 
const objVal = {}, arrVal = []; 
s.add(objVal); 
s.add(arrVal);
objVal.bar = "bar"; 
arrVal.push("bar");
alert(s.has(objVal)); // true 
alert(s.has(arrVal)); // true
```

- add()和delete()操作是怎样的？
  - 幂等的
- delete()返回一个什么值，表示什么？
  - 布尔值，
  - 表示集合中是否存在要删除的值

```
const s = new Set(); 
s.add('foo'); 
alert(s.size); // 1 
s.add('foo'); 
alert(s.size); // 1 
// 集合里有这个值
alert(s.delete('foo')); // true 
// 集合里没有这个值
alert(s.delete('foo')); // false
```

### **6.6.2** 顺序与迭代 

- Set是否支持按顺序迭代？为什么？
  - 支持
  - Set会维护值插入时的顺序

- 集合实例可以提供一个迭代器，能做什么？
  - 以插入顺序生成集合内容
- 可以通过什么取得这个迭代器？
  - values()
  - keys()
  - Symbol.iterator属性，它引用values()

```
const s = new Set(["val1", "val2", "val3"]); alert(s.values === s[Symbol.iterator]); // true alert(s.keys === s[Symbol.iterator]); // true 
for (let value of s.values()) { 
	alert(value); 
}
// val1
// val2
// val3 
for (let value of s[Symbol.iterator]()) { 		
	alert(value);
}
// val1 
// val2 
// val3
```

- 因为values()是默认迭代器，所以可以做什么？
  - 直接对集合实例使用扩展操作把集合转换为数组： 

```
const s = new Set(["val1", "val2", "val3"]); console.log([...s]); // ["val1", "val2", "val3"]
```

- 集合的entries()方法返回一个迭代器，可以做什么？
  - 按照插入顺序产生包含两个元素的数组，
    - 这两个元素是集合中每个值的重复出现： 

```
const s = new Set(["val1", "val2", "val3"]);
for (let pair of s.entries()) {
	console.log(pair); 
}
// ["val1", "val1"] 
// ["val2", "val2"] 
// ["val3", "val3"]
```

- 如果不使用迭代器，而是使用回调方式，则可以调用什么？
  - 调用集合的forEach()方法并传入回调，
    - 依次迭代每个键/值对。
- 传入的回调接收可选的第二个参数，这个参数用于什么？
  - 重写回调内部this的值：

```
const s = new Set(["val1", "val2", "val3"]); s.forEach((val, dupVal) => 
	alert(`${val} -> ${dupVal}`
)); 
// val1 -> val1 
// val2 -> val2
// val3 -> val3
```

- 修改集合中值的属性是否会影响其作为集合值的身份？
  - 不会

```
const s1 = new Set(["val1"]); 
// 字符串原始值作为值不会被修改 
for (let value of s1.values()) { 
	value = "newVal"; 
	alert(value); // newVal 
	alert(s1.has("val1")); // true
}
const valObj = {id: 1}; 
const s2 = new Set([valObj]); 
// 修改值对象的属性，但对象仍然存在于集合中 
for (let value of s2.values()) { 
	value.id = "newVal"; 
	alert(value); // {id: "newVal"} 			
	alert(s2.has(valObj)); // true 
}
alert(valObj); // {id: "newVal"}
```

###  **6.6.3** 定义正式集合操作

- 在实现正式集合操作时，需要考虑几个地方？

  - 某些Set操作是有关联性的，

    - 因此最好让实现的方法能支持

      处理任意多个集合实例。 

  - Set保留插入顺序，

    - 所有方法返回的集合必须保证顺序。

  - 尽可能高效地使用内存。

    - 扩展操作符的语法很简洁，
    - 但尽可能避免集合和数组间的相互转换
      - 能够节省对象初始化成本。 

  - 不要修改已有的集合实例。

    - union(a, b)或a.union(b)应该返回
  
      包含结果的新集合实例。

```
class XSet extends Set {
    union(...sets) {
        return XSet.union(this, ...sets)
    }
    intersection(...sets) {
        return XSet.intersection(this, ...sets);
    }
    difference(set) {
        return XSet.difference(this, set);
    }
    symmetricDifference(set) {
        return XSet.symmetricDifference(this, set);
    }
    cartesianProduct(set) {
        return XSet.cartesianProduct(this, set);
    }
    powerSet() {
        return XSet.powerSet(this);
    } // 返回两个或更多集合的并集
    static union(a, ...bSets) {
        const unionSet = new XSet(a);
        for (const b of bSets) {
            for (const bValue of b) {
                unionSet.add(bValue);
            }
        }
        return unionSet;
    }
    // 返回两个或更多集合的交集
    static intersection(a, ...bSets) {
        const intersectionSet = new XSet(a);
        for (const aValue of intersectionSet) {
            for (const b of bSets) {
                if (!b.has(aValue)) {
                    intersectionSet.delete(aValue);
                }
            }
        }
        return intersectionSet;
    } // 返回两个集合的差集 
    static difference(a, b) {
        const differenceSet = new XSet(a);
        for (const bValue of b) {
            if (a.has(bValue)) {
                differenceSet.delete(bValue);
            }
        }
        return differenceSet;
    } // 返回两个集合的对称差集
    static symmetricDifference(a, b) {
        // 按照定义，对称差集可以表达为 
        return a.union(b).difference(a.intersection(b));
    } // 返回两个集合（数组对形式）的笛卡儿积 
    // 必须返回数组集合，因为笛卡儿积可能包含相同值的对
    static cartesianProduct(a, b) {
        const cartesianProductSet = new XSet();
        for (const aValue of a) {
            for (const bValue of b) {
                cartesianProductSet.add([aValue, bValue]);
            }
        }
        return cartesianProductSet;
    } // 返回一个集合的幂集
    static powerSet(a) {
        const powerSet = new XSet().add(new XSet());
        for (const aValue of a) {
            for (const set of new XSet(powerSet)) {
                powerSet.add(new XSet(set).add(aValue));
            }
        }
        return powerSet;
    }
}
```

## **6.7** **WeakSet**

### **6.7.1** 基本**API**

- 如何实例化一个空的WeakSet？
  - 使用new关键字

```
const ws = new WeakSet();
```

- 弱集合中的值只能是什么类型？
  - Object或者继承自Object的类型
  - 尝试使用非对象设置值会抛出TypeError。 

- 如果想在初始化时填充弱集合，则构造函数可以接收什么？
  - 一个可迭代对象
  - 其中需要包含有效的值。
- 可迭代对象中的每个值都会执行什么操作？
  - 会按照迭代顺序插入到新实例中

 

```
const val1 = {id: 1}, 
val2 = {id: 2}, 
val3 = {id: 3}; // 使用数组初始化弱集合
const ws1 = new WeakSet([val1, val2, val3]); alert(ws1.has(val1)); // true
alert(ws1.has(val2)); // true 
alert(ws1.has(val3)); // true
// 初始化是全有或全无的操作
// 只要有一个值无效就会抛出错误，导致整个初始化失败
const ws2 = new WeakSet([val1, "BADVAL", val3]);
// TypeError: Invalid value used in WeakSet typeof ws2; 
// ReferenceError: ws2 is not defined 
// 原始值可以先包装成对象再用作值 
const stringVal = new String("val1");
const ws3 = new WeakSet([stringVal]); alert(ws3.has(stringVal)); // true
```

- 初始化之后可以使用什么再添加新值？
  - add()
- 可以使用什么查询？
  - has()
- 还可以使用什么删除？
  - delete()

```
const ws = new WeakSet(); 
const val1 = {id: 1}, 
val2 = {id: 2}; 
alert(ws.has(val1)); // false
ws.add(val1)
.add(val2);
alert(ws.has(val1)); // true 
alert(ws.has(val2)); // true 
ws.delete(val1); // 只删除这一个值 alert(ws.has(val1)); // false 
alert(ws.has(val2)); // true
```

- add()方法返回弱集合实例，因此可以做什么？
  - 把多个操作连缀起来，包括初始化声明： 

```
const val1 = {id: 1}, 
val2 = {id: 2}, 
val3 = {id: 3}; 
const ws = new WeakSet().add(val1);
ws.add(val2)
.add(val3);
alert(ws.has(val1)); // true 
alert(ws.has(val2)); // true
alert(ws.has(val3)); // true
```

### **6.7.2** 弱值

- WeakSet中“weak”表示弱集合的值是什么意思？
  - 这些值不属于正式的引用，不会阻止垃圾回收。

```
const ws = new WeakSet(); 
ws.add({});
```

- 因为没有指向这个对象的其他引用，所以会发生什么？

  - 当这行代码执行完成后，

    这个对象值就会被当作垃圾回收。

  - 然后，这个值就从弱集合中消失了，

    使其成为一个空集合。

```
const ws = new WeakSet();
const container = { val: {} };
ws.add(container.val);
function removeReference() { container.val = null; }
```

- 这一次，这个对象值是否会成为垃圾回收的目标？为什么？
  - 不会
  - container对象维护着一个对弱集合值的引用
- 不过，如果调用了removeReference()，就会发生什么?
  - 摧毁值对象的最后一个引用，
  - 垃圾回收程序就可以把这个值清理掉。 

### **6.7.3** 不可迭代值 

- 为什么没必要提供迭代其值的能力？
  - 因为WeakSet中的值任何时候都可能被销毁

- WeakSet为什么限制只能用对象作为值？
  - 是为了保证只有通过值对象的引用才能取得值。

### **6.7.4** 使用弱集合

- 弱集合在做什么时有价值的？
  - 给对象打标签

```
const disabledElements = new Set(); 
const loginButton = document.querySelector('#login'); 
// 通过加入对应集合，给这个节点打上“禁用”标签 disabledElements.add(loginButton);
```

- 上述代码，假如元素从DOM树中被删除了，会发生什么？
  - 它的引用却仍然保存在Set中
  - 垃圾回收程序不能回收它。 

- 为了让垃圾回收程序回收元素的内存，可以怎么做？
  - 使用WeakSet

```
const disabledElements = new WeakSet();
const loginButton = document.querySelector('#login'); 
// 通过加入对应集合，给这个节点打上“禁用”标签 disabledElements.add(loginButton);
```

- 这样，只要WeakSet中任何元素从DOM树中被删除，

  就会发生什么？

  - 垃圾回收程序就可以忽略其存在，
  - 而立即释放其内存
  - （假设没有其他地方引用这个对象）。

## **6.8** 迭代与扩展操作 

- 有哪4种原生集合类型定义了默认迭代器？

  - Array 
  - 所有定型数组 

  - Map 

  - Set 

- 定义了默认迭代器意味着什么？
  - 都支持顺序迭代
  - 都可以传入for-of循环
  - 都兼容扩展操作符

```
let iterableThings = [ 
	Array.of(1, 2), 
	typedArr = Int16Array.of(3, 4), 
	new Map([[5, 6], [7, 8]]), 
	new Set([9, 10]) 
];
for (const iterableThing of iterableThings) { 
	for (const x of iterableThing) { 
		console.log(x); 
	} 
}
// 1 // 2 // 3 // 4 // [5, 6] // [7, 8] // 9 // 10
```

- 扩展操作符在什么时特别有用？
  - 对可迭代对象执行浅复制

```
let arr1 = [1, 2, 3];
let arr2 = [...arr1]; 
console.log(arr1); // [1, 2, 3]
console.log(arr2); // [1, 2, 3] 
console.log(arr1 === arr2); // false
```

- 对于期待可迭代对象的构造函数，只要传什么就能实现复制？
  - 传入一个可迭代对象就可以实现复制： 

```
let map1 = new Map([[1, 2], [3, 4]]);
let map2 = new Map(map1); 
console.log(map1); // Map {1 => 2, 3 => 4} console.log(map2); // Map {1 => 2, 3 => 4}
```

- ，也可以构建数组的部分元素： 

```
let arr1 = [1, 2, 3];
let arr2 = [0, ...arr1, 4, 5]; 
console.log(arr2); // [0, 1, 2, 3, 4, 5]
```

- 浅复制意味着什么？
  - 只会复制对象的引用

```
let arr1 = [{}]; 
let arr2 = [...arr1]; 
arr1[0].foo = 'bar';
console.log(arr2[0]); // { foo: 'bar' }
```

- Array.of()和Array.from() 在与扩展操作符一起使用时

```
let arr1 = [1, 2, 3]; // 把数组复制到定型数组
let typedArr1 = Int16Array.of(...arr1); 
let typedArr2 = Int16Array.from(arr1); console.log(typedArr1); // Int16Array [1, 2, 3] console.log(typedArr2); // Int16Array [1, 2, 3]
// 把数组复制到映射 
let map = new Map(arr1.map((x) => [x, 'val' + x])); console.log(map);
//Map{1 => 'val 1', 2 => 'val 2', 3 => 'val 3'}
// 把数组复制到集合 
let set = new Set(typedArr2); 
console.log(set); // Set {1, 2, 3}
// 把集合复制回数组
let arr2 = [...set]; 
console.log(arr2); // [1, 2, 3]
```

## **6.9** 小结

- JavaScript中的对象是引用值，

  可以通过什么创建特定类型的对象？

  - 几种内置引用类型

- Object类型是一个基础类型，这意味着什么？
  - 所有引用类型都从它继承了基本的行为

- Array类型表示一组有序的值，并提供了什么能力？
  - 操作和转换值的能力。

- 定型数组包含一套不同的引用类型，用于做什么？
  - 管理数值在内存中的类型。

- ECMAScript 6新增了一批引用类型？
  - Map
  - WeakMap
  - Set
  - WeakSet

