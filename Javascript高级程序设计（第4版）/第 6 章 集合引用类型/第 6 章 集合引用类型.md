# 第 6 章 集合引用类型

## 本章内容

- 对象

- 数组与定型数组 

- Map、WeakMap、Set以及WeakSet类型

## **6.1 Object** 

- Object的实例很适合做什么？
  -  存储和在应用程序间交换数据。

- 显式地创建Object的实例有哪两种方式？
  - 第一种是使用new操作符和Object构造函数
  - 第二种是使用对象字面量表示法

```
let person = new Object(); 
person.name = "Nicholas"; 
person.age = 29;
```

- 对象字面量是什么？
  - 对象的简写形式
- 对象字面量的目的是什么？
  - 为了简化包含大量属性的对象的创建

```
let person = { 
	name: "Nicholas", 
	age: 29 
};
```

- 在ECMAScript中，表达式上下文指的是什么？

  - 期待返回值的上下文

- 为什么上述代码中左大括号表示一个表达式的开始？

  - 因为赋值操作符表示后面要期待一个值

- 同样是左大括号，

  如果出现在语句上下文中，比如if语句的条件后面，

  则表示什么？

  -  一个语句块的开始。 

- 在最后一个属性后面加上逗号

  在什么浏览器中会导致报错？

  - 非常老的浏览器
    - 现代浏览器都支持这种写法

- 在对象字面量表示法中，属性名可以是什么类型？

  - 字符串
  - 数值

```
let person = {
	"name": "Nicholas", 
	"age": 29, 
	5: true 
};
```

- 数值属性会自动执行什么操作？

  - 转换为字符串。 

- 如何用对象字面量表示法来定义一个

  只有默认属性和方法的对象

  - 使用一对大括号，中间留空

```
let person = {}; // 与new Object()相同 
person.name = "Nicholas";
person.age = 29;
```

- 对象字面量表示法通常只在什么场景才使用？
  - 为了让属性一目了然时 

- 在使用对象字面量表示法定义对象时

  是否会实际调用Object构造函数？

  - 不会

- 为什么开发者更倾向于使用对象字面量表示法？

  - 因为对象字面量代码更少
    - 看起来也更有封装所有相关数据的感觉。

- 对象字面量已经成为做什么的主要方式？
  - 给函数传递大量可选参数

```
function displayInfo(args) { 
	let output = ""; 
	if (typeof args.name == "string"){ 
		output += "Name: " + args.name + "\n"; 
	}
	if (typeof args.age == "number") { 
		output += "Age: " + args.age + "\n"; 
	}
	alert(output); 
}
displayInfo({ name: "Nicholas", age: 29 }); displayInfo({ name: "Greg" })
```

- 这种模式非常适合什么的情况？
  - 函数有大量可选参数
- 一般来说，哪种参数更直观？
  - 命名参数
    - 但在可选参数过多的时候就显得笨拙了。
- 处理参数的最好的方式是什么？
  - 对必选参数使用命名参数，
  - 再通过一个对象字面量来封装多个可选参数。 

- 存取属性由哪几种方式
  - 点语法
  - 中括号语法
- 在使用中括号时，要在括号内使用属性名的什么形式？
  - 字符串
- 从功能上讲，这两种存取属性的方式有什么区别？
  - 没有区别
- 使用中括号的主要优势是什么？
  - 可以通过变量访问属性

```
let propertyName = "name"; console.log(person[propertyName]); // "Nicholas"
```

- 如果属性名中

  包含可能会导致语法错误的字符，

  或包含关键字/保留字时

  或包含非字母数字字符的，

  使用什么语法存取属性？

  - 中括号语法

```
person["first name"] = "Nicholas";
```

- 为什么"first name"不能使用点语法来访问？
  - 因为"first name"中包含一个空格，

- 哪个语法是首选的属性存取方式？
  - 点语法

## **6.2** **Array** 

- 数组中每个槽位可以存储什么类型的数据？
  - 任意类型
- ECMAScript数组的大小是怎么样的？
  - 动态的，
    - 会随着数据添加而自动增长。 

### **6.2.1** 创建数组 

- 有哪几种基本的方式可以创建数组？
  - 使用Array构造函数
  - 使用数组字面量表示法

```
let colors = new Array();
```

- 给构造函数传入一个表示数组中元素的数量数值，

  然后自动执行什么操作？

  - length属性就会被自动创建并设置为这个值。

```
let colors = new Array(20);
```

- 给Array构造函数传入要保存的元素

```
let colors = new Array("red", "blue", "green");
```

- 在使用Array构造函数时，省略new操作符，

  结果有什么区别？

  - 结果一样

```
let colors = Array(3); // 创建一个包含3个元素的数组 let names = Array("Greg"); // 创建一个只包含一个元素，即字符串"Greg"的数组
```

- 在使用数组字面量表示法创建数组是否会调用Array构造函数？

  - 不会

- Array构造函数还有哪两个ES6新增的

  用于创建数组的静态方法

  - from()
  - of()

- from()用于什么？
  - 将类数组结构转换为数组实例
- of()用于什么？
  - 将一组参数转换为数组实例。
- Array.from()的第一个参数是什么？
  - 一个类数组对象，
    - 即任何可迭代的结构， 
  - 或者有一个length属性和可索引元素的结构

```
// 字符串会被拆分为单字符数组 console.log(Array.from("Matt")); // ["M", "a", "t", "t"] 
// 可以使用from()将集合和映射转换为一个新数组 
const m = new Map().set(1, 2) .set(3, 4); 
const s = new Set().add(1) .add(2) .add(3) .add(4); 
console.log(Array.from(m)); // [[1, 2], [3, 4]] console.log(Array.from(s)); // [1, 2, 3, 4] 
// Array.from()对现有数组执行浅复制
const a1 = [1, 2, 3, 4]; 
const a2 = Array.from(a1); 
console.log(a1); // [1, 2, 3, 4] 
alert(a1 === a2); // false
// 可以使用任何可迭代对象 
const iter = { *[Symbol.iterator]() {
	yield 1;
	yield 2; 
	yield 3; 
	yield 4; 
	} 
};
console.log(Array.from(iter)); // [1, 2, 3, 4] 
// arguments对象可以被轻松地转换为数组 
function getArgsArray() { 
	return Array.from(arguments); 
}
console.log(getArgsArray(1, 2, 3, 4)); 
// [1, 2, 3, 4] 
// from()也能转换带有必要属性的自定义对象 
const arrayLikeObject = { 0: 1, 1: 2, 2: 3, 3: 4, length: 4 };
console.log(Array.from(arrayLikeObject)); // [1, 2, 3, 4]
```

- Array.from()还接收第二个可选的映射函数参数。

  这个函数可以做什么？

  - 直接增强新数组的值

- Array.from()接收第三个可选参数，用于什么？
  - 指定映射函数中this的值
    - 但这个重写的this值在箭头函数中不适用

```
const a1 = [1, 2, 3, 4]; 
const a2 = Array.from(a1, x => x**2); 
const a3 = Array.from(a1, function(x) {
	return x**this.exponent
}, {exponent: 2});
console.log(a2); // [1, 4, 9, 16] 
console.log(a3); // [1, 4, 9, 16]
```

- Array.of()可以做什么？

  - 把一组参数转换为数组

- Array.of()方法用于替代在ES6之前常用的什么方法？

  - Array.prototype.slice.call(arguments)

    - 一种异常笨拙的

      将arguments对象转换为数组的写法： 

```
console.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4] console.log(Array.of(undefined)); // [undefined]
```

### **6.2.2** 数组空位 

- 使用数组字面量初始化数组时，可以使用什么来创建空位 ？
  - 一串逗号
- ECMAScript会将什么值当成空位？
  - 逗号之间相应索引位置的值
- 如何创建一个空位数组？

```
const options = [,,,,,];
console.log(options.length); // 5
console.log(options); // [,,,,,]
```

- ES6新增方法普遍将空位当成什么元素？
  - 存在的元素

```
const options = [1,,,,5];
for (const option of options) {
	console.log(option === undefined);
}
// false
// true
// true
// true
// false
```

```
const a = Array.from([,,,]);
for (const val of a) {
	alert(val === undefined);
}
// true
// true
// true
alert(Array.of(...[,,,]));
for (const [index, value] of options.entries()) {
	alert(value);
}
// 1
// undefined
// undefined
// undefined
// 5
```

- ES6之前的方法是否会忽略空位？
  - 会

```
const options = [1,,,,5];
// map()会跳过空位置
console.log(options.map(() => 6));// [6, undefined, undefined, undefined, 5]

// join()视空位置为空字符串
console.log(options.join('-')); // "1----5"
```

- 为什么实践中要避免使用数组空位？
  - 因为行为不一致和存在性能隐患
- 如果确实需要空位，则可以怎么做？
  - 显式地用undefined值代替

### **6.2.3** 数组索引 

- 要取得或设置数组的值，需要做什么？
  - 使用中括号
  - 并提供相应值的数字索引，

```
let colors = ["red", "blue", "green"]; // 定义一个字符串数组 
alert(colors[0]); // 显示第一项 
colors[2] = "black"; // 修改第三项 
colors[3] = "brown"; // 添加第四项
```

- 在中括号中提供的索引表示什么？
  - 要访问的值。
- 如果索引小于数组包含的元素数，则返回什么？
  - 存储在相应位置的元素，
- 如果把一个值设置给超过数组最大索引的索引，则会发生什么？
  - 则数组长度会自动扩展到该索引值加1

- 数组中元素的数量保存在什么属性中？

  这个属性始终返回什么？

  - length属性
  - 返回0或大于0的值

```
let colors = ["red", "blue", "green"]; // 创建一个包含3个字符串的数组 
let names = []; // 创建一个空数组 alert(colors.length); // 3
alert(names.length); // 0
```

- 数组length属性的独特之处在于什么？
  - ，它不是只读的
- 通过修改length属性，可以做什么？
  - 从数组末尾删除或添加元素。

```
let colors = ["red", "blue", "green"]; // 创建一个包含3个字符串的数组 
colors.length = 2; 
alert(colors[2]); // undefined
```

- 如果将length设置为大于数组元素数的值，则会发生什么？
  - 新添加的元素都将以undefined填充，

```
let colors = ["red", "blue", "green"]; // 创建一个包含3个字符串的数组 
colors.length = 4; 
alert(colors[3]); // undefined
```

- 使用length属性可以方便地做什么？
  - 向数组末尾添加元素

```
let colors = ["red", "blue", "green"]; // 创建一个包含3个字符串的数组 
colors[colors.length] = "black"; // 添加一种颜色（位置3） 
colors[colors.length] = "brown"; // 再添加一种颜色（位置4）
```

- 数组中最后一个元素的索引始终是什么？
  - length - 1

```
let colors = ["red", "blue", "green"]; // 创建一个包含3个字符串的数组 
colors[99] = "black"; // 添加一种颜色（位置99） alert(colors.length); // 100
```

- 数组最多可以包含4 294 967 295个元素

  以这个最大值作为初始值创建数组，可能导致什么？

  - 脚本运行时间过长的错误

### **6.2.4** 检测数组 

- 在只有一个网页（因而只有一个全局作用域）的情况下，

  如何判断一个对象是不是数组？

  - 使用instanceof操作符

```
if (value instanceof Array){ // 操作数组 }
```

- 涉及两个不同的全局执行上下文，因此就会有什么？
  - 两个不同版本的Array构造函数

- 如果要把数组从一个框架传给另一个框架，则会发生什么？

  - 则这个数组的构造函数将有别于

    在第二个框架内本地创建的数组。

- Array.isArray()方法的目的就是什么？
  - 确定一个值是否为数组
    - 而不用管它是在哪个全局执行上下文中创建的。

```
if (Array.isArray(value)){ // 操作数组 }
```

### **6.2.5** 迭代器方法

- 在ES6中，Array的原型上暴露了3个用于检索数组内容的方 

  法？

  - keys()
    - 返回数组索引的迭代器
  - values()
    - 返回数组元素的迭代器
  - entries()
    - 返回索引/值对的迭代器

 

```
const a = ["foo", "bar", "baz", "qux"]; // 因为这些方法都返回迭代器，所以可以将它们的内容 
// 通过Array.from()直接转换为数组实例 
const aKeys = Array.from(a.keys()); 
const aValues = Array.from(a.values()); 
const aEntries = Array.from(a.entries()); console.log(aKeys); // [0, 1, 2, 3] console.log(aValues); // ["foo", "bar", "baz", "qux"] 
console.log(aEntries); // [[0, "foo"], [1, "bar"], [2, "baz"], [3, "qux"]]
```

- 使用ES6的解构可以非常容易地做什么？
  - 在循环中拆分键/值对

```
const a = ["foo", "bar", "baz", "qux"]; 
for (const [idx, element] of a.entries()) { 
	alert(idx); 
	alert(element); 
}
// 0 
// foo
// 1 
// bar
// 2 
// baz
// 3
// qux
```

### **6.2.6** 复制和填充方法

- ES6新增了两个复制和填充方法？
  - 批量复制方法copyWithin()，
  - 填充数组方法fill()。

- 这两个方法的函数签名相似之处？
  - 都需要指定既有数组实例上的一个范围，
    - 包含开始索引，不包含结束索引
- 使用这个方法是否会改变数组的大小？
  - 不会
- 使用fill()方法可以做什么？
  - 向一个已有的数组中插入全部或部分相同的值 

- 开始索引用于？
  - 指定开始填充的位置
  - 它是可选的
- 如果不提供结束索引？
  - 则一直填充到数组末尾

- 负值索引从哪里开始计算？
  - 数组末尾
  - 想象成数组长度加上它得到的一个正索引

```
const zeroes = [0, 0, 0, 0, 0]; // 用5填充整个数组 
zeroes.fill(5); 
console.log(zeroes); // [5, 5, 5, 5, 5] zeroes.fill(0); // 重置
// 用6填充索引大于等于3的元素 
zeroes.fill(6, 3);
console.log(zeroes); // [0, 0, 0, 6, 6] zeroes.fill(0); // 重置
// 用7填充索引大于等于1且小于3的元素 
zeroes.fill(7, 1, 3);
console.log(zeroes);// [0, 7, 7, 0, 0]; 
zeroes.fill(0); // 重置 
// 用8填充索引大于等于1且小于4的元素
// (-4 + zeroes.length = 1) 
// (-1 + zeroes.length = 4) 
zeroes.fill(8, -4, -1);
console.log(zeroes); // [0, 8, 8, 8, 0];
```

- fill()静默忽略什么的索引范围？
  - 超出数组边界、
  - 零长度
  - 方向相反的

```
const zeroes = [0, 0, 0, 0, 0]; // 索引过低，忽略 zeroes.fill(1, -10, -6); 
console.log(zeroes); // [0, 0, 0, 0, 0] 
// 索引过高，忽略 
zeroes.fill(1, 10, 15);
console.log(zeroes); // [0, 0, 0, 0, 0] 
// 索引反向，忽略 
zeroes.fill(2, 4, 2); 
console.log(zeroes); // [0, 0, 0, 0, 0]
// 索引部分可用，填充可用部分 
zeroes.fill(4, 3, 10) 
console.log(zeroes); // [0, 0, 0, 4, 4]
```

- copyWithin()会做什么？
  - 按照指定范围浅复制数组中的部分内容，
  - 然后将它们插入到指定索引开始的位置

- copyWithin()开始索引和结束索引使用什么样的计算方法？
  - 与fill()同样

```
let ints, reset = () => ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; 
reset(); // 从ints中复制索引0开始的内容，插入到索引5开始的位置 
// 在源索引或目标索引到达数组边界时停止 ints.copyWithin(5); 
console.log(ints); // [0, 1, 2, 3, 4, 0, 1, 2, 3, 4] reset(); // 从ints中复制索引5开始的内容，插入到索引0开始的位置 
ints.copyWithin(0, 5); 
console.log(ints); // [5, 6, 7, 8, 9, 5, 6, 7, 8, 9] reset(); // 从ints中复制索引0开始到索引3结束的内容 
// 插入到索引4开始的位置 ints.copyWithin(4, 0, 3); alert(ints); // [0, 1, 2, 3, 0, 1, 2, 7, 8, 9] reset(); 
// JavaScript引擎在插值前会完整复制范围内的值 
// 因此复制期间不存在重写的风险 
ints.copyWithin(2, 0, 6); 
alert(ints); // [0, 1, 0, 1, 2, 3, 4, 5, 8, 9] reset();
// 支持负索引值，与fill()相对于数组末尾计算正向索引的过程是一样的 
ints.copyWithin(-4, -7, -3);
alert(ints); // [0, 1, 2, 3, 4, 5, 3, 4, 5, 6]
```

- copyWithin()静默忽略的索引范围？
  - 超出数组边界
  - 零长度
  - 方向相反

```
let ints, reset = () => ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; 
reset(); 
// 索引过低，忽略
ints.copyWithin(1, -15, -12); 
alert(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; reset()
// 索引过高，忽略 
ints.copyWithin(1, 12, 15); 
alert(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; reset(); // 索引反向，忽略 
ints.copyWithin(2, 4, 2); 
alert(ints); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]; reset(); // 索引部分可用，复制、填充可用部分 ints.copyWithin(4, 7, 10) 
alert(ints); // [0, 1, 2, 3, 7, 8, 9, 7, 8, 9];
```

### **6.2.7** 转换方法

- 所有对象都有方法？
  - toLocaleString()、toString()和valueOf()

- 数组的转换方法？
  - valueOf()返回的还是数组本身。
  - toString()返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串
    - 对数组的每个值都会调用其toString()方法
  - toLocaleString()方法返回由数组中每个值的等效字符串拼接而成的逗号分隔的数组值的字符串
    - 对数组的每个值都会调用其toLocaleString()方法

```
let colors = ["red", "blue", "green"]; 
// 创建一个包含3个字符串的数组 
alert(colors.toString()); // red,blue,green alert(colors.valueOf()); // red,blue,green alert(colors); // red,blue,green
```

- 为什么会在后台调用数组的toString()方法，
  - 因为alert()期待字符串

```
let person1 = { 
	toLocaleString() { return "Nikolaos"; },
	toString() { return "Nicholas"; } 
};
let person2 = { 
	toLocaleString() { return "Grigorios"; },
	toString() { return "Greg"; } 
};
let people = [person1, person2]; 
alert(people); // Nicholas,Greg alert(people.toString()); // Nicholas,Greg alert(people.toLocaleString()); // Nikolaos,Grigorios
```

- 如果想使用不同的分隔符，则可以使用？
  - join()方法

- join()方法接收一个参数？
  - 字符串分隔符
- join()方法返回？
  - 回包含所有项的字符串

```
let colors = ["red", "green", "blue"]; alert(colors.join(",")); // red,green,blue alert(colors.join("||")); // red||green||blue
```

-  如果数组中某一项是null或undefined

  则在join()、toLocaleString()、toString()和valueOf()返回的结果中会怎么表示

  - 以空字符串

### **6.2.8** 栈方法

- ECMAScript数组提供了什么以实现类似栈的行为。？
  - push()和pop()方法

- push()方法接收参数？
  - 收任意数量的参数，并将它们添加到数组末尾

- push()方法返回
  - 数组的最新长度

- pop()方法则用于？
  - 删除数组的最后一项
  - 同时减少数组的length值，

- pop()方法返回？
  - 被删除的项

```
let colors = new Array(); // 创建一个数组 
let count = colors.push("red", "green"); // 推入两项 alert(count); // 2 
count = colors.push("black"); // 再推入一项 alert(count); // 3 
let item = colors.pop(); // 取得最后一项 
alert(item); // black
alert(colors.length); // 2
```

```
let colors = ["red", "blue"]; 
colors.push("brown"); // 再添加一项
colors[3] = "black"; // 添加一项 alert(colors.length); // 4 
let item = colors.pop(); // 取得最后一项
alert(item); // black
```

### **6.2.9** 队列方法

- shift()会做什么？
  - 会删除数组的第一项并返回它
  - 然后数组长度减1
- 使用什么，可以把数组当成队列来使用？
  - shift()和push()，

```
let colors = new Array(); // 创建一个数组 
let count = colors.push("red", "green"); // 推入两项 alert(count); // 2 
count = colors.push("black"); // 再推入一项 alert(count); // 3 
let item = colors.shift(); // 取得第一项 
alert(item); // red 
alert(colors.length); // 2
```

- unshift()执行什么操作？
  - 在数组开头添加任意多个值
  - 然后返回新的数组长度

- 如何在相反方向上模拟队列？
  - 通过使用unshift()和pop()，

```
let colors = new Array(); // 创建一个数组 
let count = colors.unshift("red", "green"); // 从数组开头推入两项 
alert(count); // 2 
count = colors.unshift("black"); // 再推入一项 alert(count); // 3 
let item = colors.pop(); // 取得最后一项 
alert(item); // green 
alert(colors.length); // 2
```

### **6.2.10** 排序方法

- 数组有两个方法可以用来对元素重新排序？
  - reverse()
    - 将数组元素反向排列
  - sort()

```
let values = [1, 2, 3, 4, 5]; 
values.reverse(); 
alert(values); // 5,4,3,2,1
```

- 默认情况下，sort()会按照什么顺序重新排列数组元素？
  - 升序
- sort()是怎么比较数组元素的？
  - 在每一项上调用String()转型函数
  - 然后比较字符串来决定顺序

```
let values = [0, 1, 5, 10, 15]; 
values.sort();
alert(values); // 0,1,10,15,5
```

- sort()方法可以接收一个比较函数，用于做什么？
  - 判断哪个值应该排在前面。

- 比较函数接收两个参数
  - 如果第一个参数应该排在第二个参数前面
    - 返回负值
  - 如果两个参数相等
    - 返回0
  - 如果第一个参数应该排在第二个参数后面
    - 返回正值

```
function compare(value1, value2) { 
	if (value1 < value2) { 
		return -1;
	} else if (value1 > value2) {
		return 1;
	} else { 
		return 0;
	} 
}
```

```
let values = [0, 1, 5, 10, 15]; values.sort(compare); 
alert(values); // 0,1,5,10,15
```

- 如何让比较函数产生降序效果？
  - 把返回值交换一下

```
function compare(value1, value2) { 
	if (value1 < value2) {
		return 1;
	} else if (value1 > value2) { 
		return -1; 
	} else { 
		return 0;
	} 
}
let values = [0, 1, 5, 10, 15]; values.sort(compare); 
alert(values); // 15,10,5,1,0
```

- 这个比较函数还可简写为一个箭头函数

```
let values = [0, 1, 5, 10, 15]; 
values.sort((a, b) => a < b ? 1 : a > b ? -1 : 0); alert(values); // 15,10,5,1,0
```

- reverse()和sort()都返回调用它们的数组的引用？
  - 是
- 如果数组的元素是数值，或者是其valueOf()方法返回数值的对象，这个比较函数还可以写成什么？
  - 可以直接用第二个值减去第一个值

```
function compare(value1, value2){ 
	return value2 - value1; 
}
```

### **6.2.11** 操作方法

- concat()方法可以做什么？
  - 首先会创建一个当前数组的副本
  - 然后再把它的参数添加到副本末尾
  - 最后返回这个新构建的数组

- 如果传入一个或多个数组，则concat()会？
  - 把这些数组的每一项都添加到结果数组

- 如果参数不是数组，则concat()会？
  - 直接把它们添加到结果数组末尾

```
let colors = ["red", "green", "blue"]; 
let colors2 = colors.concat("yellow", ["black", "brown"]); 
console.log(colors); // ["red", "green","blue"] console.log(colors2); // ["red", "green", "blue", "yellow", "black", "brown"]
```

- 打平数组参数的行为是否可以重写？
  - 是
- 哪个符号能够阻止concat()打平参数 ？
  - Symbol.isConcatSpreadable
    - 设置为true可以强制打平类数组对象

```
let colors = ["red", "green", "blue"]; 
let newColors = ["black", "brown"]; 
let moreNewColors = { 
	[Symbol.isConcatSpreadable]: true, 
	length: 2,
	0: "pink",
	1: "cyan" 
};
newColors[Symbol.isConcatSpreadable] = false; 
// 强制不打平数组 
let colors2 = colors.concat("yellow", newColors); 
// 强制打平类数组对象 
let colors3 = colors.concat(moreNewColors); console.log(colors); // ["red", "green", "blue"] console.log(colors2); // ["red", "green", "blue", "yellow", ["black", "brown"]] 
console.log(colors3); // ["red", "green", "blue", "pink", "cyan"]
```

- 方法slice()用于什么？
  - 创建一个包含原有数组中一个或多个元素的新数组

- slice()方法可以接收什么参数？
  - 返回元素的开始索引
  - 返回元素的结束索引。

- 如果只有一个参数，则slice()会返回什么？
  - 该索引到数组末尾的所有元素
- 如果有两个参数，则slice()返回什么？
  - 从开始索引到结束索引对应的所有元素
    - 其中不包含结束索引对应的元素

- 这个操作是否影响原始数组？
  - 不

```
let colors = ["red", "green", "blue", "yellow", "purple"];
let colors2 = colors.slice(1); 
let colors3 = colors.slice(1, 4);
alert(colors2); // green,blue,yellow,purple alert(colors3); // green,blue,yellow
```

- 如果slice()的参数有负值，那么会执行什么操作？
  - 就以数值长度加上这个负值的结果确定位置

- 如果slice()的参数结束位置小于开始位置，则？
  - 返回空数组

- splice()的主要目的是？
  - 在数组中间插入元素

- 有3种不同的方式使用splice()方法？
  - 删除
    - 需要给splice()传2个参数
      - 要删除的第一个元素的位置
      - 要删除的元素数量
    - splice(0, 2)
  - 插入
    - 需要给splice()传3个参数：
      - 开始位置
      - 0
      - 要插入的元素
    - splice(2, 0, "red", "green")
  - 替换
    - 传入3个参数
      - 开始位置
      - 要删除元素的数量
      - 要插入的任意多个元素
    - splice(2, 1, "red", "green")

- splice()方法始终返回什么样一个数组？
  - 它包含从数组中被删除的元素
  - （如果没有删除元素，则返回空数组）

```
let colors = ["red", "green", "blue"]; 
let removed = colors.splice(0,1); // 删除第一项 alert(colors); // green,blue 
alert(removed); // red，只有一个元素的数组 
removed = colors.splice(1, 0, "yellow", "orange"); // 在位置1插入两个元素 
alert(colors); // green,yellow,orange,blue alert(removed); // 空数组 
removed = colors.splice(1, 1, "red", "purple"); // 插入两个值，删除一个元素 
alert(colors); // green,red,purple,orange,blue alert(removed); // yellow，只有一个元素的数组
```

### **6.2.12** 搜索和位置方法

- ECMAScript提供两类搜索数组的方法？
  - 按严格相等搜索
  - 按断言函数搜索

#### \01. 严格相等

- ECMAScript提供了哪3个严格相等的搜索方法？
  - indexOf()
  - lastIndexOf()
  - includes()

- 这三个方法都接收哪两个参数？
  - 要查找的元素
  - 一个可选的起始搜索位置

- indexOf()和includes()方法以什么方向搜索？
  - 从数组前头（第一项）开始向后搜索

- lastIndexOf()以什么方向搜索？
  - 从数组末尾（最后一项）开始向前搜索

- indexOf()和lastIndexOf()都返回？
  - 要查找的元素在数组中的位置，
  - 如果没找到则返回-1

- includes()返回？
  - 布尔值
  - 表示是否至少找到一个与指定元素匹配的项

- 在比较第一个参数跟数组每一项时，会使用什么比较？
  - 使用全等（===）比较

```
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; 

alert(numbers.indexOf(4)); // 3 alert(numbers.lastIndexOf(4)); // 5 alert(numbers.includes(4)); // true 

alert(numbers.indexOf(4, 4)); // 5 alert(numbers.lastIndexOf(4, 4)); // 3 alert(numbers.includes(4, 7)); // false 

let person = { name: "Nicholas" }; 
let people = [{ name: "Nicholas" }]; 
let morePeople = [person]; 

alert(people.indexOf(person)); // -1 alert(morePeople.indexOf(person)); // 0 

alert(people.includes(person)); // false alert(morePeople.includes(person)); // true
```

#### \02. 断言函数

- ECMAScript也允许按照定义的断言函数搜索数组，每个索引都会做什么？
  - 调用这个函数

- 断言函数的返回值决定了？
  - 相应索引的元素是否被认为匹配

- 断言函数接收3个参数？
  - 元素
    - 数组中当前搜索的元素
  - 索引
    - 当前元素的索引
  - 数组本身
    - 正在搜索的数组
- 断言函数返回？
  - 布尔值
  - 表示是否匹配

- 什么方法使用了断言函数？
  - find()
  - findIndex()

- 这两个方法都从哪里开始？
  - 从数组的最小索引开始

- find()返回？
  - 第一个匹配的元素
- findIndex()返回？
  - 第一个匹配元素的索引

- 这两个方法也都接收第二个可选的参数，用于？
  - 指定断言函数内部this的值

```
const people = [ 
	{
		name: "Matt", 
		age: 27
	},
	{ 
		name: "Nicholas",
    	age: 29 
    } 
];
alert(people.find(
(element, index, array) => element.age < 28)); 
// {name: "Matt", age: 27} 

alert(people.findIndex(
(element, index, array) => element.age < 28)); // 0
```

- 找到匹配项后，这两个方法都是否再继续搜索？
  - 不

```
const evens = [2, 4, 6]; 
// 找到匹配后，永远不会检查数组的最后一个元素 
evens.find((element, index, array) => { 			
	console.log(element); 
	console.log(index); 
	console.log(array); 
	return element === 4; 
});
// 2 // 0 // [2, 4, 6] 
// 4 // 1 // [2, 4, 6]
```

### **6.2.13** 迭代方法

- ECMAScript为数组定义了5个迭代方法？
  - every()
    - 对数组每一项都运行传入的函数
    - 如果对每一项函数都返回true
      - 则这个方法返回true
  - filter()
    - 对数组每一项都运行传入的函数
    - 函数返回true的项会组成数组之后返回
  - forEach()
    - 对数组每一项都运行传入的函数
    - ，没有返回值。
  - map()
    - 对数组每一项都运行传入的函数
    - 返回由每次函数调用的结果构成的数组。 
  - some()
    - 对数组每一项都运行传入的函数
    - 如果有一项函数返回true，
      - 则这个方法返回true。

- 这些方法是否改变调用它们的数组？
  - 不

```
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; 
let everyResult = numbers.every(
	(item, index, array) => item > 2
); 
alert(everyResult); // false 
let someResult = numbers.some(
	(item, index, array) => item > 2
); 
alert(someResult); // true
```

- filter()方法方法基于给定的函数来决定什么？
  - 某一项是否应该包含在它返回的数组中。

- 如何返回一个所有数值都大于2的数组？

```
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; 
let filterResult = numbers.filter(
	(item, index, array) => item > 2
); 
alert(filterResult); // 3,4,5,4,3
```

- filter()方法非常适合做什么？
  - 从数组中筛选满足给定条件的元素。 

- map()方法也会返回一个什么样的数组？

  - 这个数组的每一项都是

    对原始数组中同样位置的元素

    运行传入函数

    而返回的结果。

- 如何将一个数组中的每一项都乘以2，

  并返回包含所有结果的数组？

```
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; 
let mapResult = numbers.map(
	(item, index, array) => item * 2
); 
alert(mapResult); // 2,4,6,8,10,8,6,4,2
```

- map()方法适合做什么？
  - 创建一个与原始数组元素一一对应的新数组。

- forEach()方法相当于什么？
  - 使用for循环遍历数组

```
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; numbers.forEach(
	(item, index, array) => { // 执行某些操作 }
);
```

### **6.2.14** 归并方法

- ECMAScript为数组提供了两个归并方法？
  - reduce()
  - reduceRight()

- 这两个方法都会做什么？
  - 迭代数组的所有项，
  - 并在此基础上构建一个最终返回值。

- reduce()方法以什么方向遍历数组？
  - 从数组第一项开始遍历到最后一项

- reduceRight()以什么方向遍历数组？
  - 从最后一项开始遍历至第一项

- 这两个方法都接收两个参数？

  - 对每一项都会运行的归并函数

  - 可选的以之为归并起点的初始值。

- 传给reduce()和reduceRight()的函数接收4个参数？
  - 上一个归并值
  - 当前项
  - 当前项的索引
  - 数组本身

- 这个函数返回的任何值都会作为什么？
  - 下一次调用同一个函数的第一个参数

- 如果没有给这两个方法传入可选的第二个参数（作为归并起点值）则第一次迭代将从哪里开始？
  - 数组的第二项
    - 传给归并函数的第一个参数是数组的第一项，
    - 第二个参数是数组的第二项。

- 可以使用什么函数执行累加数组中所有数值的操作？
  - reduce()

```
let values = [1, 2, 3, 4, 5]; 
let sum = values.reduce(
	(prev, cur, index, array) => prev + cur
); 
alert(sum); // 15
```

- reduceRight()方法例子：

```
let values = [1, 2, 3, 4, 5]; 
let sum = values.reduceRight(
	function(prev, cur, index, array){ 
	return prev + cur; 
}); 
alert(sum); // 15
```

