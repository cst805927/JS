# 第 6 章 集合引用类型

## 本章内容

- 对象

- 数组与定型数组 

- Map、WeakMap、Set以及WeakSet类型

## **6.1 Object** 

- Object的实例很适合做什么？
  -  存储和在应用程序间交换数据。

- 显式地创建Object的实例有哪两种方式？
  - 第一种是使用new操作符和Object构造函数
  - 第二种是使用对象字面量表示法

```
let person = new Object(); 
person.name = "Nicholas"; 
person.age = 29;
```

- 对象字面量是什么？
  - 对象的简写形式
- 对象字面量的目的是什么？
  - 为了简化包含大量属性的对象的创建

```
let person = { 
	name: "Nicholas", 
	age: 29 
};
```

- 在ECMAScript中，表达式上下文指的是什么？

  - 期待返回值的上下文

- 为什么上述代码中左大括号表示一个表达式的开始？

  - 因为赋值操作符表示后面要期待一个值

- 同样是左大括号，

  如果出现在语句上下文中，比如if语句的条件后面，

  则表示什么？

  -  一个语句块的开始。 

- 在最后一个属性后面加上逗号

  在什么浏览器中会导致报错？

  - 非常老的浏览器
    - 现代浏览器都支持这种写法

- 在对象字面量表示法中，属性名可以是什么类型？

  - 字符串
  - 数值

```
let person = {
	"name": "Nicholas", 
	"age": 29, 
	5: true 
};
```

- 数值属性会自动执行什么操作？

  - 转换为字符串。 

- 如何用对象字面量表示法来定义一个

  只有默认属性和方法的对象

  - 使用一对大括号，中间留空

```
let person = {}; // 与new Object()相同 
person.name = "Nicholas";
person.age = 29;
```

- 对象字面量表示法通常只在什么场景才使用？
  - 为了让属性一目了然时 

- 在使用对象字面量表示法定义对象时

  是否会实际调用Object构造函数？

  - 不会

- 为什么开发者更倾向于使用对象字面量表示法？

  - 因为对象字面量代码更少
    - 看起来也更有封装所有相关数据的感觉。

- 对象字面量已经成为做什么的主要方式？
  - 给函数传递大量可选参数

```
function displayInfo(args) { 
	let output = ""; 
	if (typeof args.name == "string"){ 
		output += "Name: " + args.name + "\n"; 
	}
	if (typeof args.age == "number") { 
		output += "Age: " + args.age + "\n"; 
	}
	alert(output); 
}
displayInfo({ name: "Nicholas", age: 29 }); displayInfo({ name: "Greg" })
```

- 这种模式非常适合什么的情况？
  - 函数有大量可选参数
- 一般来说，哪种参数更直观？
  - 命名参数
    - 但在可选参数过多的时候就显得笨拙了。
- 处理参数的最好的方式是什么？
  - 对必选参数使用命名参数，
  - 再通过一个对象字面量来封装多个可选参数。 

- 存取属性由哪几种方式
  - 点语法
  - 中括号语法
- 在使用中括号时，要在括号内使用属性名的什么形式？
  - 字符串
- 从功能上讲，这两种存取属性的方式有什么区别？
  - 没有区别
- 使用中括号的主要优势是什么？
  - 可以通过变量访问属性

```
let propertyName = "name"; console.log(person[propertyName]); // "Nicholas"
```

- 如果属性名中

  包含可能会导致语法错误的字符，

  或包含关键字/保留字时

  或包含非字母数字字符的，

  使用什么语法存取属性？

  - 中括号语法

```
person["first name"] = "Nicholas";
```

- 为什么"first name"不能使用点语法来访问？
  - 因为"first name"中包含一个空格，

- 哪个语法是首选的属性存取方式？
  - 点语法

## **6.2** **Array** 

- 数组中每个槽位可以存储什么类型的数据？
  - 任意类型
- ECMAScript数组的大小是怎么样的？
  - 动态的，
    - 会随着数据添加而自动增长。 

### **6.2.1** 创建数组 

- 有哪几种基本的方式可以创建数组？
  - 使用Array构造函数
  - 使用数组字面量表示法

```
let colors = new Array();
```

- 给构造函数传入一个表示数组中元素的数量数值，

  然后自动执行什么操作？

  - length属性就会被自动创建并设置为这个值。

```
let colors = new Array(20);
```

- 给Array构造函数传入要保存的元素

```
let colors = new Array("red", "blue", "green");
```

- 在使用Array构造函数时，省略new操作符，

  结果有什么区别？

  - 结果一样

```
let colors = Array(3); // 创建一个包含3个元素的数组 let names = Array("Greg"); // 创建一个只包含一个元素，即字符串"Greg"的数组
```

- 在使用数组字面量表示法创建数组是否会调用Array构造函数？

  - 不会

- Array构造函数还有哪两个ES6新增的

  用于创建数组的静态方法

  - from()
  - of()

- from()用于什么？
  - 将类数组结构转换为数组实例
- of()用于什么？
  - 将一组参数转换为数组实例。
- Array.from()的第一个参数是什么？
  - 一个类数组对象，
    - 即任何可迭代的结构， 
  - 或者有一个length属性和可索引元素的结构

```
// 字符串会被拆分为单字符数组 console.log(Array.from("Matt")); // ["M", "a", "t", "t"] 
// 可以使用from()将集合和映射转换为一个新数组 
const m = new Map().set(1, 2) .set(3, 4); 
const s = new Set().add(1) .add(2) .add(3) .add(4); 
console.log(Array.from(m)); // [[1, 2], [3, 4]] console.log(Array.from(s)); // [1, 2, 3, 4] 
// Array.from()对现有数组执行浅复制
const a1 = [1, 2, 3, 4]; 
const a2 = Array.from(a1); 
console.log(a1); // [1, 2, 3, 4] 
alert(a1 === a2); // false
// 可以使用任何可迭代对象 
const iter = { *[Symbol.iterator]() {
	yield 1;
	yield 2; 
	yield 3; 
	yield 4; 
	} 
};
console.log(Array.from(iter)); // [1, 2, 3, 4] 
// arguments对象可以被轻松地转换为数组 
function getArgsArray() { 
	return Array.from(arguments); 
}
console.log(getArgsArray(1, 2, 3, 4)); 
// [1, 2, 3, 4] 
// from()也能转换带有必要属性的自定义对象 
const arrayLikeObject = { 0: 1, 1: 2, 2: 3, 3: 4, length: 4 };
console.log(Array.from(arrayLikeObject)); // [1, 2, 3, 4]
```

Array.from()还接收第二个可选的映射函数参数。这个函数可以直接增 

强新数组的值，而无须像调用Array.from().map()那样先创建一个中间 

数组。还可以接收第三个可选参数，用于指定映射函数中this的值。但 

这个重写的this值在箭头函数中不适用。 