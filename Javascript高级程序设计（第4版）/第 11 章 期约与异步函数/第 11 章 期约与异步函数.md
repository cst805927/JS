# 第 **11** 章 期约与异步函数

- 本章内容

  - 异步编程 

  - 期约

  - 异步函数 

## **11.1** 异步编程

- 在JavaScript是什么模型？
  - 单线程事件循环

- 异步行为是为了什么？
  - 优化因计算量大而时间长的操作

### **11.1.1** 同步与异步 

- 同步行为对应内存中怎么执行的处理器指令？
  - 顺序执行的
- 同步行为每条指令都会严格按照什么顺序来执行？
  - 出现的顺序

```
let x = 3;
x = x + 4;
```

- 在程序执行的每一步，都可以推断出什么？
  - 程序的状态
- 后面的指令总是在什么时候执行？
  - 前面的指令完成后

-  异步行为中什么实体可以触发代码执行？

  - 当前进程外部的实体

- 为什么异步操作是必要的？

  - 因为强制进程等待一个长时间的操作是不可行的

    （同步操作则必须要等）

```
let x = 3;
setTimeout(() => x = x + 4, 1000);
```

- 但这一次执行线程是否知道x值何时会改变？
  - 不知道
  - 因为这取决于回调何时从消息队列出列并执行。 

- 但第二个指令块（加操作及赋值操作）是由系统计时器触发的，

  这会生成什么？

  - 一个入队执行的中断

### **11.1.2** 以往的异步编程模式  

- 在早期的JavaScript中，只支持什么来表明异步操作完成？
  - 定义回调函数
- 常见的问题是什么？
  - 串联多个异步操作
    - 深度嵌套的回调函数（俗称“回调地狱”）

```
function double(value) {
    setTimeout(() => setTimeout(console.log, 0, value * 2), 1000);
}
double(3); // 6（大约1000毫秒之后）
```

- setTimeout可以定义一个什么样的回调函数？

  - 在指定时间之后会被调度执行

- 1000毫秒之后，

  JavaScript运行时会执行什么操作？

  - 会把回调函数推到自己的消息队列

    上去等待执行

- 推到队列之后，回调什么时候出列是否可见？

  - 不可见

- double()函数在setTimeout成功调度异步操作之后

  会执行什么操作？

  - 立即退出

#### \01. 异步返回值

- 假设setTimeout操作会返回一个有用的值，

  如何把这个值传给需要它的地方？

  - 给异步操作提供一个回调

  - 这个回调中包含

    要使用异步返回值

    的代码

    

```
function double(value, callback) {
    setTimeout(() => callback(value * 2), 1000);
}
double(3, (x) => console.log(`I was given: ${x}`)); // I was given: 6（大约1000毫秒之后）
```

- 这里的setTimeout调用告诉JavaScript什么？
  - 运行时在1000毫秒之后
    - 把一个函数推到消息队列上。
  - 这个函数会由运行时负责异步调度执行。

####  \02. 失败处理

- 成功回调和失败回调： 

```
function double(value, success, failure) {
    setTimeout(() => {
        try {
            if (typeof value !== 'number') {
                throw 'Must provide number as first argument';
            }
            success(2 * value);
        } catch (e) {
            failure(e);
        }
    }, 1000);
}

const successCallback = (x) => 
	console.log(`Success: ${x}`);

const failureCallback = (e) =>
	console.log(`Failure: ${e}`);
	
double(3, successCallback, failureCallback);

double('b', successCallback, failureCallback);

// Success: 6（大约1000毫秒之后）
 // Failure: Must provide number as first argument（大约1000毫秒之后）
```

- 为什么这种模式已经不可取了？
  - 因为必须在初始化异步操作时定义回调。 

- 异步函数的返回值只在短时间内存在

  - 只有预备好将这个短时间内存在的值

    作为参数的回调才能接收到它

#### \03. 嵌套异步回调 

- 如果异步返值又依赖另一个异步返回值，需要怎么做？
  - 嵌套回调

```
function double(value, success, failure) {
    setTimeout(() => {
        try {
            if (typeof value !== 'number') {
               
               throw 'Must provide number as first argument';
            }
            
            success(2 * value);
            
        } catch (e) {
        
            failure(e);
        }
    }, 1000);
}

const successCallback = (x) => {
    double(x, (y) => 
    	console.log(`Success: ${y}`));
};

const failureCallback = (e) =>
	console.log(`Failure: ${e}`);
	
double(3, successCallback, failureCallback); 

// Success: 12（大约1000毫秒之后
```

## **11.2** 期约

### **11.2.1 Promises/A+**规范 

- ECMAScript 6增加了对Promises/A+规范的完善支持，
  - 即Promise类型。 

- 什么是主导性的异步编程机制？
  - Promise
- 是否所有现代浏览器都支持ES6期约？
  - 是

### **11.2.2** 期约基础 

- Promise，可以通过什么来实例化？
  - new操作符 

- 创建新期约时需要传入什么作为参数？
  - 执行器

```
let p = new Promise(() => {});
setTimeout(console.log, 0, p); // Promise <pending>
```

- 如果不提供执行器函数，就会执行什么操作？
  - 抛出SyntaxError。 

#### \01. 期约状态机

- 在把一个期约实例传给console.log()时，控制台输出

  表明该实例处于什么状态？

  - 待定

- 期约是一个有什么的对象？

  - 有状态的

- 期约可能处于哪3种状态之一 ？

  - 待定（pending） 

  - 兑现（fulfilled）
    - 也称为“解决”（resolved） 

  - 拒绝（rejected）

- 待定（pending）是期约的什么状态？

  - 最初始状态

- 在待定状态下，期约可以落定（settled）为什么状态？

  - 代表成功的兑现（fulfilled）状态，
  - 代表失败的拒绝（rejected）状态。

- 无论落定为哪种状态是否可逆？

  - 不可逆

- 只要从待定转换为兑现或拒绝，期约的状态是否再改变？

  - 不再改变

- 是否能保证期约必然会脱离待定状态？

  - 不能

- 组织合理的代码应该怎么做？

  - 无论期约解决（resolve）还是拒绝（reject）

    还是永远处于待定（pending）状态，

  - 都应该具有恰当的行为。 

- 期约的状态是私有的还是公有的？

  - 私有的

- 是否能直接通过JavaScript检测到期约的状态？

  - 不能 

  - 为了避免根据读取到的期约状态，

    以同步方式处理期约对象。

- 期约的状态是否能被外部JavaScript代码修改？
  - 不能
- 为什么期约故意将异步行为封装起来？
  - 为了隔离外部的同步代码。 

#### \02. 解决值、拒绝理由及期约用例 

- 期约主要有哪两大用途？
  - 抽象地表示一个异步操作。
  - 异步操作生成某个值
- 期约的状态代表什么？
  - 期约是否完成
- “待定”表示什么？
  - 尚未开始
  - 或正在执行中
- “兑现”表示什么？
  - 已经成功完成
- “拒绝”表示什么？
  - 没有成功完成。 

- 期约封装的异步操作是否会生成某个值？
  - 会
- 程序期待期约状态改变时可以做什么？
  - 访问异步操作生成的值。
- 如果期约被拒绝，程序就会期待期约状态改变时可以做什么？
  - 拿到拒绝的理由。
- 每个期约只要状态切换为兑现，就会有一个什么？
  - 私有的内部值（value）
- 每个期约只要状态切换为拒绝，就会有一个什么？
  - 私有的内部理由（reason）
- 无论是值还是理由，都是什么引用？
  - 包含原始值或对象的
  - 不可修改的
- 二者是否可选？
  - 可选
- 默认值是什么？
  - undefined
- 在什么时候执行的异步代码始终会收到这个值或理由？
  - 期约到达某个落定状态

#### \03. 通过执行函数控制期约状态

- 为什么期约的状态只能在内部进行操作？
  - 因为期约的状态是私有的

- 内部操作在哪里完成？ 
  - 期约的执行器函数中
- 执行器函数主要有哪两项职责？
  - 初始化期约的异步行为
  - 控制状态的最终转换
- 执行器函数怎么实现控制期约状态的转换？
  - 通过调用它的两个函数参数
- 执行器函数的两个参数通常都命名为什么？
  - resolve()
  - reject()
- 调用resolve()会执行什么操作？
  - 把状态切换为兑现，
- 调用reject()会执行什么操作？
  - 把状态切换为拒绝
  - 抛出错误

```
let p1 = new Promise((resolve, reject) =>
	resolve());
	
setTimeout(console.log, 0, p1); 
// Promise <resolved>

let p2 = new Promise((resolve, reject) => reject());

setTimeout(console.log, 0, p2);
// Promise <rejected>
// Uncaught error (in promise)
```

- 在前面的例子中，是否有异步操作？

  - 没有

  - 因为在初始化期约时，

    执行器函数已经改变了每个期约的状态。

- 执行器函数是同步还是异步执行的？
  - 同步执行
  - 因为执行器函数是期约的初始化程序。

```
new Promise(() => setTimeout(console.log, 0, 'executor'));

setTimeout(console.log, 0, 'promise initialized'); 

// executor 
// promise initialized
```

- 如何推迟切换状态？
  - 添加setTimeout

```
let p = new Promise((resolve, reject) => 
	setTimeout(resolve, 1000));
	
// 在console.log打印期约实例的时候，还不会执行超时回调（即resolve()） 

setTimeout(console.log, 0, p); // Promise <pending>
```

- 状态转换可否撤销？
  - 不可以
    - 无论resolve()和reject()中的哪个被调用
- 继续修改状态会执行什么操作？
  - 静默失败

```
let p = new Promise((resolve, reject) => {
    resolve();
    reject(); // 没有效果 
});
setTimeout(console.log, 0, p); // Promise <resolved>
```

- 如何避免期约卡在待定状态？

  - 添加一个定时退出功能。

    - 通过setTimeout设置一个10秒钟后

      会拒绝期约的回调

```
let p = new Promise((resolve, reject) => {

    setTimeout(reject, 10000); // 10秒后调用reject()

    // 执行函数的逻辑 
});

setTimeout(console.log, 0, p); // Promise <pending> 

setTimeout(console.log, 11000, p); // 11秒后再检查状态

// (After 10 seconds) Uncaught error
// (After 11 seconds) Promise <rejected>
```

- 如果执行器中的代码在超时之前已经解决或拒绝，

  那么超时回调再尝试拒绝会发生什么？

  - 静默失败

#### \04. **Promise.resolve()**  

- 期约是否一开始就必须处于待定状态？
  - 不是
- 如何实例化一个解决的期约？
  - 调用Promise.resolve()静态方法
- 下面两个期约实例实际上是一样的：

```
let p1 = new Promise((resolve, reject) => 
	resolve());
	
let p2 = Promise.resolve();
```

- 这个解决的期约的值对应着什么？
  - 传给Promise.resolve()的第一个参数。 
- 使用这个静态方法，可以对一个值做什么？
  - 把任何值都转换为一个期约

```
let p1 = new Promise((resolve, reject) => 
	resolve());
	
let p2 = Promise.resolve();

setTimeout(console.log, 0, Promise.resolve());
// Promise <resolved>: undefined 

setTimeout(console.log, 0, Promise.resolve(3)); 
// Promise <resolved>: 3

// 多余的参数会忽略 
setTimeout(console.log, 0, Promise.resolve(4, 5, 6));
// Promise <resolved>: 4
```

- 对这个静态方法而言，

  如果传入的参数本身是一个期约，

  那它的行为就类似于什么？

  - 一个空包装。

- Promise.resolve()是一个什么方法？
  - 幂等方法

```
let p = Promise.resolve(7);

setTimeout(console.log, 0, p === Promise.resolve(p)); // true 

setTimeout(console.log, 0, p === Promise.resolve(Promise.resolve(p))); // true
```

- 这个幂等性是否会保留传入期约的状态？
  - 会

```
let p = new Promise(() => {});

setTimeout(console.log, 0, p); // Promise <pending>

setTimeout(console.log, 0, Promise.resolve(p));
// Promise <pending>

setTimeout(console.log, 0, p === Promise.resolve(p)); // true
```

-  这个静态方法是否能够包装非期约值？
  - 能
    - 包括错误对象，
    - 并将其转换为解决的期约。

```
let p = Promise.resolve(new Error('foo')); 

setTimeout(console.log, 0, p); 
// Promise <resolved>: Error: foo
```

#### \05. **Promise.reject()**

- Promise.reject()会实例化一个什么？
  - 拒绝的期约
  - 并抛出一个异步错误
- 这个错误能否通过try/catch捕获？
  - 不能
  - 只能通过拒绝处理程序捕获
- 下面的两个期约实例实际上是一样的

```
let p1 = new Promise((resolve, reject) => reject());

let p2 = Promise.reject();
```

- 这个拒绝的期约的理由是什么？
  - 传给Promise.reject()的第一个参数

- 这个参数是否会传给后续的拒绝处理程序？
  - 会

```
let p = Promise.reject(3); 

setTimeout(console.log, 0, p);
// Promise <rejected>: 3 

p.then(null, (e) => setTimeout(console.log, 0, e));
// 3
```

- 如果给Promise.reject()传一个期约对象，

  则这个期约会成为什么？

  - 它返回的拒绝期约的理由

```
setTimeout(console.log, 0, Promise.reject(Promise.resolve())); 
// Promise <rejected>: Promise <resolved>
```

#### \06. 同步**/**异步执行的二元性 

- 两种模式下抛出错误的情形：

```
try {
    throw new Error('foo');
} catch (e) {
    console.log(e); // Error: foo
}

try {
    Promise.reject(new Error('bar'));
} catch (e) {
    console.log(e);
}
// Uncaught (in promise) Error: bar
```

- 第一个try/catch是否抛出并捕获了错误？
  - 是
- 第二个try/catch抛出错误是否有捕获到？
  - 没有
- 代码中是同步还是异步创建了一个拒绝的期约实例？
  - 同步
- 这个实例是否抛出了包含拒绝理由的错误？
  - 是
- 为什么这里的同步代码try/catch没有捕获期约抛出的错误？
  - 因为它没有通过异步模式捕获错误。
- 期约真正的异步特性是什么？
  - 是同步对象
    - （在同步执行模式中使用）
  - 是异步执行模式的媒介

- 在前面的例子中，

  拒绝期约的错误有没有抛到执行同步代码的线程里？

  - 没有

- 拒绝期约的错误是通过什么处理的？

  - 通过浏览器异步消息队列

- try/catch块能不能捕获该错误？

  - 不能

- 代码一旦开始以异步模式执行，

  则唯一与之交互的方式是什么？

  - 使用异步结构
    - 期约的方法