# 第 5 章 基本引用类型

## 本章内容

-   理解对象

-   基本 JavaScript 数据类型

-   原始值与原始值包装类型

---

-   引用值（或者对象）是什么？

    -   某个特定引用类型的实例。

-   在 ECMAScript 中， 引用类型是什么？

    -   把数据和功能组织到一起的结构

-   为什么引用类型有时候也被称为对象定义？

    -   因为它们描述了自己的对象应有的属性和方法。

-   引用类型跟类是否是一个概念？

-   不是

-   怎么创建一个新对象？

    -   通过使用 new 操作符

        后跟一个构造函数（constructor）来创建

-   构造函数是什么？

    -   用来创建新对象的函数

```
let now = new Date();
```

-   上述代码中的构造函数是什么？
    -   Date()
-   Date()做了什么？
    -   创建一个只有默认属性和方法的简单对象。
-   函数是否是一种引用类型？
    -   是

## 5.1 Date

-   Date 类型将日期保存为什么？

    -   自协调世界时（UTC，Universal Time

        Coordinated）时间 1970 年 1 月 1 日零时至今所经过的毫秒数。

-   如何创建日期对象？
    -   使用 new 操作符来调用 Date 构造函数

```
let now = new Date();
```

-   在不给 Date 构造函数传参数的情况下，

    创建的对象将保存什么？

    -   当前日期和时间。

-   如何基于其他日期和时间创建日期对象？

    -   传入其毫秒表示

        （1970 年 1 月 1 日零时之后的毫秒数）

-   Date.parse()方法接收什么参数？

    -   一个表示日期的字符串

-   Date.parse()方法对这个字符串参数执行什么操作？

    -   将其转换为表示该日期的毫秒数

-   Date.parse()方法必须支持哪些日期格式？

    -   “月/日/年”

        -   如"5/23/2019"；

    -   “月 日, 年”

        -   如"May 23, 2019"

    -   “周 月 日 年 时:分:秒 时区”

        -   如"Tue May 23 2019 00:00:00GMT-0700"；

    -   “YYYY-MM-DDTHH:mm:ss.sssZ”，

        -   如 2019-05-23T00:00:00

            （只适用于兼容 ES5 的实现）。

-   如何创建一个表示“2019 年 5 月 23 日”的日期对象？

```
let someDate = new Date(Date.parse("May 23, 2019"));
```

-   如果传给 Date.parse()的字符串并不表示日期，

    则该方法会返回什么？

    -   NaN

-   如果直接把表示日期的字符串传给 Date 构造函数，

    那么 Date 会执行什么操作？

    -   隐式调用 Date.parse()
    -   下面这行代码跟前面那行代码是等价的
        -   这两行代码得到的日期对象相同。

```
let someDate = new Date("May 23, 2019");
```

-   不同的浏览器对 Date 类型的实现是否一致？
    -   不一致
        -   很多浏览器会选择用当前日期替代越界的日期，
        -   有些浏览器会将"January 32, 2019"解释为"February 1, 2019"
-   Date.UTC () 方法返回什么？
    -   日期的毫秒表示
-   传给 Date.UTC () 方法的参数是什么？
    -   年
    -   月（1 月是 0，2 月是 1，以此类推）
    -   日（1~31）
    -   时（0~23）
    -   分
    -   秒
    -   毫秒
-   Date.UTC () 方法的参数中，哪些是必需的？
-   只有前两个（年和月）
-   Date.UTC () 方法的日参数默认是什么？
-   1 日
-   Date.UTC () 方法的时、分、秒、毫秒参数的默认值是什么？
-   都是 0

-   Date.UTC () 方法的例子？

```
// GMT时间2000年1月1日零点
let y2k = new Date(Date.UTC(2000, 0));
// GMT时间2005年5月5日下午5点55分55秒
let allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));
```

-   Date.UTC() 是否会被 Date 构造函数隐式调用？
    -   是
-   被 Date 隐式调用情况下，创建的是什么日期？
    -   本地日期
        -   不是 GMT 日期
-   Date 构造函数跟 Date.UTC() 接收的参数是否是一样的？
    -   是
-   前面的例子也可以这样来写：

```
// 本地时间2000年1月1日零点
let y2k = new Date(2000, 0);
// 本地时间2005年5月5日下午5点55分55秒
let allFives = new Date(2005, 4, 5, 17, 55, 55);
```

-   Date.now() 是Date类型的哪种方法？
    -   静态方法

-   Date.now() 方法返回什么？
    -   表示方法执行时日期和时间的毫秒数。
-   Date.now() 方法可以方便地用在哪里？
    -   代码分析中

```
// 起始时间
let start = Date.now();
// 调用函数
doSomething();
// 结束时间
let stop = Date.now(),
result = stop - start;
```

- Date类型实例的getTime()方法返回什么？
  - 当前毫秒数

```
let date = new Date();
date.getTime();
```

### 5.1.1 继承的方法

-   Date 类型重写了哪些方法？

    -   toLocaleString()
    -   toString()
    -   valueOf()

-   重写后这些方法有什么不一样？

    -   返回值不一样

-   Date 类型实例的 toLocaleString()方法返回什么？

    -   返回与浏览器运行的本地环境一致的日期和时间。

-   toLocaleString()方法格式中有什么特点？

    -   包含针对时间的 AM（上午）或 PM（下午）
        -   但不包含时区信息

-   toString()方法通常返回什么？

    -   带时区信息的日期和时间

-   toString()方法时间也是 12 小时还是 24 小时制？

    -   24 小时制

-   现代浏览器在 toLocaleString()和 toString()的输出有什么区别？

    -   没有区别

-   Date 类型的 valueOf()方法返回什么？

    -   日期的毫秒表示


```
let date = new Date();
date.valueOf();
```

-   操作符（如小于号和大于号）是否可以直接

    使用 valueOf()方法返回的值？

    -   可以

```
let date1 = new Date(2019, 0, 1); // 2019年1月1日
let date2 = new Date(2019, 1, 1); // 2019年2月1日 console.log(date1 < date2); // true console.log(date1 > date2); // false
```

-   什么是确保日期先后的一个简单方式？
    -   用操作符（如小于号和大于号）直接比较日期对象

### 5.1.2 日期格式化方法

-   Date 类型有哪几个专门用于格式化日期的方法？

    -   toDateString()

        -   显示日期中的周、月、日、年

    -   toTimeString()

        -   显示日期中的时、分、秒、时区

    -   toLocaleDateString()

        -   显示日期中的周、月、日、年

    -   toLocaleTimeString()

        -   显示日期中的时、分、秒

    -   toUTCString()
        -   显示完整的 UTC 日期

-   为什么这些方法不能用于在用户界面上一致地显示日期？

    -   因为这些方法的输出会因浏览器而异

-   toGMTString()跟 toUTCString() 有什么关系？

    -   是一样的

-   toGMTString()目的是什么？
    -   为了向后兼容。
-   规范建议新代码使用 toUTCString() 还是 toGMTString()？
    -   使用 toUTCString()

### 5.1.3 日期/时间组件方法

| 方法                    | 说明                                                         |
| ----------------------- | ------------------------------------------------------------ |
| getTime()               | 返回日期的毫秒表示；与valueOf()相同                          |
| setTime(*milliseconds*) | 设置日期的毫秒表示，从而修改整个日期                         |
| getFullYear()           | 返回4位数年（即2019而不是19）                                |
| getUTCFullYear()        | 返回UTC日期的4位数年                                         |
| setFullYear(*year*)     | 设置日期的年（*year*必须是4位数）                            |
| setUTCFullYear(*year*)  | 设置UTC日期的年（*year*必须是4位数）                         |
| getMonth()              | 返回日期的月（0表示1月，11表示12月）                         |
| getDate()               | 返回日期中的日（1~31）                                       |
| getDay()                | 返回日期中表示周几的数值（0表示周日，6表示周六）             |
| getHours()              | 返回日期中的时（0~23）                                       |
| getMinutes()            | 返回日期中的分（0~59）                                       |
| getSeconds()            | 返回日期中的秒（0~59）                                       |
| getMilliseconds()       | 返回日期中的毫秒                                             |
| getTimezoneOffset()     | 返回以分钟计的UTC与本地时区的偏移量（如美国EST 即“东部标准时间”返回300，进入夏令时的地区可能有所差异） |



## 5.2 RegExp

-   ECMAScript 通过什么类型支持正则表达式？
    -   RegExp
-   如何创建正则表达式？

```
let expression = /pattern/flags;
```

-   这个正则表达式的 pattern（模式）可以是什么？

    -   任何正则表达式
        -   包括字符类、限定符、分组、向前查找和反向引用

-   每个正则表达式可以带什么，用于控制正则表达式的行为？

    -   零个或多个 flags（标记）

-   匹配模式的标记有哪些？

    -   g：全局模式

        -   表示查找字符串的全部内容，
            -   而不是找到第一个匹配的内容就结束。

    -   i：不区分大小写

        -   表示忽略 pattern 和字符串的大小写。

    -   m：多行模式

        -   表示查找到一行文本末尾时会继续查找。

    -   y：粘附模式

        -   表示只查找从 lastIndex 开始及之后的字符串。

    -   u：Unicode 模式

        -   表示启用 Unicode 匹配

    -   s：dotAll 模式
        -   表示元字符 . 匹配任何字符（包括\n 或\r）

```
// 匹配字符串中的所有"at"
let pattern1 = /at/g;
// 匹配第一个"bat"或"cat"，忽略大小写
let pattern2 = /[bc]at/i;
// 匹配所有以"at"结尾的三字符组合，忽略大小写
let pattern3 = /.at/gi;
```

-   所有元字符在 pattern 中也必须做什么？
-   转义

```
( [ { \ ^ $ | ) ] } ? * + .
```

-   如果要匹配元字符本身，就必须做什么？
    -   使用反斜杠来转义。

```
// 匹配第一个"bat"或"cat"，忽略大小写
let pattern1 = /[bc]at/i;
// 匹配第一个"[bc]at"，忽略大小写
let pattern2 = /\[bc\]at/i;
// 匹配所有以"at"结尾的三字符组合，忽略大小写
let pattern3 = /.at/gi;
// 匹配所有".at"，忽略大小写
let pattern4 = /\.at/gi;
```

-   正则表达式还可以怎么创建？
    -   使用 RegExp 构造函数创建
-   RegExp 构造函数接收哪两个参数？
    -   模式字符串
    -   标记字符串（可选的）

```
// 匹配第一个"bat"或"cat"，忽略大小写
let pattern1 = /[bc]at/i;
// 跟pattern1一样，只不过是用构造函数创建的
let pattern2 = new RegExp("[bc]at", "i");
```

-   为什么 RegExp 构造函数的模式参数

    在某些情况下需要二次转义？

    -   因为 RegExp 的模式参数是字符串

-   所有元字符都必须做什么？

    -   二次转义

        -   包括转义字符序列

            -   （ \ 转义后的字符串是 \\\，

                在正则表达式字符串中则要写成 \\\\\\\ ）。

-   使用 RegExp 是否可以基于已有的正则表达式实例？
    -   可以
-   RegExp 是否可选择性地修改标记？
    -   可以

```
const re1 = /cat/g;
console.log(re1); // "/cat/g"
const re2 = new RegExp(re1);
console.log(re2); // "/cat/g"
const re3 = new RegExp(re1, "i");
console.log(re3); // "/cat/i"
```

### 5.2.1 RegExp 实例属性

-   每个 RegExp 实例都有哪些属性？

    -   global：布尔值，

        -   表示是否设置了 g 标记。

    -   ignoreCase：布尔值，

        -   表示是否设置了 i 标记。

    -   unicode：布尔值，

        -   表示是否设置了 u 标记。

    -   sticky：布尔值，

        -   表示是否设置了 y 标记。

    -   lastIndex：整数，

        -   表示在源字符串中下一次搜索的开始位置，
            -   始终从 0 开始。

    -   multiline：布尔值，

        -   表示是否设置了 m 标记。

    -   dotAll：布尔值，

        -   表示是否设置了 s 标记。

    -   source：正则表达式的字面量字符串

        -   （没有前后斜杠）

    -   flags：正则表达式的标记字符串。
        -   （没有前后斜杠）

```
let pattern1 = /\[bc\]at/i; console.log(pattern1.global); // false console.log(pattern1.ignoreCase); // true
console.log(pattern1.multiline); // false console.log(pattern1.lastIndex); // 0 console.log(pattern1.source); // "\[bc\]at" console.log(pattern1.flags); // "i"
let pattern2 = new RegExp("\\[bc\\]at", "i"); console.log(pattern2.global); // false console.log(pattern2.ignoreCase); // true console.log(pattern2.multiline); // false console.log(pattern2.lastIndex); // 0 console.log(pattern2.source); // "\[bc\]at" console.log(pattern2.flags); // "i"
```

-   source 和 flags 属性返回的是什么？
    -   规范化之后可以在字面量中使用的形式

### 5.2.2 RegExp 实例方法

-   RegExp 实例的方法有哪些？

    -   exec()
    -   test()

-   exec() 方法接收哪个参数？

    -   要应用模式的字符串。

-   exec() 方法如果找到了匹配项，则返回什么？

    -   包含第一个匹配信息的数组

-   exec() 方法如果没找到匹配项，则返回什么？

    -   null。

-   exec() 方法返回的数组包含哪两个额外的属性？

    -   index

        -   字符串中匹配模式的起始位置

    -   input
        -   要查找的字符串。

-   exec() 方法返回的数组第一个元素是什么？

    -   匹配整个模式的字符串

-   exec() 方法返回的数组其他元素是什么？

    -   与表达式中的捕获组匹配的字符串。

-   如果模式中没有捕获组，exec() 方法返回的数组包含什么？

    -   只包含第一个元素。

```
let text = "mom and dad and baby";
let pattern = /mom( and dad( and baby)?)?/gi;
let matches = pattern.exec(text); console.log(matches.index); // 0 console.log(matches.input); // "mom and dad and baby"
console.log(matches[0]); // "mom and dad and baby" console.log(matches[1]); // " and dad and baby" console.log(matches[2]); // " and baby"
```

-   模式包含哪两个捕获组？

    -   最内部的匹配项" and baby"，

    -   外部的匹配项" and dad"或" and dad and baby"。

-   为什么 matchs 数组的 index 属性就是 0？

    -   因为整个字符串匹配模式

-   数组的第一个元素是什么？

    -   匹配的整个字符串，

-   数组的第二、三个元素是什么？

    -   匹配第一个捕获组的字符串
    -   匹配第二个捕获组的字符串

-   如果没有设置全局标记，则无论对同一个字符串调用多少

    次 exec()，都会返回什么？

    -   第一个匹配的信息。

```
let text = "cat, bat, sat, fat";
let pattern = /.at/;
let matches = pattern.exec(text); console.log(matches.index); // 0 console.log(matches[0]); // cat console.log(pattern.lastIndex); // 0
matches = pattern.exec(text); console.log(matches.index); // 0 console.log(matches[0]); // cat console.log(pattern.lastIndex); // 0
```

-   如果在这个模式上设置了 g 标记，

    则每次调用 exec()都会执行什么操作？

    -   在字符串中向前搜索下一个匹配项，

```
let text = "cat, bat, sat, fat";
let pattern = /.at/g;
let matches = pattern.exec(text); console.log(matches.index); // 0 console.log(matches[0]); // cat console.log(pattern.lastIndex); // 3

matches = pattern.exec(text); console.log(matches.index); // 5 console.log(matches[0]); // bat console.log(pattern.lastIndex); // 8

matches = pattern.exec(text); console.log(matches.index); // 10 console.log(matches[0]); // sat console.log(pattern.lastIndex); // 13
```

-   如果模式设置了粘附标记 y，

    则每次调用 exec()会执行什么操作？

    -   就只会在 lastIndex 的位置上寻找匹配项。
    -   粘附标记覆盖全局标记。

```
let text = "cat, bat, sat, fat";
let pattern = /.at/y;
let matches = pattern.exec(text); console.log(matches.index); // 0 console.log(matches[0]); // cat console.log(pattern.lastIndex); // 3

// 以索引3对应的字符开头找不到匹配项，因此exec()返回null
// exec()没找到匹配项，于是将lastIndex设置为0
matches = pattern.exec(text);
console.log(matches); // null console.log(pattern.lastIndex); // 0

// 向前设置lastIndex可以让粘附的模式通过exec()找到下一个匹配项：
pattern.lastIndex = 5;
matches = pattern.exec(text); console.log(matches.index); // 5 console.log(matches[0]); // bat console.log(pattern.lastIndex); // 8
```

-   正则表达式的另一个方法是 test()，接收什么参数？
    -   一个字符串参数
-   如果 test()传入的字符串参数与模式匹配，则返回什么？
    -   则返回 true，
    -   否则返回 false

### 5.2.3 RegExp 构造函数属性

-   RegExp 构造函数本身也有几个属性。
-   RegExp 构造函数属性适用于什么正则表达式？
-   作用域中的所有正则表达式
-   RegExp 构造函数属性会根据什么而变化？
    -   最后执行的正则表达式操作
-   RegExp 构造函数属性可以通过哪两种不同的方式访问？

    -   全名
    -   简写

-   下表列出了 RegExp 构造函数的属性

| 全名         | 简写 | 说明                                      |
| ------------ | ---- | ----------------------------------------- |
| input        | $\_  | 最后搜索的字符串（非标准特性）            |
| lastMatch    | $&   | 最后匹配的文本                            |
| lastParen    | $+   | 最后匹配的捕获组（非标准特性）            |
| leftContext  | $`   | input 字符串中出现在 lastMatch 前面的文本 |
| rightContext | $'   | input 字符串中出现在 lastMatch 后面的文本 |

-   通过 RegExp 构造函数属性可以提取出什么信息？
    -   与 exec()和 test()执行的操作相关的信息

```
let text = "this has been a short summer";
let pattern = /(.)hort/g;

if (pattern.test(text)) {
    console.log(RegExp.input); // this has been a short summer
    console.log(RegExp.leftContext); // this has been a
    console.log(RegExp.rightContext); // summer
    console.log(RegExp.lastMatch); // short
    console.log(RegExp.lastParen); // s
}
```

-   RegExp 构造函数属性名的简写形式为什么要使用中括号语法来访问？
    -   因为大多数简写形式都不是合法的 ECMAScript 标识符

```
let text = "this has been a short summer";
let pattern = /(.)hort/g; /** 注意：Opera 不支持简写属性名 * IE 不支持多行匹配 */
if (pattern.test(text)) {
    console.log(RegExp.$_); // this has been a short summer
    console.log(RegExp["$`"]); // this has been a
    console.log(RegExp["$'"]); // summer
    console.log(RegExp["$&"]); // short
    console.log(RegExp["$+"]); // s
}
```

-   可以存储最多几个捕获组的匹配项？
    -   9
-   通过什么来访问捕获组的匹配项？
    -   RegExp.$1~RegExp.$9
        -   分别包含第 1~9 个捕获组的匹配项。

```
let text = "this has been a short summer";
let pattern = /(..)or(.)/g;
if (pattern.test(text)) {
    console.log(RegExp.$1); // sh
    console.log(RegExp.$2); // t
}
```

-   为什么不要在生产环境中使用 RegExp 构造函数？

    -   因为 RegExp 构造函数的所有属性

        都没有任何 Web 标准出处

### 5.2.4 模式局限

-   哪些特性目前还没有得到 ECMAScript 的支持？

    -   \A 和\Z 锚（分别匹配字符串的开始和末尾）

    -   联合及交叉类

    -   原子组

    -   x（忽略空格）匹配模式

    -   条件式匹配

    -   正则表达式注释

## 5.3 原始值包装类型

-   为了方便操作原始值，

    ECMAScript 提供了哪 3 种特殊的引用类型？

    -   Boolean
    -   Number
    -   String

-   每当用到某个原始值的方法或属性时，后台执行什么操作？

    -   会创建一个相应原始包装类型的对象，
        -   从而暴露出操作原始值的各种方法

```
let s1 = "some text";
let s2 = s1.substring(2);
```

-   当第二行访问 s1 时，是以什么模式访问的？

    -   读模式
        -   要从内存中读取变量保存的值。

-   在以读模式访问字符串值的时候，后台都会执行什么操作？

    -   (1) 创建一个 String 类型的实例；
    -   (2) 调用实例上的特定方法；

    -   (3) 销毁实例

```
let s1 = new String("some text");
let s2 = s1.substring(2);
s1 = null;
```

-   这种行为可以让原始值发生什么变化？
    -   拥有对象的行为
-   引用类型与原始值包装类型的主要区别是什么？
    -   对象的生命周期不同
        -   在通过 new 实例化得到的实例，
            -   会在离开作用域时被销毁，
        -   自动创建的原始值包装对象
            -   只存在于访问它的那行代码执行期间
-   是否能在运行时给原始值添加属性和方法?
    -   不能

```
let s1 = "some text";
s1.color = "red";
console.log(s1.color); // undefined
```

-   第二行代码运行时会执行什么操作？

    -   临时创建一个 String 对象，

-   第三行代码执行时，这个临时对象是否存在？

    -   已经被销毁了

-   第三行代码执行了什么操作？

    -   创建了自己的 String 对象
        -   但这个对象没有 color 属性。

-   在原始值包装类型的实例上调用 typeof 会返回什么？

    -   "object"

-   所有原始值包装对象都会转换为什么布尔值？

    -   true

-   Object 构造函数作为一个工厂方法，

    能够根据传入值的类型返回什么？

    -   相应原始值包装类型的实例
        -   如果是字符串
            -   则会创建 String 的实例。
        -   如果是数值
            -   则会创建 Number 的实例。
        -   如果是布尔值
            -   则会创建 Boolean 的实例。

```
let obj = new Object("some text");
console.log(obj instanceof String); // true
```

-   使用 new 调用原始值包装类型的构造函数，

    与调用同名的转型函数是否一样

    -   不一样

```
let value = "25";
let number = Number(value); // 转型函数 console.log(typeof number); // "number"
let obj = new Number(value); // 构造函数 console.log(typeof obj); // "object"
```

### 5.3.1 Boolean

-   如何创建一个 Boolean 对象？
    -   使用 Boolean 构造函数
    -   并传入 true 或 false

```
let booleanObject = new Boolean(true);
```

-   Boolean 的实例重写的 valueOf() 方法返回什么？
    -   一个原始值 true 或 false 。
-   Boolean 的实例重写的 toString() 方法返回什么？
    -   字符串 "true" 或 "false"

```
let falseObject = new Boolean(false);
let result = falseObject && true; console.log(result); // true
let falseValue = false;
result = falseValue && true;
console.log(result); // false
```

-   所有对象在布尔表达式中都会自动转换成什么？

    -   true

-   原始值和引用值（Boolean 对象）有什么区别？

    -   typeof 操作符

        -   对原始值返回"boolean"，
        -   对引用值返回"object"。

    -   instaceof 操作符 Boolean
        -   对原始值返回 false
        -   对引用值返回 true

-   建议永远不要使用原始值还是引用值（Boolean 对象） ？

    -   引用值（Boolean 对象）

### 5.3.2 Number

-   如何创建一个 Number 对象？
    -   使用 Number 构造函数
    -   并传入一个数值

```
let numberObject = new Number(10);
```

-   Number 类型重写的 valueOf() 方法返回什么？

    -   Number 对象表示的原始数值

-   Number 类型重写的 toLocaleString() 方法返回什么？

    -   数值字符串

-   Number 类型重写的 toString()方法接收什么参数？

    返回什么？

    -   可选地接收一个表示基数的参数
    -   返回相应基数形式的数值字符串

```
let num = 10;
console.log(num.toString()); // "10"
console.log(num.toString(2)); // "1010" console.log(num.toString(8)); // "12" console.log(num.toString(10)); // "10" console.log(num.toString(16)); // "a
```

-   Number 类型提供了哪几个

    用于将数值格式化为字符串的方法？

    -   toFixed ()
    -   toExponential ()
    -   toPrecision()

-   toFixed()方法返回什么？

    -   包含指定小数点位数的数值字符串

```
let num = 10;
console.log(num.toFixed(2)); // "10.00"
```

-   如果调用 toFixed()方法的数值本身的小数位

    超过了参数指定的位数，则返回什么？

    -   四舍五入到最接近的小数位

```
let num = 10.005;
console.log(num.toFixed(2)); // "10.01"
```

-   多个浮点数值的数学计算是否一定能得到精确的结果？

    -   不一定
    -   比如，0.1 + 0.2 = 0.30000000000000004

-   toFixed()方法可以表示有多少个小数位的数值？

-   0 ~ 20 个小数位

-   toExponential()返回什么？

    -   以科学记数法（也称为指数记数法）

        表示的数值字符串

-   toExponential()接收什么参数？
    -   参数表示结果中小数的位数

```
let num = 10;
console.log(num.toExponential(1)); // "1.0e+1"
```

-   如果想得到数值最适当的形式，可以使用什么方法？
    -   toPrecision() 方法
-   toPrecision()方法会执行什么操作？
    -   根据情况返回最合理的输出结果
-   toPrecision()方法会返回哪几种结果？
    -   固定长度形式
    -   科学记数法形式。
-   toPrecision() 方法接收什么参数
    -   表示结果中数字的总位数（不包含指数）

```
let num = 99;
console.log(num.toPrecision(1)); // "1e+2" console.log(num.toPrecision(2)); // "99" console.log(num.toPrecision(3)); // "99.0"
```

-   为什么 toPrecision()方法就将 99 舍入为 100？
    -   因为 99 不能只用 1 位数字来精确表示
        -   100 能用 1 位数字（及其科学记数法形式）来表示
-   这 3 个方法是否都会向上或向下舍入？为什么？
    -   都会舍入
        -   为了以正确的小数位精确表示数值
-   toPrecision()方法可以表示带几个小数位的数值？
    -   1~21 个小数位
-   在处理原始数值和引用数值时，typeof 和 instacnceof 操作符会返回哪些结果？

```
let numberObject = new Number(10);
let numberValue = 10;
console.log(typeof numberObject); // "object" console.log(typeof numberValue); // "number" console.log(numberObject instanceof Number); // true
console.log(numberValue instanceof Number); // false
```

#### **isInteger()**方法与安全整数

-   Number.isInteger()方法用来做什么？
    -   辨别一个数值是否保存为整数

```
console.log(Number.isInteger(1)); // true console.log(Number.isInteger(1.00)); // true console.log(Number.isInteger(1.01)); // false
```

-   IEEE 754 数值格式有一个特殊的数值范围，

    在这个范围内二进制值可以表示一个整数值，

    这个数值范围是什么？

    -   从 Number.MIN_SAFE_INTEGER （-2^53 + 1）

        到 Number.MAX_SAFE_INTEGER（2^53 - 1）

-   如何鉴别整数是否在这个范围内？
    -   用 Number.isSafeInteger()方法

```
console.log(Number.isSafeInteger(-1 * (2 ** 53))); // false console.log(Number.isSafeInteger(-1 * (2 ** 53) + 1)); // true
console.log(Number.isSafeInteger(2 ** 53)); // false
console.log(Number.isSafeInteger((2 ** 53) - 1)); // true
```

### **5.3.3** **String**

-   如何创建一个 String 对象，
    -   使用 String 构造函数并传入一个数值

```
let stringObject = new String("hello world");
```

-   String 对象的方法可以在什么字符串原始值上调用？
    -   所有字符串原始值
-   String 对象有哪几个继承的方法 ？返回什么？
    -   valueOf()
    -   toLocaleString()
    -   toString()
    -   都返回对象的原始字符串
-   每个 String 对象都有一个 length 属性，这个属性表示什么？
    -   字符串中字符的数量。

```
let stringValue = "hello world";
console.log(stringValue.length); // "11"
```

-   如果字符串中包含双字节字符

    （而不是单字节的 ASCII 字符），length 属性会按什么计数？

    -   按单字符来计数

#### 01. **JavaScript**字符

-   JavaScript 字符串由多少位码元（code unit）组成？
    -   16 位码元
-   对多数字符来说， 每 16 位码元对应多少个字符？
    -   一个
-   字符串的 length 属性表示什么（码元）？
    -   表示字符串包含多少 16 位码元

```
let message = "abcde"; console.log(message.length); // 5
```

-   charAt()方法执行什么操作？
    -   查找指定索引位置的 16 位码元
    -   并返回该码元对应的字符
        -   索引位置由方法的整数参数指定。

```
let message = "abcde"; console.log(message.charAt(2)); // "c"
```

-   JavaScript 字符串使用了哪两种 Unicode 编码混合的策略？

    -   UCS-2
    -   UTF-16

-   对于可以采用 16 位编码的字符（U+0000~U+FFFF），

    UCS-2 和 UTF-16 两种编码有什么区别？

    -   没有区别

-   使用 charCodeAt()方法可以做什么？

    -   查看指定码元的字符编码。

-   charCodeAt()方法返回什么？

    -   指定索引位置的码元值，
        -   索引由整数参数指定

```
let message = "abcde";
// Unicode "Latin small letter C"的编码是U+0063 console.log(message.charCodeAt(2)); // 99
// 十进制99等于十六进制63
console.log(99 === 0x63); // true
```

- fromCharCode()方法用于什么？

  - 根据给定的 UTF-16 码元

    创建字符串中的字符。

-   fromCharCode()方法可以接受多少个数值？

    -   任意多个数值

-   fromCharCode()方法返回什么？

    -   将所有数值对应的字符

        拼接起来的字符串

```
// Unicode "Latin small letter A"的编码是U+0061
// Unicode "Latin small letter B"的编码是U+0062
// Unicode "Latin small letter C"的编码是U+0063
// Unicode "Latin small letter D"的编码是U+0064
// Unicode "Latin small letter E"的编码是U+0065 console.log(String.fromCharCode(0x61, 0x62, 0x63, 0x64, 0x65)); // "abcde"
// 0x0061 === 97
// 0x0062 === 98
// 0x0063 === 99
// 0x0064 === 100
// 0x0065 === 101 console.log(String.fromCharCode(97, 98, 99, 100, 101)); // "abcde"
```

-   为什么对于 U+0000~U+FFFF 范围内的字符，

    length、charAt()、charCodeAt()、fromCharCode()

    返回的结果跟预期一样？

    -   因为在这个范围内，每个字符都是用 16 位表示的，

    -   而这几个方法也都基于 16 位码元完成操作。

    -   只要字符编码大小与码元大小一一对应，

        这些方法就能如期工作

-   字符编码大小与码元大小的对应关系在扩展到 Unicode 增补字符平面时是否成立？
    -   不成立
        -   即 16 位只能唯一表示 65 536 个字符
-   为了表示更多的字符，Unicode 采用了什么策略？
    -   每个字符使用两个 16 位码元
-   这种每个字符使用两个 16 位码元的策略称为什么？
    -   代理对

```
// "smiling face with smiling eyes" 表情符号的编码是U+1F60A
// 0x1F60A === 128522 let message = "ab☺de"; console.log(message.length); // 6 console.log(message.charAt(1)); // b console.log(message.charAt(2)); // <?> console.log(message.charAt(3)); // <?> console.log(message.charAt(4)); // d console.log(message.charCodeAt(1)); // 98 console.log(message.charCodeAt(2)); // 55357 console.log(message.charCodeAt(3)); // 56842 console.log(message.charCodeAt(4)); // 100 console.log(String.fromCodePoint(0x1F60A)); // ☺ console.log(String.fromCharCode(97, 98, 55357, 56842, 100, 101)); // ab☺d
```

-   charAt（）方法将多少位码元当作一个字符？
    -   16 位码元
-   事实上索引 2 和索引 3 对应的码元应该被看成什么？
    -   一个代理对，只对应一个字符。
-   为什么 fromCharCode() 方法仍然返回正确的结果？
    -   因为它是基于提供的二进制表示直接组合成字符串
-   浏览器是否可以正确解析代理对（由两个码元构成）？
    -   可以
-   为正确解析既包含单码元字符又包含代理对字符的字符串，可以使用什么方法来代替 charCodeAt()？
    -   codePointAt() 方法
-   codePointAt()接收什么参数并返回什么？

    -   接收 16 位码元的索引参数
    -   返回该索引位置上的码点（code point）

-   码点是什么？
    -   Unicode 中一个字符的完整标识。
-   码点是 16 位的还是 32 位的？
    -   可能是 16 位，也可能是 32 位，
-   codePointAt()方法可以从指定码元位置执行什么操作？
    -   识别完整的码点

```
let message = "ab☺de"; console.log(message.codePointAt(1)); // 98 console.log(message.codePointAt(2)); // 128522 console.log(message.codePointAt(3)); // 56842 console.log(message.codePointAt(4)); // 100
```

-   如果传入的码元索引并非代理对的开头，就会返回什么？
    -   错误的码点。
-   这种错误只有什么时候才会出现，？
    -   检测单个字符时
-   可以通过什么来规避？
    -   从左到是右按正确的码元数遍历字符串
-   迭代字符串是否可以智能地识别代理对的码点？
    -   是

```
console.log([..."ab☺de"]); // ["a", "b", "☺", "d", "e"]
```

-   fromCodePoint()方法接收什么？返回什么？
    -   接收任意数量的码点，
    -   返回对应字符拼接起来的字符串

```
console.log(String.fromCharCode(97, 98, 55357, 56842, 100, 101)); // ab☺de console.log(String.fromCodePoint(97, 98, 128522, 100, 101)); // ab☺de
```

#### 02. **normalize()**方法

-   字符可以通过什么表示？
    -   通过一个 BMP 字符表示，
    -   也可以通过一个代理对表示。

```
// U+00C5：上面带圆圈的大写拉丁字母A console.log(String.fromCharCode(0x00C5)); // Å
// U+212B：长度单位“埃” console.log(String.fromCharCode(0x212B)); // Å
// U+004：大写拉丁字母A
// U+030A：上面加个圆圈 console.log(String.fromCharCode(0x0041, 0x030A));
```

-   为什么代码中这 3 个字符互不相等？
    -   因为比较操作符不在乎字符看起来是什么样的

```
let a1 = String.fromCharCode(0x00C5),
a2 = String.fromCharCode(0x212B),
a3 = String.fromCharCode(0x0041, 0x030A); console.log(a1, a2, a3); // Å, Å, Å console.log(a1 === a2); // false
console.log(a1 === a3); // false
console.log(a2 === a3); // false
```

-   Unicode 提供的规范化形式，可以将类似上面的字符进行什么操作？

    -   规范化为一致的格式

-   Unicode 提供了哪 4 种规范化形式？

    -   NFD（Normalization Form D）、

    -   NFC（Normalization Form C）、
    -   NFKD（Normalization Form KD）

    -   NFKC（Normalization Form KC）

-   可以使用什么方法对字符串应用上述规范化形式？

    -   normalize()方法

-   使用 normalize()方法时需要传入什么参数？

    -   表示哪种形式的字符串：

        "NFD"、"NFC"、"NFKD"、"NFKC"

-   如何判断该字符串是否已经规范化了？
    -   通过比较字符串与其调用 normalize()的返回值

```
let a1 = String.fromCharCode(0x00C5),
a2 = String.fromCharCode(0x212B),
a3 = String.fromCharCode(0x0041, 0x030A);
// U+00C5是对0+212B进行NFC/NFKC规范化之后的结果 console.log(a1 === a1.normalize("NFD")); // false console.log(a1 === a1.normalize("NFC")); // true console.log(a1 === a1.normalize("NFKD")); // false
console.log(a1 === a1.normalize("NFKC")); // true // U+212B是未规范化的
console.log(a2 === a2.normalize("NFD")); // false console.log(a2 === a2.normalize("NFC")); // false console.log(a2 === a2.normalize("NFKD")); // false
console.log(a2 === a2.normalize("NFKC")); // false
// U+0041/U+030A是对0+212B进行NFD/NFKD规范化之后的结果
console.log(a3 === a3.normalize("NFD")); // true console.log(a3 === a3.normalize("NFC")); // false console.log(a3 === a3.normalize("NFKD")); // true console.log(a3 === a3.normalize("NFKC")); // false
```

-   怎样选择规范化形式可以让比较操作符返回正确的结果？
    -   选择同一种规范化形式

```
let a1 = String.fromCharCode(0x00C5),
a2 = String.fromCharCode(0x212B),
a3 = String.fromCharCode(0x0041, 0x030A); console.log(a1.normalize("NFD") === a2.normalize("NFD")); // true console.log(a2.normalize("NFKC") === a3.normalize("NFKC")); // true console.log(a1.normalize("NFC") === a3.normalize("NFC")); // true
```

#### 03. 字符串操作方法

-   concat()用于做什么？
    -   将一个或多个字符串拼接成一个新字符串。

```
let stringValue = "hello ";
let result = stringValue.concat("world"); console.log(result); // "hello world"
console.log(stringValue); // "hello"
```

-   concat()方法可以多少个参数，？
    -   接收任意多个参数
-   concat()方法是否可以一次性拼接多个字符串？
    -   可以

```
let stringValue = "hello ";
let result = stringValue.concat("world", "!"); console.log(result); // "hello world!" console.log(stringValue); // "hello"
```

-   拼接字符串常用的方式是什么？

    -   使用加号操作符（+）

-   ECMAScript 提供了哪 3 个从字符串中提取子字符串的方法？

    -   slice()、
    -   substr()
    -   substring()。

-   这 3 个从字符串中提取子字符串方法都返回什么？

-   返回字符串中的一个子字符串

-   这 3 个从字符串中提取子字符串方法

    接收的第一个参数表示什么？

    -   表示子字符串开始的位置，

-   对 slice()和 substring()而言，第二个参数表示什么？

    -   是提取结束的位置
        -   （即该位置之前的字符会被提取出来）。

-   对 substr()而言，第二个参数表示什么？

    -   表示返回的子字符串数量。

-   任何情况下，省略第二个参数都意味着什么？

    -   提取到字符串末尾。

-   slice()、substr()、substring()是否会修改调用原字符串？

    -   不会修改
        -   只会返回提取到的新字符串值。

```
let stringValue = "hello world"; console.log(stringValue.slice(3)); // "lo world" console.log(stringValue.substring(3)); // "lo world"
console.log(stringValue.substr(3)); // "lo world" console.log(stringValue.slice(3, 7)); // "lo w" console.log(stringValue.substring(3,7)); // "lo w"
console.log(stringValue.substr(3, 7)); // "lo worl"
```

-   slice() 方法将所有负值参数都当成什么？
    -   字符串长度加上负参数值。
-   substr()方法将第一个负参数值当成什么？
    -   当成字符串长度加上该值
-   substr()方法将第二个负参数值进行什么操作？
    -   转换为 0
-   substring()方法会将所有负参数值都进行什么操作？
    -   都转换为 0

```
let stringValue = "hello world"; console.log(stringValue.slice(-3)); // "rld" console.log(stringValue.substring(-3)); // "hello world"
console.log(stringValue.substr(-3)); // "rld" console.log(stringValue.slice(3, -4)); // "lo w" console.log(stringValue.substring(3, -4)); // "hel"
console.log(stringValue.substr(3, -4)); // "" (empty string)
```

#### 04. 字符串位置方法

-   哪两个方法用于在字符串中定位子字符串

    -   indexOf()

    -   lastIndexOf()

-   这两个方法执行什么操作？

    -   从字符串中搜索传入的字符串，
    -   并返回位置
        -   （如果没找到，则返回-1）

-   两者的区别在于什么？

    -   indexOf()方法从字符串开头开始查找子字符串，
    -   lastIndexOf()方法从字符串末尾开始查找子字符串。

```
let stringValue = "hello world"; console.log(stringValue.indexOf("o")); // 4
console.log(stringValue.lastIndexOf("o")); // 7
```

-   这两个方法接收可选的第二个参数，该参数表示什么？

    -   表示开始搜索的位置

        -   indexOf()

            -   会从这个参数指定的位置开始

                向字符串末尾搜索

        -   lastIndexOf()

            -   则会从这个参数指定的位置开始

                向字符串开头搜索

```
let stringValue = "hello world"; console.log(stringValue.indexOf("o", 6)); // 7 console.log(stringValue.lastIndexOf("o", 6)); // 4
```

-   如何在字符串中找到所有的目标子字符串？
    -   使用第二个参数并循环调用 indexOf()或 lastIndexOf()

```
let stringValue = "Lorem ipsum dolor sit amet, consectetur adipisicing elit";
let positions = new Array();
let pos = stringValue.indexOf("e");
while(pos > -1) {
	positions.push(pos);
	pos = stringValue.indexOf("e", pos + 1);
}
console.log(positions); // [3,24,32,35,52]
```

#### 05. 字符串包含方法

-   ECMAScript 6 增加了哪 3 个方法

    用于判断字符串中是否包含另一个字符串？

    -   startsWith()、
    -   endsWith()
    -   includes()

-   这些方法都会执行什么操作？返回什么？

    -   从字符串中搜索传入的字符串，
    -   并返回一个表示是否包含的布尔值。

-   它们的区别在于什么？

    -   startsWith()检查开始于索引 0 的匹配项，

    -   endsWith()检查开始于索引

        (string.length -substring.length)的匹配项，

    -   includes()检查整个字符串

```
let message = "foobarbaz"; console.log(message.startsWith("foo")); // true console.log(message.startsWith("bar")); // false console.log(message.endsWith("baz")); // true console.log(message.endsWith("bar")); // false console.log(message.includes("bar")); // true console.log(message.includes("qux")); // false
```

-   startsWith()和 includes()方法接收的第二个参数表示什么？
    -   开始搜索的位置。
-   如果传入第二个参数，这两个方法会执行什么操作？
    -   从指定位置向着字符串末尾搜索

```
let message = "foobarbaz"; console.log(message.startsWith("foo")); // true console.log(message.startsWith("foo", 1)); // false
console.log(message.includes("bar")); // true console.log(message.includes("bar", 4)); // false
```

-   endsWith()方法接收可选的第二个参数表示什么？

    -   应该当作字符串末尾的位置。

-   endsWith()方法如果不提供第二个参数，那么默认是什么？

    -   就是字符串长度。

-   endsWith()方法如果提供第二个参数，

    那么会执行什么操作？

    -   就忽略从参数位置向末尾的字符

```
let message = "foobarbaz"; console.log(message.endsWith("bar")); // false console.log(message.endsWith("bar", 6)); // true
```

#### 06. **trim()**方法

-   ECMAScript 在哪些字符串上都提供了 trim()方法？
    -   所有字符串
-   trim()方法会执行什么操作？返回什么？
    -   创建字符串的一个副本，
    -   删除前、后所有空格符，
    -   再返回结果

```
let stringValue = " hello world "; let trimmedStringValue = stringValue.trim(); console.log(stringValue); // " hello world " console.log(trimmedStringValue); // "hello world
```

-   原始字符串是否受影响，？
    -   不会
        -   因为 trim()返回的是字符串的副本，
        -   因此原本的前、后空格符都会保留。
-   trimLeft()和 trimRight()方法分别用于什么？
    -   从字符串开始和末尾清理空格符。

#### 07. **repeat()**方法

-   repeat()方法接收一个什么类型的参数？该参数表示什么？

    -   一个整数参数，

    -   表示要将字符串复制多少次，

-   repeat()方法返回什么？

    -   返回拼接所有副本后的结果。

```
let stringValue = "na "; console.log(stringValue.repeat(16) + "batman"); // na na na na na na na na na na na na na na na na batman
```

#### 08. **padStart()**和**padEnd()**方法

-   padStart()和 padEnd()方法会执行什么操作？
    -   复制字符串
-   如果小于指定长度，则执行什么操作？
    -   在相应一边填充字符，直至满足长度条件。
-   这两个方法的第一个参数是什么？第二个参数是什么？
    -   第一个参数是长度，
    -   第二个参数是可选的填充字符串，默认为空格

```
let stringValue = "foo"; console.log(stringValue.padStart(6)); // " foo" console.log(stringValue.padStart(9, ".")); // "......foo"
console.log(stringValue.padEnd(6)); // "foo " console.log(stringValue.padEnd(9, ".")); // "foo......"
```

-   可选的第二个参数是否限于一个字符？
    -   不限于
-   如果提供了多个字符的字符串，则会执行什么操作？
    -   将其拼接并截断以匹配指定长度。
-   如果长度小于或等于字符串长度，则会执行什么操作？
    -   返回原始字符串

```
let stringValue = "foo"; console.log(stringValue.padStart(8, "bar")); // "barbafoo"
console.log(stringValue.padStart(2)); // "foo" console.log(stringValue.padEnd(8, "bar")); // "foobarba"
console.log(stringValue.padEnd(2)); // "foo"
```

#### 09. 字符串迭代与解构

-   字符串的原型上暴露了一个@@iterator 方法，

    该方法表示什么？

    -   表示可以迭代字符串的每个字符。

```
let message = "abc"; let stringIterator = message[Symbol.iterator](); console.log(stringIterator.next()); // {value: "a", done: false} console.log(stringIterator.next()); // {value: "b", done: false} console.log(stringIterator.next()); // {value: "c", done: false} console.log(stringIterator.next()); // {value: undefined, done: true}
```

-   如何按序访问每个字符？
    -   在 for-of 循环中可以通过这个迭代器访问

```
for (const c of "abcde") {
console.log(c);
}
// a
// b
// c
// d
// e
```

-   有了这个迭代器之后，

    字符串就可以通过什么操作符来解构了？

    -   解构操作符

-   如何把字符串分割为字符数组？

```
let message = "abcde";
console.log([...message]); // ["a", "b", "c", "d", "e"]
```

#### 10. 字符串大小写转换

-   涉及大小写转换，包括哪 4 个方法？

    -   toLowerCase()、
    -   toLocaleLowerCase()、
    -   toUpperCase()
    -   toLocaleUpperCase()。

-   toLocaleLowerCase()和 toLocaleUpperCase()方法

    旨在什么？

    -   基于特定地区实现

```
let stringValue = "hello world"; console.log(stringValue.toLocaleUpperCase()); // "HELLO WORLD" console.log(stringValue.toUpperCase()); // "HELLO WORLD" console.log(stringValue.toLocaleLowerCase()); // "hello world" console.log(stringValue.toLowerCase()); // "hello world"
```

-   如果不知道代码涉及什么语言，则最好使用什么转换方法？
    -   地区特定的转换方法

#### 11. 字符串模式匹配方法

-   字符串模式匹配的方法有哪些？

    -   match（）
    -   search（）
    -   replace（）
    -   split（）

-   match()方法方法本质上跟什么方法相同？

    -   跟 RegExp 对象的 exec()方法相同。

-   match()方法接收一个什么参数？

    -   可以是一个正则表达式字符串，

    -   也可以是一个 RegExp 对象

```
let text = "cat, bat, sat, fat";
let pattern = /.at/; // 等价于pattern.exec(text)
let matches = text.match(pattern); console.log(matches.index); // 0 console.log(matches[0]); // "cat" console.log(pattern.lastIndex); // 0
```

-   match()方法返回的数组与 RegExp 对象的 exec()方法返回的数组有什么关系？

    -   是一样的

-   match()方法返回的数组第一个元素是什么？其余元素是什么？

    -   第一个元素是与整个模式匹配的字符串，
    -   其余元素是与表达式中的捕获组匹配的字符串
        -   （如果有的话）。

-   search()方法唯一的参数是什么？

    -   正则表达式字符串或 RegExp 对象

-   search（）方法返回什么？

    -   返回模式第一个匹配的位置索引
    -   如果没找到则返回 -1

-   search（）始终按照什么方向匹配模式？

    -   从字符串开头向后

```
let text = "cat, bat, sat, fat";
let pos = text.search(/at/);
console.log(pos);
```

-   replace（）方法接收哪两个参数？

    -   第一个参数可以是一个 RegExp 对象或一个字符串

    -   第二个参数可以是一个字符串或一个函数

-   如果第一个参数是字符串，那么会执行什么操作？

    -   只会替换第一个子字符串

-   如何替换所有子字符串？

    -   第一个参数必须为正则表达式
    -   并且带全局标记

```
let text = "cat, bat, sat, fat";
let result = text.replace("at", "ond");
console.log(result); // "cond, bat, sat, fat"

result = text.replce(/at/g, "ond");

console.log(result); // "cond, bond, sond, fond"
```

-   replace（）方法的第二个参数是字符串的情况下，

    有哪几个特殊的字符序列？

| 字符序列 | 替换文本                                                |
| -------- | ------------------------------------------------------- |
| $$       | $                                                       |
| $&       | 匹配整个模式的子字符串，与 RegExp.lastMatch 相同        |
| $'       | 匹配的子字符串之前的字符串，与 RegExp.rightContext 相同 |
| $`       | 匹配的子字符串之后的字符串，与 RegExp.leftContext 相同  |
| $n       | 匹配第 n 个捕获组的子字符串，其中 n 是 0~9              |
| $nn      | 匹配第 nn 个捕获组的字符串，其中 nn 是 01-99            |

-   使用这些特殊的序列，可以做什么？
    -   在替换文本中使用之前匹配的内容

```
let text = "cat, bat, sat, fat";
result = text.replace(/(.at)/g, "word ($1)"); console.log(result); // word (cat), word (bat), word (sat), word (fat)
```

-   replace()的第二个参数可以是一个函数，

    在只有一个匹配项时，

    这个函数会收到哪 3 个参数？

    -   与整个模式匹配的字符串
    -   匹配项在字符串中的开始位置
    -   整个字符串

-   在有多个捕获组的情况下，

    每个匹配捕获组的字符串也会作为参数传给这个函数，

    但最后两个参数还是什么？

    -   匹配项在字符串中的开始位置
    -   整个字符串

-   这个函数应该返回一个字符串，这个字符串表示什么？

    -   表示应该把匹配项替换成什么。

-   使用函数作为第二个参数有什么好处？

    -   可以更细致地控制替换过程，

```
function htmlEscape(text) {
    return text.replace(/[<>"&]/g, function (match, pos, originalText) {
        switch (match) {
            case "<":
                return "&lt;";
            case ">":
                return "&gt;";
            case "&":
                return "&amp;";
            case "\"":
                return "&quot;";
        }
    });
}
console.log(htmlEscape("<p class=\"greeting\">Hello world!</p>"));
// "&lt;p class=&quot;greeting&quot;&gt;Hello world!</p>"
```

-   split（）方法会执行什么操作？

    -   会根据传入的分隔符

        将字符串拆分成数组

-   作为分隔符的参数可以是什么？

    -   可以是字符串
    -   也可以是 RegExp 对象
    
-   split（）方法的第二个参数是什么？

    -   数组大小
        -   以确保返回的数组不会超过指定大小

```
let colorText = "red,blue,green,yellow";
let colors1 = colorText.split(",");
let colors2 = colorText.split(",", 2);
let colors3 = colorText.split(/[^,]+/);
// ["", ",", ",", ",", ""]
```

#### 13. HTML 方法

## 5.4 单例内置对象

-   ECMA-262 对内置对象的定义是什么？

    -   “任何由 ECMAScript 实现提供、

        与宿主环境无关，

        并在 ECMAScript 程序开始执行时就存在的对象”

-   为什么开发者不用显式地实例化内置对象？

    -   ，因为它们已经实例化好了

### 5.4.1 Global

-   在全局作用域中定义的变量和函数都会变成什么对象的属性 ？
    -   Global 对象

#### 01. **URL**编码方法

-   哪两个方法用于编码统一资源标识符（URI）？

    -   encodeURI()
    -   encodeURIComponent()方法

-   使用 URI 编码方法来编码 URI 有什么好处？

    -   可以让浏览器能够理解它们，
    -   同时又以特殊的 UTF-8 编码替换掉所有无效字符

-   ecnodeURI()方法用于什么？

    -   对整个 URI 进行编码，
        -   比如"www.wrox.com/illegal value.js"。

-   encodeURIComponent()方法用于什么？

    -   编码 URI 中单独的组件，
        -   比如前面 URL 中的"illegalvalue.js"

-   这两个方法的主要区别是什么？

    -   encodeURI()不会编码属于 URL 组件的特殊字符，

        -   比如冒号、斜杠、问号、井号，

    -   encodeURIComponent()会编码

        它发现的所有非标准字符。

```
let uri = "http://www.wrox.com/illegal value.js#start";
// "http://www.wrox.com/illegal%20value.js#start" console.log(encodeURI(uri));
```

-   一般来说，使用哪种方法的频率更高？

    -   encodeURIComponent（）

        -   因为编码查询字符串参数比

            编码基准 URI 的次数更多

-   与 encodeURI（）和 encodeURIComponent()相对的是什么方法？

    -   decodeURI（）
        -   只对使用 encodeURI（）编码过的字符解码
    -   decodeURIComponent()
        -   解码所有 encodeURIComponent()编码的字符
        -   基本上就是解码所有特殊值

-   URI 方法取代了哪两个方法？
    -   escape（）
    -   unescape（）

#### 02. **eval()**方法

-   eval（）方法就是一个什么？
    -   完整的 ECMAScript 解释器
-   eval（）方法接收一个什么参数
-   一个要执行的 ECMAScript（JavaScript）字符串。

```
eval("console.log('hi')");
```

-   上面这行代码的功能与下一行等价：

```
console.log("hi");
```

-   当解释器发现 eval()调用时，会执行什么操作？

    -   将参数解释为实际的 ECMAScript 语句，
    -   然后将其插入到该位置。

-   通过 eval()执行的代码属于什么上下文

    -   该调用所在的上下文

-   被执行的代码与该上下文拥有相同的什么？

    -   作用域链

        -   这意味着定义在包含上下文中的变量

            可以在 eval()调用内部被引用

```
let msg = "hello world";
eval("console.log(msg)"); // "hello world"
```

-   在 eval()内部定义的一个函数或变量，

    在外部代码中是否可以引用？

    -   是

```
eval("function sayHi() {
	console.log('hi');
}");
sayHi();
```

```
eval("let msg = 'hello world';");
console.log(msg); // Reference Error: msg is not defined
```

-   通过 eval()定义的任何变量和函数是否会被提升？

    -   不会

        -   因为在解析代码时

            它们是在被包含在一个字符串中的

            它们只是在 eval（）执行的时候才会被创建

-   在严格模式下，在 eval（）内部创建的变量和函数

    是否能被外部访问？

    -   不能

-   在严格模式下，赋值给 eval 是否会报错？

    -   是

```
"use strict";
eval = "hi";//导致错误
```

-   为什么 eval（）方法非常危险？
    -   因为这个方法会对 XSS 利用暴露出很大的攻击面
    -   恶意用户可能插入会导致你网站或应用崩溃的代码

#### 03. Global 对象属性

#### 04. window 对象

-   虽然 ECMA-262 没有规定直接访问 Global 对象的方式，
    -   但浏览器将 window 对象实现为 Global 对象的代理
-   所有全局作用域中声明的变量和函数都变成了谁的属性。？
    -   window 对象

```
var color = "red";
function sayColor() {
	console.log(window.color);
}
window.sayColor(); // "red
```

-   window 对象在 JavaScript 中是否只实现了 ECMAScript 的

    Global 对象？

    -   不是

-   另一种获取 Global 对象的方式？

```
let global = function() {
	return this;
}();
```

-   当一个函数没有明确指定 this 的情况下，this 值等于什么？
    -   Global 对象
-   在任何执行上下文中获取 Global 对象的通用方式是什么？
    -   调用一个简单返回 this 的函数

### 5.4.2 Math

-   Math 对象提供了什么？
    -   一些辅助计算的属性和方法
-   为什么说 Math 对象上提供的计算要比直接在 JS 实现的快得多？
    -   因为 Math 对象上的计算使用了 JS 引擎中更高效的实现和处理器指令

#### 01. Math 对象属性

-   Math 对象属性主要用于什么？
    -   保存在数学中的一些特殊值

#### 02. min() 和 max()方法

-   min() 和 max()方法用于什么？
-   确定一组数值中的最小值和最大值
-   这两个 方法都接收多少个参数？
    -   任意多个参数

```
let max = Math.max(3, 54, 32, 16);
console.log(max); // 54
let min = Math.min(3, 54, 32, 16);
console.log(min); // 3
```

-   如何知道数组中的最大值和最小值？
    -   使用扩展操作符

```
let values = [1, 2, 3, 4, 5, 6, 7, 8];
let max = Math.max(...val)
```

#### 03. 舍入方法

-   用于把小数值舍入为整数的哪 4 个方 法

    -   Math.ceil()

        -   始终向上舍入为最接近的整数

    -   Math.floor()、

        -   始终向下舍入为最接近的整数。

    -   Math.round()

        -   Math.round()方法执行四舍五入

    -   Math.fround()。

        -   Math.fround()方法返回

            数值最接近的单精度（32 位）浮点值表示。

```
console.log(Math.ceil(25.9)); // 26 console.log(Math.ceil(25.5)); // 26 console.log(Math.ceil(25.1)); // 26 console.log(Math.round(25.9)); // 26 console.log(Math.round(25.5)); // 26
```

#### 04. random()方法

-   方法返回什么？

    -   返回一个 0 ~ 1 范围内的随机数
        -   包含 0 不包含 1

-   如何使用 Math.random()从一组整数中随机选择一个数？

```
number = Math.floor(Math.random()*total_number_of_chioce + first_possible_value);
```

-   如何从 1 ~ 10 的范围内随机选择一个数？

```
let num = Math.floor(Math.random * 10 + 1);
```

-   如果是为了加密而需要生成随机数（传给生成器的输入需

    要较高的不确定性），那么建议使用什么方法？

    -   window.crypto.getRandomValues()。

#### 05. 其他方法

## 5.5 小结

- JS的对象称为什么值？
  - 引用值
- 几种内置的引用类型可用于什么？
  - 创建特定类型的对象
- Date类型提供关于什么的信息？包括什么？
  - 日期和时间
    - 包括当前日期、时间及相关计算
- RegExp类型是什么？
  - 是ECMAScript支持正则表达式的接口
- RegExp类型提供了什么？
  - 大多数基础和部分高级的正则表达式功能
- 函数实际上是什么类型的实例？
  - Function类型
- 函数是否是对象？
  - 是
- 为什么函数有方法？这些方法有什么用？
  - 因为函数是对象
  - 用于增强其能力
- 原始值包装类型用来做什么？
  - 让原始值可以被当作对象使用
- 有哪几种原始值包装类型？
  - Boolean
  - Number
  - String
- 每种包装类型都映射到什么？
  - 同名的原始类型
- 以读模式访问原始值时，后台会执行什么操作？
  - 实例化一个原始值包装类型的对象
    - 借助这个对象可以操作相应的数据
- 涉及原始值的语句执行完毕后，包装对象会执行什么操作？
  - 会被销毁
- 当代码开始执行时，全局上下文中会存在哪些内置对象？
  - Global
  - Math
- Global对象是否可以直接访问？
  - 不可以
- 浏览器将Global对象视为什么对象？
  - window对象
- 所有全局变量和函数都是谁的属性？
  - Global对象
- Math对象包含什么属性和方法？
  - 包含辅助完成复杂计算的属性和方法
