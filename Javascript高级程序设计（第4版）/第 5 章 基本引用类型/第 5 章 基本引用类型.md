# 第 5 章 基本引用类型

## 本章内容

- 理解对象 

- 基本JavaScript数据类型 

- 原始值与原始值包装类型

------

- 引用值（或者对象）是什么？

  - 某个特定引用类型的实例。

- 在ECMAScript中， 引用类型是什么？

  - 把数据和功能组织到一起的结构

- 为什么引用类型有时候也被称为对象定义？

  - 因为它们描述了自己的对象应有的属性和方法。

-  引用类型跟类是否是一个概念？

  - 不是

- 怎么创建一个新对象？

  - 通过使用new操作符

    后跟一个构造函数（constructor）来创建

- 构造函数是什么？

  - 用来创建新对象的函数

```
let now = new Date();
```

- 上述代码中的构造函数是什么？
  - Date()
- Date()做了什么？
  - 创建一个只有默认属性和方法的简单对象。
- 函数是否是一种引用类型？
  - 是

## 5.1 Date

- Date类型将日期保存为什么？

  - 自协调世界时（UTC，Universal Time 

    Coordinated）时间1970年1月1日零时至今所经过的毫秒数。

- 如何创建日期对象？
  - 使用new操作符来调用Date构造函数

```
let now = new Date();
```

- 在不给Date构造函数传参数的情况下，

  创建的对象将保存什么？

  - 当前日期和时间。

- 如何基于其他日期和时间创建日期对象？

  - 传入其毫秒表示 

    （1970年1月1日零时之后的毫秒数）

- Date.parse()方法接收什么参数？

  - 一个表示日期的字符串

- Date.parse()方法对这个字符串参数执行什么操作？ 

  - 将其转换为表示该日期的毫秒数

- Date.parse()方法必须支持哪些日期格式？

  - “月/日/年”
    - 如"5/23/2019"； 

  - “月 日, 年”
    - 如"May 23, 2019" 

  - “周 月 日 年 时:分:秒 时区”
    - 如"Tue May 23 2019 00:00:00GMT-0700"； 

  - “YYYY-MM-DDTHH:mm:ss.sssZ”，

    - 如2019-05-23T00:00:00

      （只适用于兼容ES5的实现）。 

- 如何创建一个表示“2019年5月23日”的日期对象？

```
let someDate = new Date(Date.parse("May 23, 2019"));
```

- 如果传给Date.parse()的字符串并不表示日期，

  则该方法会返回什么？

  - NaN

- 如果直接把表示日期的字符串传给Date构造函数，

  那么Date会执行什么操作？

  - 隐式调用Date.parse()
  - 下面这行代码跟前面那行代码是等价的
    - 这两行代码得到的日期对象相同。

```
let someDate = new Date("May 23, 2019");
```

- 不同的浏览器对Date类型的实现是否一致？
  - 不一致
    - 很多浏览器会选择用当前日期替代越界的日期，
    - 有些浏览器会将"January 32, 2019"解释为"February 1, 2019"
- Date.UTC () 方法返回什么？
  - 日期的毫秒表示
- 传给 Date.UTC () 方法的参数是什么？
  - 年
  - 月（1月是0，2月是1，以此类推）
  - 日（1~31）
  - 时（0~23）
  - 分
  - 秒
  - 毫秒
-  Date.UTC () 方法的参数中，哪些是必需的？
  - 只有前两个（年和月）
-  Date.UTC () 方法的日参数默认是什么？
  - 1日
-  Date.UTC () 方法的时、分、秒、毫秒参数的默认值是什么？
  - 都是 0

- Date.UTC () 方法的例子？

```
// GMT时间2000年1月1日零点 
let y2k = new Date(Date.UTC(2000, 0)); 
// GMT时间2005年5月5日下午5点55分55秒 
let allFives = new Date(Date.UTC(2005, 4, 5, 17, 55, 55));
```

- Date.UTC() 是否会被Date构造函数隐式调用？
  - 是
- 被Date隐式调用情况下，创建的是什么日期？
  - 本地日期
    - 不是GMT日期
- Date构造函数跟 Date.UTC() 接收的参数是否是一样的？
  - 是
- 前面的例子也可以这样来写： 

```
// 本地时间2000年1月1日零点 
let y2k = new Date(2000, 0);
// 本地时间2005年5月5日下午5点55分55秒 
let allFives = new Date(2005, 4, 5, 17, 55, 55);
```

- Date.now() 方法返回什么？
  - 表示方法执行时日期和时间的毫秒数。
- Date.now() 方法可以方便地用在哪里？
  - 代码分析中

```
// 起始时间 
let start = Date.now(); 
// 调用函数 
doSomething(); 
// 结束时间 
let stop = Date.now(), 
result = stop - start;
```

### 5.1.1 继承的方法

- Date类型重写了哪些方法？

  - toLocaleString()
  - toString()
  - valueOf()

- 重写后这些方法有什么不一样？

  - 返回值不一样

- Date类型的toLocaleString()方法返回什么？

  - 返回与浏览器运行的本地环境一致的日期和时间。

- toLocaleString()方法格式中有什么特点？

  - 包含针对时间的AM（上午）或 PM（下午）
    - 但不包含时区信息

- toString()方法通常返回什么？

  - 带时区信息的日期和时间

- toString()方法时间也是12小时还是24小时制？

  - 24 小时制

- 现代浏览器在toLocaleString()和toString()的输出有什么区别？

  - 没有区别

- Date类型的valueOf()方法返回什么？

  - 日期的毫秒表示

- 操作符（如小于号和大于号）是否可以直接 

  使用valueOf()方法返回的值？

  - 可以

```
let date1 = new Date(2019, 0, 1); // 2019年1月1日
let date2 = new Date(2019, 1, 1); // 2019年2月1日 console.log(date1 < date2); // true console.log(date1 > date2); // false
```

- 什么是确保日期先后的一个简单方式？
  - 用操作符（如小于号和大于号）直接比较日期对象

### 5.1.2 日期格式化方法

- Date类型有哪几个专门用于格式化日期的方法？

  - toDateString()
    - 显示日期中的周、月、日、年

  - toTimeString()
    - 显示日期中的时、分、秒、时区

  - toLocaleDateString()
    - 显示日期中的周、月、日、年

  - toLocaleTimeString()
    - 显示日期中的时、分、秒

  - toUTCString()
    - 显示完整的UTC日期

- 为什么这些方法不能用于在用户界面上一致地显示日期？

  - 因为这些方法的输出会因浏览器而异

- toGMTString()跟toUTCString() 有什么关系？

  - 是一样的

- toGMTString()目的是什么？
  - 为了向后兼容。
- 规范建议新代码使用 toUTCString() 还是 toGMTString()？
  - 使用 toUTCString()

### 5.1.3 日期/时间组件方法

## 5.2 RegExp

- ECMAScript通过什么类型支持正则表达式？
  - RegExp
- 如何创建正则表达式？

```
let expression = /pattern/flags;
```

- 这个正则表达式的pattern（模式）可以是什么？

  - 任何正则表达式
    - 包括字符类、限定符、分组、向前查找和反向引用

- 每个正则表达式可以带什么，用于控制正则表达式的行为？

  - 零个或多个flags（标记）

- 匹配模式的标记有哪些？

  - g：全局模式
    - 表示查找字符串的全部内容，
      - 而不是找到第一个匹配的内容就结束。 

  - i：不区分大小写
    - 表示忽略pattern和字符串的大小写。

  - m：多行模式
    - 表示查找到一行文本末尾时会继续查找。 

  - y：粘附模式
    - 表示只查找从lastIndex开始及之后的字符串。 

  - u：Unicode模式
    - 表示启用Unicode匹配 

  - s：dotAll模式
    - 表示元字符 . 匹配任何字符（包括\n或\r）

```
// 匹配字符串中的所有"at" 
let pattern1 = /at/g; 
// 匹配第一个"bat"或"cat"，忽略大小写 
let pattern2 = /[bc]at/i; 
// 匹配所有以"at"结尾的三字符组合，忽略大小写 
let pattern3 = /.at/gi;
```

-  所有元字符在pattern中也必须做什么？
  - 转义

```
( [ { \ ^ $ | ) ] } ? * + .
```

- 如果要匹配元字符本身，就必须做什么？
  - 使用反斜杠来转义。

```
// 匹配第一个"bat"或"cat"，忽略大小写 
let pattern1 = /[bc]at/i; 
// 匹配第一个"[bc]at"，忽略大小写 
let pattern2 = /\[bc\]at/i; 
// 匹配所有以"at"结尾的三字符组合，忽略大小写 
let pattern3 = /.at/gi; 
// 匹配所有".at"，忽略大小写 
let pattern4 = /\.at/gi;
```

- 正则表达式还可以怎么创建？
  - 使用RegExp构造函数创建
- RegExp构造函数接收哪两个参数？
  - 模式字符串
  - 标记字符串（可选的）

```
// 匹配第一个"bat"或"cat"，忽略大小写 
let pattern1 = /[bc]at/i; 
// 跟pattern1一样，只不过是用构造函数创建的 
let pattern2 = new RegExp("[bc]at", "i");
```

- 为什么RegExp构造函数的模式参数

  在某些情况下需要二次转义？

  - 因为RegExp的模式参数是字符串

- 所有元字符都必须做什么？

  - 二次转义

    - 包括转义字符序列

      - （ \ 转义后的字符串是 \\\，

        在正则表达式字符串中则要写成 \\\\\\\ ）。

- 使用RegExp是否可以基于已有的正则表达式实例？
  - 可以
- RegExp是否可选择性地修改标记？
  - 可以

```
const re1 = /cat/g; 
console.log(re1); // "/cat/g" 
const re2 = new RegExp(re1); 
console.log(re2); // "/cat/g" 
const re3 = new RegExp(re1, "i"); 
console.log(re3); // "/cat/i"
```

### 5.2.1 RegExp 实例属性

- 每个RegExp实例都有哪些属性？

  - global：布尔值，
    - 表示是否设置了 g 标记。 

  - ignoreCase：布尔值，
    - 表示是否设置了 i 标记。 

  - unicode：布尔值，
    - 表示是否设置了 u 标记。 

  - sticky：布尔值，
    - 表示是否设置了 y 标记。 

  - lastIndex：整数，
    - 表示在源字符串中下一次搜索的开始位置，
      - 始终从 0 开始。 

  - multiline：布尔值，
    - 表示是否设置了 m 标记。 

  - dotAll：布尔值，
    - 表示是否设置了 s 标记。 

  - source：正则表达式的字面量字符串
    - （没有前后斜杠）

  - flags：正则表达式的标记字符串。
    - （没有前后斜杠）

```
let pattern1 = /\[bc\]at/i; console.log(pattern1.global); // false console.log(pattern1.ignoreCase); // true
console.log(pattern1.multiline); // false console.log(pattern1.lastIndex); // 0 console.log(pattern1.source); // "\[bc\]at" console.log(pattern1.flags); // "i" 
let pattern2 = new RegExp("\\[bc\\]at", "i"); console.log(pattern2.global); // false console.log(pattern2.ignoreCase); // true console.log(pattern2.multiline); // false console.log(pattern2.lastIndex); // 0 console.log(pattern2.source); // "\[bc\]at" console.log(pattern2.flags); // "i"
```

- source和 flags属性返回的是什么？
  - 规范化之后可以在字面量中使用的形式

### 5.2.2 RegExp 实例方法

- RegExp实例的主要方法是什么？

  - exec()

- exec() 方法接收哪个参数？

  - 要应用模式的字符串。

- exec() 方法如果找到了匹配项，则返回什么？

  - 包含第一个匹配信息的数组

- exec() 方法如果没找到匹配项，则返回什么？

  - null。

- exec() 方法返回的数组包含哪两个额外的属性？

  - index 
    - 字符串中匹配模式的起始位置

  - input
    - 要查找的字符串。

- exec() 方法返回的数组第一个元素是什么？

  - 匹配整个模式的字符串

- exec() 方法返回的数组其他元素是什么？

  - 与表达式中的捕获组匹配的字符串。

- 如果模式中没有捕获组，exec() 方法返回的数组包含什么？

  - 只包含第一个元素。

```
let text = "mom and dad and baby"; 
let pattern = /mom( and dad( and baby)?)?/gi; 
let matches = pattern.exec(text); console.log(matches.index); // 0 console.log(matches.input); // "mom and dad and baby" 
console.log(matches[0]); // "mom and dad and baby" console.log(matches[1]); // " and dad and baby" console.log(matches[2]); // " and baby"
```

- 模式包含哪两个捕获组？

  - 最内部的匹配项" and baby"， 

  - 外部的匹配项" and dad"或" and dad and baby"。

- 为什么matchs数组的index属性就是0？

  - 因为整个字符串匹配模式

- 数组的第一个元素是什么？

  - 匹配的整个字符串，

- 数组的第二、三个元素是什么？ 

  - 匹配第一个捕获组的字符串
  - 匹配第二个捕获组的字符串 

- 如果没有设置全局标记，则无论对同一个字符串调用多少 

  次exec()，都会返回什么？

  - 第一个匹配的信息。

```
let text = "cat, bat, sat, fat"; 
let pattern = /.at/; 
let matches = pattern.exec(text); console.log(matches.index); // 0 console.log(matches[0]); // cat console.log(pattern.lastIndex); // 0 
matches = pattern.exec(text); console.log(matches.index); // 0 console.log(matches[0]); // cat console.log(pattern.lastIndex); // 0
```

- 如果在这个模式上设置了g标记，

  则每次调用exec()都会执行什么操作？

  - 在字符串中向前搜索下一个匹配项，

```
let text = "cat, bat, sat, fat"; 
let pattern = /.at/g; 
let matches = pattern.exec(text); console.log(matches.index); // 0 console.log(matches[0]); // cat console.log(pattern.lastIndex); // 3 

matches = pattern.exec(text); console.log(matches.index); // 5 console.log(matches[0]); // bat console.log(pattern.lastIndex); // 8 

matches = pattern.exec(text); console.log(matches.index); // 10 console.log(matches[0]); // sat console.log(pattern.lastIndex); // 13
```

- 如果模式设置了粘附标记y，

  则每次调用exec()会执行什么操作？

  - 就只会在lastIndex的位置上寻找匹配项。
  - 粘附标记覆盖全局标记。 

```
let text = "cat, bat, sat, fat"; 
let pattern = /.at/y;
let matches = pattern.exec(text); console.log(matches.index); // 0 console.log(matches[0]); // cat console.log(pattern.lastIndex); // 3 

// 以索引3对应的字符开头找不到匹配项，因此exec()返回null 
// exec()没找到匹配项，于是将lastIndex设置为0 
matches = pattern.exec(text); 
console.log(matches); // null console.log(pattern.lastIndex); // 0

// 向前设置lastIndex可以让粘附的模式通过exec()找到下一个匹配项： 
pattern.lastIndex = 5; 
matches = pattern.exec(text); console.log(matches.index); // 5 console.log(matches[0]); // bat console.log(pattern.lastIndex); // 8
```

- 正则表达式的另一个方法是test()，接收什么参数？
  - 一个字符串参数
- 如果test()传入的字符串参数与模式匹配，则返回什么？
  - 则返回true，
  - 否则返回false

### 5.2.3 RegExp 构造函数属性

- RegExp构造函数本身也有几个属性。
-  RegExp 构造函数属性适用于什么正则表达式？
  - 作用域中的所有正则表达式
- RegExp 构造函数属性会根据什么而变化？
  - 最后执行的正则表达式操作
- RegExp 构造函数属性可以通过哪两种不同的方式访问？
  - 全名
  - 简写

- 下表列出了RegExp构造函数的属性

| 全名         | 简写 | 说明                                   |
| ------------ | ---- | -------------------------------------- |
| input        | $_   | 最后搜索的字符串（非标准特性）         |
| lastMatch    | $&   | 最后匹配的文本                         |
| lastParen    | $+   | 最后匹配的捕获组（非标准特性）         |
| leftContext  | $`   | input字符串中出现在lastMatch前面的文本 |
| rightContext | $'   | input字符串中出现在lastMatch后面的文本 |

- 通过RegExp 构造函数属性可以提取出什么信息？
  - 与exec()和test()执行的操作相关的信息

```
let text = "this has been a short summer";
let pattern = /(.)hort/g;

if (pattern.test(text)) {
    console.log(RegExp.input); // this has been a short summer 
    console.log(RegExp.leftContext); // this has been a 
    console.log(RegExp.rightContext); // summer 
    console.log(RegExp.lastMatch); // short 
    console.log(RegExp.lastParen); // s
}
```

- RegExp 构造函数属性名的简写形式为什么要使用中括号语法来访问？
  - 因为大多数简写形式都不是合法的ECMAScript标识符

```
let text = "this has been a short summer";
let pattern = /(.)hort/g; /** 注意：Opera 不支持简写属性名 * IE 不支持多行匹配 */
if (pattern.test(text)) {
    console.log(RegExp.$_); // this has been a short summer 
    console.log(RegExp["$`"]); // this has been a 
    console.log(RegExp["$'"]); // summer 
    console.log(RegExp["$&"]); // short 
    console.log(RegExp["$+"]); // s
}
```

- 可以存储最多几个捕获组的匹配项？
  - 9
- 通过什么来访问捕获组的匹配项？
  - RegExp.$1~RegExp.$9
    - 分别包含第1~9个捕获组的匹配项。

```
let text = "this has been a short summer";
let pattern = /(..)or(.)/g;
if (pattern.test(text)) {
    console.log(RegExp.$1); // sh 
    console.log(RegExp.$2); // t
}
```

- 为什么不要在生产环境中使用RegExp构造函数？

  - 因为RegExp构造函数的所有属性

    都没有任何Web标准出处

### 5.2.4 模式局限

- 哪些特性目前还没有得到ECMAScript的支持？

  - \A和\Z锚（分别匹配字符串的开始和末尾） 

  - 联合及交叉类 

  - 原子组 

  - x（忽略空格）匹配模式 

  - 条件式匹配 

  - 正则表达式注释 

## 5.3 原始值包装类型

- 为了方便操作原始值，

  ECMAScript提供了哪3种特殊的引用类型？

  - Boolean
  - Number
  - String

- 每当用到某个原始值的方法或属性时，后台执行什么操作？

  - 会创建一个相应原始包装类型的对象， 
    - 从而暴露出操作原始值的各种方法

```
let s1 = "some text"; 
let s2 = s1.substring(2);
```

- 当第二行访问s1时，是以什么模式访问的？

  - 读模式
    - 要从内存中读取变量保存的值。

- 在以读模式访问字符串值的时候，后台都会执行什么操作？

  - (1) 创建一个String类型的实例； 
  - (2) 调用实例上的特定方法； 

  - (3) 销毁实例

```
let s1 = new String("some text"); 
let s2 = s1.substring(2); 
s1 = null;
```

- 这种行为可以让原始值发生什么变化？
  - 拥有对象的行为
- 引用类型与原始值包装类型的主要区别是什么？
  - 对象的生命周期不同
    - 在通过new实例化得到的实例，
      - 会在离开作用域时被销毁，
    - 自动创建的原始值包装对象
      - 只存在于访问它的那行代码执行期间
- 是否能在运行时给原始值添加属性和方法?
  - 不能

```
let s1 = "some text"; 
s1.color = "red"; 
console.log(s1.color); // undefined
```

- 第二行代码运行时会执行什么操作？

  - 临时创建一个String对象，

- 第三行代码执行时，这个临时对象是否存在？

  - 已经被销毁了

- 第三行代码执行了什么操作？

  - 创建了自己的String对象
    - 但这个对象没有color属性。 

- 在原始值包装类型的实例上调用typeof会返回什么？

  - "object"

- 所有原始值包装对象都会转换为什么布尔值？

  - true

- Object构造函数作为一个工厂方法，

  能够根据传入值的类型返回什么？

  - 相应原始值包装类型的实例
    - 如果是字符串
      - 则会创建String的实例。
    - 如果是数值
      - 则会创建Number的实例。
    - 如果是布尔值
      - 则会创建Boolean的实例。 

```
let obj = new Object("some text"); 
console.log(obj instanceof String); // true
```

- 使用new调用原始值包装类型的构造函数，

  与调用同名的转型函数是否一样

  - 不一样

```
let value = "25"; 
let number = Number(value); // 转型函数 console.log(typeof number); // "number" 
let obj = new Number(value); // 构造函数 console.log(typeof obj); // "object"
```

### 5.3.1 Boolean

- 如何创建一个Boolean对象？
  - 使用Boolean构造函数
  - 并传入true或false

```
let booleanObject = new Boolean(true);
```

- Boolean的实例重写的 valueOf() 方法返回什么？
  - 一个原始值 true 或 false 。
- Boolean的实例重写的 toString() 方法返回什么？
  - 字符串 "true" 或 "false"

```
let falseObject = new Boolean(false); 
let result = falseObject && true; console.log(result); // true 
let falseValue = false; 
result = falseValue && true; 
console.log(result); // false
```

- 所有对象在布尔表达式中都会自动转换成什么？

  - true

- 原始值和引用值（Boolean对象）有什么区别？

  - typeof操作符
    - 对原始值返回"boolean"，
    - 对引用值返回"object"。 

  - instaceof操作符 Boolean
    - 对原始值返回false
    - 对引用值返回true

- 建议永远不要使用原始值还是引用值（Boolean对象） ？

  - 引用值（Boolean对象）

### 5.3.2 Number

### 5.3.3 String

## 5.4 单例内置对象

### 5.4.1 Global

### 5.4.2 Math

## 5.5 小结