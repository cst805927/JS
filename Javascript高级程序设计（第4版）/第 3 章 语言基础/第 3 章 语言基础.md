

# 第 3 章 语言基础

## 本章内容

- 语法
- 数据类型
- 流控制语句
- 理解函数

## 3.1 语法

### 3.1.1 区分大小写

- ECMAScript 一切都区分大小写

### 3.1.2 标识符

- 标识符是什么？
  - 是变量、函数、属性、函数参数的名字
- 组成标识符的字符有哪些规定？
  - 第一个字符必须是字母、下划线（_）、美元符号（$）
  - 剩下的字符可以是字母、下划线（_）、美元符号（$）、数字

- 标识符的最佳实践是什么？

  - 驼峰大小写形式

    - 第一个单词的首字母小写

      后面每个单词的首字母大写

- 哪些字符不能作为标识符？
  - 关键字
  - 保留字
  - true、false
  - null

### 3.1.3 注释

- ECMAScript注释有哪几种？

  - 单行注释

    ```
    // 单行注释
    ```

  - 块注释

    ```
    /* 这是多行
    注释 */
    ```

### 3.1.4 严格模式

- 严格模式是什么？
  - 是一种 JS 解析和执行模型

- 严格模式的特点是什么？

  - 处理 ECMAScript 3 的一些不规范的写法
  - 对于不安全的活动将抛出错误

- 如何开启严格模式？

  - 在脚本开头加上一行“use strict”

- 选择严格模式的目的是什么？

  - 不破坏 ECMAScript 3 的语法

- 如何单独指定一个函数在严格模式下执行

  - ```
    function doSomeThing () {
    	"use strict";
    	// 函数体
    }
    ```

- 所有现代浏览器都支持严格模式吗？
  - 是的

### 3.1.5 语句

- ECMAScript 中的语句是以什么结尾的？

  - 分号

- 省略分号意味着什么？

  - 意味着由解析器确定语句在哪里结尾

- 加分号由什么好处？

  - 防止省略造成的问题
    - （如避免输入内容不完整）

  - 便于开发者删除空行来压缩代码

    - （如果没有分号，只删除空行，会导致语法错误）

  - 在某些情况下提升性能

    - 因为解析器会尝试

      在合适的位置补上分号

      以纠正语法错误

- 代码块由什么组成？

  - 由一个左花括号（{）开始，

    一个右花括号（}）标识结束

- 控制语句的最佳实践是什么？

  - 始终使用代码块

    即使要执行的只有一条语句

- 使用代码块有什么好处？
  - 让内容更清晰
  - 在修改代码时减少出错的可能性

## 3.2 关键字与保留字

- ECMA-262 保留的关键字有哪些？

  - ```
    break		do			in				typeof
    case		else		instanceof		var
    catch		export		new				void
    class		extends		return			while
    const		finally		super			with
    continue	for			switch			yield
    debugger	function	this
    default		if			throw
    delete		import		try
    ```

- 关键字能否用作标识符或属性名？
  - 不能

- ECMA-262 未来的保留字有哪些？

  - ```
    始终保留：
    enum
    严格模式下保留：
    implements	package		public
    interface	protected	static
    let			private
    模板代码中保留：
    await
    ```

## 3.3 变量

- ECMAScript 变量是什么类型的？
  - 松散类型
    - 变量可以用来保存任何类型的数据
- 变量的是用来做什么的？
  - 用来保存任意值的命名占位符
- 有什么关键字可以声明变量，每个关键字在什么版本中可以使用？
  - var 
    - 所有版本
  - const
    - ES 6 及更晚的版本
  - let
    - ES 6 及更晚的版本

### 3.3.1 var 关键字

- 如何使用 var 操作符定义变量？

  - ```
    var message;
    ```

- 不初始化的情况下，变量会保存什么值？
  - 特殊值 undefined

- 可以同时定义变量并设置它的值吗？

  - 可以

  - ```
    var message = "hi"
    ```

- 可以改变值的类型吗？

  - 可以，但不推荐

  - ```
    var message = "hi"
    message = 100
    ```

#### 1. var 声明作用域

- var 的关键问题是什么？

  - 使用 var 操作符定义的变量

    会成为包含它的函数的局部变量

    - 意味着变量会在函数退出时被销毁

  - ```
    function test() {
    	var messaage = "hi"; // 局部变量
    }
    test();
    console.log(message); // 出错
    ```

- 如何创建一个全局变量？

  - 定义变量时省略 var 操作符

    ```
    function test() {
    	message = "hi"; // 全局变量
    }
    test();
    console.log(message);
    ```

- 为什么不推荐通过省略 var 操作符定义全局变量？

  - 在局部作用域定义的全局变量很难维护

  - 造成困惑

    - 因为不能马上断定

      省略 var 操作符是不是有意为之

  - 在严格模式下

    如果给未声明的变量赋值

    会抛出 ReferenceError 错误

- 如何定义多个变量？

  - 在一条语句用逗号分割每个变量

    ```
    var message = "hi",
    	found = false,
    	age = 29;
    ```

- 在严格模式下，不能定义名字是什么的变量，否则会导致语法错误？
  - eval
  - arguments

#### 2. var 声明提升

- 下面的代码是否会报错？

  ```
  function foo() {
  	console.log(age);
  	var age = 26;
  }
  foo(); // undefined
  ```

  - 不会报错

    - 因为用 var 声明的变量

      会自动提升到函数作用域顶部

- 提升是什么意思？

  - 把所有变量声明

    都拉到函数作用域的顶部

- 能否多次使用 var 声明同一个变量？

  - 能

    ```
    function foo() {
    	var age = 16;
    	var age = 26;
    	var age = 36;
    	console.log(age);
    }
    foo() // 36
    ```

### 3.3.2 let 声明

- let 和 var 的重要区别是什么？

  - let 声明的变量不会在作用域中被提升

  - 声明的范围不同

    - let 声明的范围是块作用域
    - var 声明的范围是函数作用域

    ```
    if (true) {
    	var name = 'Matt';
    	console.log(name); // Matt
    }
    console.log(name); // Matt
    ```

    ```
    if (true) {
    	let age = 26;
    	console.log(age); // 26
    }
    console.log(age); // ReferenceError: age 没有定义
    ```

    - age 的作用域仅限于该块内部

- 块作用域和函数作用域的关系？
  - 块作用域是函数作用域的子集

- 适用于 var 作用域限制是否适用于 let ？
  - 是
  - 因为块作用域是函数作用域的子集

- let 是否允许同一个块作用域中出现冗余声明？

  - 不允许

    ```
    var name;
    var name;
    ```

    ```
    let age;
    let age; // SyntaxError：标识符age已经声明过了
    ```

- 嵌套使用相同的标识符是否会报错？

  - 不会

    - 因为同一个块中没有重复声明

    ```
    var name = 'Nicholas';
    console.log(name); // 'Nicholas'
    if (true) {
    	var name = 'Matt';
    	console.log(name); // 'Matt'
    }
    ```

    ```
    let age = 10;
    console.log(age); // 10
    if (true) {
    	let age = 26;
    	console.log(age) // 26
    }
    ```

- let 和 var 声明的是什么？

  - 指出变量在相关作用域如何存在

  ```
  var name;
  let name; // SyntaxError
  ```

  ```
  let age;
  var age; // SyntaxError
  ```

#### 1.  暂时性死区

- let 和 var 的重要区别是什么？

  - 声明的范围不同

    - let 声明的范围是块作用域
    - var 声明的范围是函数作用域

  - let 声明的变量不会在作用域中被提升

    ```
    // name会被提升
    console.log(name); // undefined
    var name = 'Matt';
    ```

    ```
    // age不会被提升
    console.log(age); // ReferenceError:age没有定义
    let age = 26;
    ```

- 什么是“暂时性死区”？
  - 在 let 声明之前的执行瞬间
- 在“暂时性死区”阶段引用任何后面才声明的变量会发生什么？
  - 抛出 ReferenceError

#### 2. 全局声明

- var 和 let 有什么区别？

  - 声明的范围不同

    - let 块作用域
    - var 函数作用域

  - 提升

    - let 不会提升
    - var 会提升

  - 全局作用域中声明的变量是否会成为 window 对象的属性

    - let 不会

    - var 会

    ```
    var name = 'Matt';
    console.log(window.name); // 'Matt'
    ```

    ```
    let age = 26;
    console.log(window.age); // undefined
    ```

#### 3. 条件声明

- 使用 var 冗余声明时，JS 引擎会怎么做？

  - 会将多余的声明在作用域顶部

    合并为一个声明

    - 因为声明会被提升

- let 会不会检查前面是否声明过同名变量？

  - 不会
    - 因为 let 的作用域是块

- let 有没有可能在没有声明的情况下声明变量

  - 不可能
  - 因为 let 的作用域是块

  ```
      <script>
        var name = "Nicholas";
        let age = 26;
      </script>
      <script>
        // 脚本不确定页面是否已经声明了同名变量
        // 那脚本可以假设还没有声明过
  
        // 这里没问题，因为可以被作为提升声明来处理
        // 不需要检查之前是否声明过同名变量
        var name = "Matt";
  
        // 如果age之前声明过，这里会报错
        let age = 36; // SyntaxError: Identifier 'age' has already been declared
      </script>
  ```

  - 用 try/catch 语句或 typeof 操作符也不能解决

    ```
        <script>
          var name = "Nicholas";
          let age = 36;
        </script>
        <script>
          // 脚本不确定页面是否已经声明了同名变量
          // 那脚本可以假设还没有声明过
    
          // name被限制在if{}块的作用域内
          if (typeof name === "undefined") {
            let name;
          }
          // 因此这个赋值是全局赋值
          name = "Matt";
    
          try {
            // 如果age没有声明过，这里会报错
            console.log(age); // 36
          } catch (error) {
            let age;
          }
          // age被限制在catch()块的作用域内
          // 因此这个赋值是全局赋值
          age = 26;
        </script>
    ```

- let 是否可以依赖条件声明模式？
  - 不可以
- 条件声明模式的缺点是什么？
  - 让程序更难理解

#### 4. for 循环中的 let 声明

- 在 let 出现之前，for 循环定义的迭代变量会有什么问题？

  - 会渗透到循环体外部

    ```
    for (var i = 0; i < 5; i++) {
    	// 循环逻辑
    }
    console.log(i); // 5
    ```

- 改用 let 后，迭代变量渗透到外部的问题是否还存在？

  - 不存在

    - 因为迭代变量的作用域

      仅限于 for 循环块内部

      ```
      for (let i = 0; i < 5; i++) {
      	// 循环逻辑
      }
      console.log(i); // ReferenceError: i没有定义
      ```

- 在使用 var 时，对迭代变量最常见的问题是什么？

  - 对迭代变量的奇特声明和修改

    ```
    for (var i = 0; i < 5; i++) {
    	setTimeOut(() => console.log(i), 0)
    }
    // 输出 5，5，5，5，5
    ```

  - 退出循环时，迭代变量保存的是什么？
    - 保存的是导致循环退出的值：5
      - 执行超时逻辑时，所有的 i 都是同一个变量 5

- 在使用 let 声明迭代变量时，JS 引擎会做什么？

  - JS 引擎会为每个迭代循环

    声明一个新的迭代变量

    - 此时每个setTimeout 引用的都是不同的变量

      ```
      for (let i = 0; i < 5; i++) {
      	setTimeout(() => console.log(i), 0)
      }
      // 输出 0，1，2，3，4
      ```

- let 每次迭代声明一个独立变量的行为

  是否适用于所有风格的 for 循环？

  - 是
    - 包括 for-in 和 for-of

### 3.3.3 const 声明

- const 和 let 的重要区别是什么？

  - const 声明变量时必须初始化变量

    且不能修改

    ```
    const age = 25;
    age = 36; // TypeError: 给常量赋值
    ```

    ```
    // const也不允许重复声明
    const name = 'Matt';
    const name = 'Nicholas'; // SyntaxError
    ```

    ```
    // const 声明的作用域也是块
    const name = 'Matt';
    if (true) {
    	const name = 'Nicholas';
    }
    console.log(name); // Matt
    ```

- 如果 const 变量引用的是一个对象，是否可以修改这个对象内部的属性？

  - 可以

    - 因为 const 声明的限制只适用于

      它指向的变量的引用

    ```
    const person = {};
    person.name = 'Matt'; // ok
    ```

- 能否用 const 来声明迭代变量？

  - 不能

    - 因为迭代变量会自增

    ```
    for (const i = 0; i < 10; i++) {} // TypeError:给常量赋值
    ```

- 每次迭代用 const 只创建一个新变量，适用于什么循环？

  - for-in ：遍历 key

  - for-of ：遍历 value

    ```
    for (const key in {a: 1, b: 2}) {
    	console.log(key);
    }
    // a, b
    
    for (const value of [1, 2, 3, 4, 5]) {
    	cosole.log(value);
    }
    // 1, 2, 3, 4, 5
    ```

### 3.3.4 声明风格及最佳实践

#### 1. 不使用 var

- 只使用 let 和 const 的好处是什么？
  - 提升代码质量
    - 因为变量有了明确的作用域、声明位置、以及不变的值

#### 2. const 优先，let 次之

- 使用 const 声明变量的好处有哪些？
  - 可以让浏览器运行时强制保持变量不变
  - 也可以让静态代码分析工具提前发现不合法的赋值操作

- 什么时候使用 let ？
  - 提前知道未来会有修改时，再使用 let

## 3.4 数据类型

- ECMAScript 的简单数据类型有哪几种？
  - 6 种简单数据类型（原始类型）
  - Undefined
  - Null
  - Boolean
  - Number
  - String
  - Symbol（ES6 新增）

- 有一种复杂数据类型叫什么？
  - Object（对象）
- Object 是什么？
  - Object是一种无序名值对的集合

- 在 ECMAScript 中能否定义自己的数据类型？
  - 不能

### 3.4.1 typeof 操作符

- 如何确定变量的数据类型？

  - 用 typeof 操作符

- 对一个值用 typeof 操作符会返回什么？

  - “undefined” 未定义
  - “boolean” 布尔值
  - “string” 字符串
  - “number” 数值
  - “object” 对象或null
  - “function” 函数
  - “symbol” 符号

- 使用 typeof 操作符的例子

  ```
  let message = "some string";
  console.log(typeof message); // "string"
  console.log(typeof(message)); // "string"
  console.log(typeof 95); // "number"
  ```

- typeof 是什么？

  - typeof 是一个操作符

    而不是函数

    所以不需要参数（但可以使用参数）

- 为什么调用 typeof null 返回的是 “object” ？
  - 因为特殊值 null 被认为是一个空对象的引用

- 为什么要通过 typeof 操作符区分函数和其他对象？

  - 因为函数也有自己特殊的属性

  - 严格来讲，

    函数在 ECMAScript 中被认为是对象，

    并不代表一种数据类型

### 3.4.2 undefined 类型

- undefined类型有几个值？

  - 只有一个值

    特殊值 undefined

- 什么情况下相当于给变量赋值为undefined值？

  - 当使用 var 或 let 声明了变量

    但没有初始化时

    ```
    let message;
    console.log(message === undefined); // true
    ```

- 为什么永远不要显式地给某个变量设置 undefined？

  - 因为字面量 undefined 主要用于比较
  - 而且在 ES 3 之前不存在

- 增加特殊值 undefined 的目的是什么？

  - 为了明确

    空对象（null）和

    未初始化变量的区别

- 包含 undefined 值的变量跟未定义变量有什么区别？

  - ```
    let message; // 这个变量被声明了，只是值为undefined
    // 确保没有声明过这个变量
    // let age;
    console.log(message); // "undefined"
    console.log(age); // 报错
    ```

- 对未声明的变量，只能执行的哪个有用的操作？

  - 对它调用 typeof

  - 对它调用 delete 也不会报错，

    但这个操作没用

    严格模式下会报错

- 对未初始化的变量调用 typeof，返回的结果是什么？

  - “undefined”

- 对未声明的变量调用 typeof，返回的结果是什么？

  - “undefined”

- 为什么建议在声明变量的同时进行初始化？

  - 因为这样做之后

    当 typeof 返回 “undefined” 时

    就一定有变量未声明

    而不是声明了未初始化

- undefined 是一个真值还是假值？

  - 假值

    ```
    let message; // 这个变量被声明了，只是值为 undefined
    // age 没有声明
    if (message) {
    	// 这个块不会执行
    }
    if (!message) {
    	// 这个块会执行
    }
    if (age) {
    	// 这里会报错
    }
    ```

### 3.4.3 Null 类型

- Null 类型有哪些值？

  - 只有一个值

    即特殊值 null

- 逻辑上讲，null值表示什么意思？

  - 表示一个空对象指针

  - 这也是 typeof null 返回 “object” 的原因

    ```
    let car = null;
    console.log(typeof car); // "object"
    ```

- 在定义将来要保存对象值的变量时，建议使用什么初始化

  - 使用 null 来初始化，不要使用其他值

- 为什么要用 null 来初始化？

  - 因为只要检查这个变量的值是不是 null

    就知道这个变量是否在后来

    被重新赋予了一个对象的引用

    ```
    if (car !== null) {
    	// car是一个对象的引用
    }
    ```

- 为什么 ECMA-262 将 undefined 和 null 定义为表面相等？

  - 因为 undefined 值是由 null 值派生而来的

    ```
    console.log(null == undefined); // true
    ```

    

