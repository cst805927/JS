

# 第 3 章 语言基础

## 本章内容

- 语法
- 数据类型
- 流控制语句
- 理解函数

## 3.1 语法

### 3.1.1 区分大小写

- ECMAScript 一切都区分大小写

### 3.1.2 标识符

- 标识符是什么？
  - 是变量、函数、属性、函数参数的名字
- 组成标识符的字符有哪些规定？
  - 第一个字符必须是字母、下划线（_）、美元符号（$）
  - 剩下的字符可以是字母、下划线（_）、美元符号（$）、数字

- 标识符的最佳实践是什么？

  - 驼峰大小写形式

    - 第一个单词的首字母小写

      后面每个单词的首字母大写

- 哪些字符不能作为标识符？
  - 关键字
  - 保留字
  - true、false
  - null

### 3.1.3 注释

- ECMAScript注释有哪几种？

  - 单行注释

    ```
    // 单行注释
    ```

  - 块注释

    ```
    /* 这是多行
    注释 */
    ```

### 3.1.4 严格模式

- 严格模式是什么？
  - 是一种 JS 解析和执行模型

- 严格模式的特点是什么？

  - 处理 ECMAScript 3 的一些不规范的写法
  - 对于不安全的活动将抛出错误

- 如何开启严格模式？

  - 在脚本开头加上一行“use strict”

- 选择严格模式的目的是什么？

  - 不破坏 ECMAScript 3 的语法

- 如何单独指定一个函数在严格模式下执行

  - ```
    function doSomeThing () {
    	"use strict";
    	// 函数体
    }
    ```

- 所有现代浏览器都支持严格模式吗？
  - 是的

### 3.1.5 语句

- ECMAScript 中的语句是以什么结尾的？

  - 分号

- 省略分号意味着什么？

  - 意味着由解析器确定语句在哪里结尾

- 加分号由什么好处？

  - 防止省略造成的问题
    - （如避免输入内容不完整）

  - 便于开发者删除空行来压缩代码

    - （如果没有分号，只删除空行，会导致语法错误）

  - 在某些情况下提升性能

    - 因为解析器会尝试

      在合适的位置补上分号

      以纠正语法错误

- 代码块由什么组成？

  - 由一个左花括号（{）开始，

    一个右花括号（}）标识结束

- 控制语句的最佳实践是什么？

  - 始终使用代码块

    - 即使要执行的只有一条语句

- 使用代码块有什么好处？
  - 让内容更清晰
  - 在修改代码时减少出错的可能性

## 3.2 关键字与保留字

- ECMA-262 保留的关键字有哪些？

  - ```
    break		do			in				typeof
    case		else		instanceof		var
    catch		export		new				void
    class		extends		return			while
    const		finally		super			with
    continue	for			switch			yield
    debugger	function	this
    default		if			throw
    delete		import		try
    ```

- 关键字能否用作标识符或属性名？
  - 不能

- ECMA-262 未来的保留字有哪些？

  - ```
    始终保留：
    enum
    严格模式下保留：
    implements	package		public
    interface	protected	static
    let			private
    模板代码中保留：
    await
    ```

## 3.3 变量

- ECMAScript 变量是什么类型的？
  - 松散类型
    - 变量可以用来保存任何类型的数据
- 变量的是用来做什么的？
  - 用来保存任意值的命名占位符
- 有什么关键字可以声明变量，每个关键字在哪些版本中可以使用？
  - var 
    - 所有版本
  - const
    - ES 6 及更晚的版本
  - let
    - ES 6 及更晚的版本

### 3.3.1 var 关键字

- 如何使用 var 操作符定义变量？

  - ```
    var message;
    ```

- 不初始化的情况下，变量会保存什么值？
  - 特殊值 undefined

- 可以同时定义变量并设置它的值吗？

  - 可以

  - ```
    var message = "hi"
    ```

- 可以改变值的数据类型吗？

  - 可以，但不推荐

  - ```
    var message = "hi"
    message = 100
    ```

#### 1. var 声明作用域

- var 的关键问题是什么？

  - 使用 var 操作符定义的变量

    会成为

    包含它的函数的局部变量

    - 意味着变量会在函数退出时被销毁

  - ```
    function test() {
    	var messaage = "hi"; // 局部变量
    }
    test();
    console.log(message); // 出错
    ```

- 如何创建一个全局变量？

  - 省略 var 操作符

    ```
    function test() {
    	message = "hi"; // 全局变量
    }
    test();
    console.log(message);
    ```

- 为什么不推荐通过省略 var 操作符定义全局变量？

  - 很难维护

    - 在局部作用域定义的全局变量很难维护

  - 造成困惑

    - 不能马上断定

      省略 var 操作符是不是有意为之

  - 在严格模式下，会抛出 ReferenceError 错误

    - 如果给未声明的变量赋值

- 如何定义多个变量？

  - 在一条语句用逗号分割每个变量

    ```
    var message = "hi",
    	found = false,
    	age = 29;
    ```

- 在严格模式下，不能定义名字是什么的变量，否则会导致语法错误？
  - eval
  - arguments

#### 2. var 声明提升

- 下面的代码是否会报错？

  ```
  function foo() {
  	console.log(age);
  	var age = 26;
  }
  foo(); // undefined
  ```

  - 不会报错

    - 因为用 var 声明的变量

      会提升到函数作用域顶部

- 提升是什么意思？

  - 把所有变量声明

    都拉到函数作用域的顶部

- 能不能多次使用 var 声明同一个变量？

  - 能

    ```
    function foo() {
    	var age = 16;
    	var age = 26;
    	var age = 36;
    	console.log(age);
    }
    foo() // 36
    ```

### 3.3.2 let 声明

- let 和 var 的重要区别有哪些？

  - 全局作用域中声明的变量是否会成为 window 对象的属性

    - let 不会

    - var 会

  - 提升

    - let 不会提升
    - var 会提升

  - 声明的范围不同

    - let 块作用域
    - var 函数作用域

    ```
    if (true) {
    	var name = 'Matt';
    	console.log(name); // Matt
    }
    console.log(name); // Matt
    ```

    ```
    if (true) {
    	let age = 26;
    	console.log(age); // 26
    }
    console.log(age); // ReferenceError: age 没有定义
    ```

    - 因为 age 的作用域仅限于该块内部

- 块作用域和函数作用域的关系？
  - 块作用域是函数作用域的子集

- 适用于 var 作用域的限制是否适用于 let ？
  - 是
    - 因为块作用域是函数作用域的子集

- let 是否允许同一个块作用域中出现冗余声明？

  - 不允许

    ```
    var name;
    var name;
    ```

    ```
    let age;
    let age; // SyntaxError：标识符age已经声明过了
    ```

- 嵌套使用相同的标识符是否会报错？

  - 不会

    - 因为同一个块中没有重复声明

    ```
    var name = 'Nicholas';
    console.log(name); // 'Nicholas'
    if (true) {
    	var name = 'Matt';
    	console.log(name); // 'Matt'
    }
    ```

    ```
    let age = 10;
    console.log(age); // 10
    if (true) {
    	let age = 26;
    	console.log(age) // 26
    }
    ```

- let 和 var 声明的是什么？

  - 指出变量在相关作用域如何存在

  ```
  var name;
  let name; // SyntaxError
  ```

  ```
  let age;
  var age; // SyntaxError
  ```

#### 1.  暂时性死区

- let 和 var 的重要区别有哪些？

  - 声明的范围不同

    - let 块作用域
    - var 函数作用域

  - 提升

    - let 不会提升
    - var 会提升

    ```
    // name会被提升
    console.log(name); // undefined
    var name = 'Matt';
    ```

    ```
    // age不会被提升
    console.log(age); // ReferenceError:age没有定义
    let age = 26;
    ```

  - 全局作用域中声明的变量是否会成为 window 对象的属性

    - let 不会

    - var 会

- 什么是“暂时性死区”？

  - 在 let 声明之前的执行瞬间

- 在“暂时性死区”阶段引用任何后面才声明的变量会发生什么？
  - 抛出 ReferenceError

#### 2. 全局声明

- var 和 let 有什么区别？

  - 声明的范围不同

    - let 块作用域
    - var 函数作用域

  - 提升

    - let 不会提升
    - var 会提升

  - 全局作用域中声明的变量是否会成为 window 对象的属性

    - let 不会

    - var 会

    ```
    var name = 'Matt';
    console.log(window.name); // 'Matt'
    ```

    ```
    let age = 26;
    console.log(window.age); // undefined
    ```

#### 3. 条件声明

- 使用 var 冗余声明时，JS 引擎会怎么做？

  - 在作用域顶部

    将冗余声明

    合并为一个声明
    
    - 因为声明会被提升

- let 会不会检查前面是否声明过同名变量？

  - 不会
    - 因为 let 的作用域是块

- let 有没有可能在没有声明的情况下声明变量

  - 不可能
    - 因为 let 的作用域是块


  ```
      <script>
        var name = "Nicholas";
        let age = 26;
      </script>
      <script>
        // 脚本不确定页面是否已经声明了同名变量
        // 那脚本可以假设还没有声明过
  
        // 这里没问题，因为可以被作为提升声明来处理
        // 不需要检查之前是否声明过同名变量
        var name = "Matt";
  
        // 如果age之前声明过，这里会报错
        let age = 36; // SyntaxError: Identifier 'age' has already been declared
      </script>
  ```

  - 用 try/catch 语句或 typeof 操作符也不能解决

    ```
        <script>
          var name = "Nicholas";
          let age = 36;
        </script>
        <script>
          // 脚本不确定页面是否已经声明了同名变量
          // 那脚本可以假设还没有声明过
    
          // name被限制在if{}块的作用域内
          if (typeof name === "undefined") {
            let name;
          }
          // 因此这个赋值是全局赋值
          name = "Matt";
    
          try {
            // 如果age没有声明过，这里会报错
            console.log(age); // 36
          } catch (error) {
            let age;
          }
          // age被限制在catch()块的作用域内
          // 因此这个赋值是全局赋值
          age = 26;
        </script>
    ```

- let 是否可以依赖条件声明模式？
  - 不可以
    - 因为 let 的作用域是块
  
- 条件声明模式的缺点是什么？
  - 让程序更难理解

#### 4. for 循环中的 let 声明

- 用 var 定义for 循环的迭代变量会有什么问题？

  - 迭代变量会渗透到循环体外部

    ```
    for (var i = 0; i < 5; i++) {
    	// 循环逻辑
    }
    console.log(i); // 5
    ```

- 改用 let 后，迭代变量渗透到外部的问题是否还存在？

  - 不存在

    - 因为迭代变量的作用域

      仅限于 for 循环块内部

      ```
      for (let i = 0; i < 5; i++) {
      	// 循环逻辑
      }
      console.log(i); // ReferenceError: i没有定义
      ```

- 在使用 var 时，对迭代变量最常见的问题是什么？

  - 对迭代变量的奇特声明和修改

    ```
    for (var i = 0; i < 5; i++) {
    	setTimeout(() => console.log(i), 0)
    }
    // 输出 5，5，5，5，5
    ```

- 退出循环时，使用 var 定义的迭代变量保存的是什么？
  - 保存的是导致循环退出的值：5
    - 退出循环之后
    
      执行 setTimeout 时，
    
      所有的 i 都是同一个变量 5

- 在使用 let 声明迭代变量时，JS 引擎会做什么？

  - JS 引擎会为每个迭代循环

    声明一个新的迭代变量

    - 此时每个setTimeout 引用的都是不同的变量

      ```
      for (let i = 0; i < 5; i++) {
      	setTimeout(() => console.log(i), 0)
      }
      // 输出 0，1，2，3，4
      ```

- let 每次迭代声明一个独立变量的行为

  是否适用于所有风格的 for 循环？

  - 是
    - 包括 for-in 和 for-of

### 3.3.3 const 声明

- const 和 let 的重要区别是什么？

  - const 声明变量时

    必须初始化变量

    且不能修改
    
    ```
    const age = 25;
    age = 36; // TypeError: 给常量赋值
    ```
    

- const 和 let 有哪些共同点？

  - 不允许重复声明

    ```
    const name = 'Matt';
    const name = 'Nicholas'; // SyntaxError
    ```

  - 声明的作用域是块

    ```
    const name = 'Matt';
    if (true) {
    	const name = 'Nicholas';
    }
    console.log(name); // Matt
    ```

- 如果 const 变量引用的是一个对象，是否可以修改这个对象内部的属性？

  - 可以

    - 因为 const 声明的限制

      只适用于
      
      它指向的变量的引用
    
    ```
    const person = {};
    person.name = 'Matt'; // ok
    ```

- 能否用 const 来声明迭代变量？

  - 不能

    - 因为迭代变量会自增

    ```
    for (const i = 0; i < 10; i++) {} // TypeError:给常量赋值
    ```

- 每次迭代用 const 只创建一个新变量，适用于什么循环？

  - for-in ：遍历 key

  - for-of ：遍历 value

    ```
    for (const key in {a: 1, b: 2}) {
    	console.log(key);
    }
    // a, b
    
    for (const value of [1, 2, 3, 4, 5]) {
    	cosole.log(value);
    }
    // 1, 2, 3, 4, 5
    ```

### 3.3.4 声明风格及最佳实践

#### 1. 不使用 var

- 只使用 let 和 const 的好处是什么？
  - 提升代码质量
    - 因为变量有了
      - 明确的作用域、
      - 声明位置、
      - 不变的值

#### 2. const 优先，let 次之

- 使用 const 声明变量的好处有哪些？
  - 让浏览器运行时
  
    强制保持变量不变
  
  - 让静态代码分析工具
  
    提前发现不合法的赋值操作
  
- 什么时候使用 let ？
  - 提前知道未来会有修改时，再使用 let

## 3.4 数据类型

- ECMAScript 的简单数据类型有哪几种？
  - 6 种简单数据类型（原始类型）
  - Undefined
  - Null
  - Boolean
  - Number
  - String
  - Symbol（ES6 新增）

- 有一种复杂数据类型叫什么？
  - Object（对象）
- Object 是什么？
  - Object是一种无序名值对的集合

- 在 ECMAScript 中能否定义自己的数据类型？
  - 不能

### 3.4.1 typeof 操作符

- 如何确定变量的数据类型？

  - 用 typeof 操作符

- 对一个值用 typeof 操作符会返回什么？

  - “undefined” 未定义
  - “boolean” 布尔值
  - “string” 字符串
  - “number” 数值
  - “object” 对象或null
  - “function” 函数
  - “symbol” 符号

- 使用 typeof 操作符的例子

  ```
  let message = "some string";
  console.log(typeof message); // "string"
  console.log(typeof(message)); // "string"
  console.log(typeof 95); // "number"
  ```

- typeof 是什么？

  - typeof 是一个操作符

    而不是函数

    所以不需要参数
    
    （但可以使用参数）

- 为什么调用 typeof null 返回的是 “object” ？
  - 因为特殊值 null 被认为是一个空对象的引用

- 为什么要通过 typeof 操作符区分函数和其他对象？

  - 因为函数也有自己特殊的属性

    - 但严格来讲，

      函数被认为是对象，

      并不代表一种数据类型
  

### 3.4.2 undefined 类型

- undefined类型有几个值？

  - 只有一个值

    特殊值 undefined

- 什么情况下相当于给变量赋值为undefined值？

  - 当使用 var 或 let 声明了变量

    但没有初始化时

    ```
    let message;
    console.log(message === undefined); // true
    ```

- 为什么不要显式地给某个变量设置 undefined？

  - 因为字面量 undefined 主要用于比较
  - 而且在 ES 3 之前不存在

- 增加特殊值 undefined 的目的是什么？

  - 为了明确

    空对象（null）和

    未初始化变量的区别

- 包含 undefined 值的变量与未定义变量有什么区别？

  - ```
    let message; 
    console.log(message); // "undefined"
    console.log(age); // 报错：age未定义
    ```
  
- 对未声明的变量，只能执行的哪个有用的操作？

  - 对它调用 typeof

    - 对它调用 delete 也不会报错，

      但这个操作没用

      严格模式下会报错

- 对未初始化的变量调用 typeof，返回的结果是什么？

  - “undefined”

- 对未声明的变量调用 typeof，返回的结果是什么？

  - “undefined”

- 为什么建议在声明变量的同时进行初始化？

  - 因为这样做之后

    当 typeof 返回 “undefined” 时

    就一定有变量未声明

    而不是声明了未初始化

- undefined 是一个真值还是假值？

  - 假值

    ```
    let message; // 这个变量被声明了，只是值为 undefined
    // age 没有声明
    if (message) {
    	// 这个块不会执行
    }
    if (!message) {
    	// 这个块会执行
    }
    if (age) {
    	// 这里会报错
    }
    ```

### 3.4.3 Null 类型

- Null 类型有哪些值？

  - 只有一个值

    即特殊值 null

- 逻辑上讲，null值表示什么意思？

  - 表示一个空对象指针

    - 这也是 typeof null 返回 “object” 的原因


    ```
    let car = null;
    console.log(typeof car); // "object"
    ```

- 在定义将来要保存对象值的变量时，建议使用什么初始化

  - 使用 null 来初始化，不要使用其他值

- 为什么要用 null 来初始化？

  - 因为只要检查这个变量的值是不是 null

    就知道这个变量

    是否在后来

    被重新赋予了一个对象的引用
    
    ```
    if (car !== null) {
    	// car是一个对象的引用
    }
    ```

- 为什么 ECMA-262 将 undefined 和 null 定义为表面相等？

  - 因为 undefined 值是由 null 值派生而来的

    ```
    console.log(null == undefined); // true
    ```

    - == 操作符会转换操作数的数据类型

- null 和 undefined 的区别？

  - undefined：不要显式地将变量值设置为 undefined
  - null ：只要变量保存对象，就可以用 null 来填充该变量

- null 是一个真值还是假值？

  - 假值

    ```
    let message = null;
    if (message) {
    	// 这个块不会执行
    }
    if (!message) {
    	// 这个块会执行
    }
    ```

### 3.4.4 Boolean 类型

- Boolean 类型有哪几个字面量？

  - 有两个字面量
    - true
    - false

- true 是否等于 1，false 是否等于 0 ？

  - 这两个布尔值不同于数值

    - true 不等于 1

    - false 不等于 0

      ```
      let found = true;
      let lost = false;
      ```

- 布尔值字面量 true 和 false 是否区分大小写？

  - 是

    - 因此 True 和 False（及其它大小混写形式）

      是有效的标识符

      但不是布尔值

- 如何将一个其他类型的值转换为布尔值？

  - 调用 Boolean() 转型函数

    ```
    let message = "Hello World!";
    let messageAsBoolean = Boolean(message);
    ```

    | 数据类型  | 转换为 true 的值       | 转换为 false 的值 |
    | --------- | ---------------------- | ----------------- |
    | Boolean   | true                   | false             |
    | String    | 非空字符串             | “”（空字符串）    |
    | Number    | 非零数值（包括无穷值） | 0，NaN            |
    | Object    | 任意对象               | null              |
    | Undefined |                        | undefined         |

- 像 if 等流控制语句会自动执行什么？

  - 其它类型到布尔值的转换

    ```
    let message = "Hello World!";
    if (message) {
    	console.log("Value is true");
    }
    ```

### 3.4.5 Number 类型

- Number 类型使用什么格式表示整数和浮点数？

  - IEEE 754 格式

- 如何创建八进制字面量？

  - 第一个数字必须是零（0）
  - 然后是相应的八进制数字（0 ~ 7）

- 如果八进制字面量中包含的数字超出了应有的范围，会发生什么？

  - 会忽略前缀的零

  - 后面的数字序列会被当成十进制数

    ```
    let octalNum1 = 070; // 八进制的56
    let octalNum2 = 079; // 无效的八进制，当成79处理
    let octalNum3 = 08; // 无效的八进制，当成8处理
    ```

- 八进制字面量可以在严格模式下使用吗

  - 不能，会导致 JS 引擎抛出语法错误

- 如何创建十六进制字面量？

  - 前缀必须是 0x（区分大小写）
  - 后面是十六进制数字（0 ~ 9 以及 A ~ F）

- 十六进制中的数字有大小写区分吗？

  - 没有，大小写均可

    ```
    let hexNum1 = 0xA; // 十六进制10
    let hexNum2 = 0x1f; // 十六进制31
    ```

- 在数学操作中遇到八进制或十六进制会发生什么？
  - 都被视为十进制数值
- 正零（+0）和负零（-0）等同吗？
  - 在所有情况下都认为是等同的

#### 1. 浮点值

- 如何定义一个浮点值

  - 数值中必须包含小数点

  - 小数点后面必须至少有一个数字

  - 小数点前面不是必须有整数，但推荐加上

    ```
    let floatNum1 = 1.1;
    let floatNum2 = 0.1;
    let floatNum3 = .1; // 有效，但不推荐
    ```

- 为什么 ECMAScript 总是想方设法把浮点值转换为整数值？

  - 因为存储浮点值使用的内存空间

    是存储整数值的两倍

- 在什么情况下，浮点值会变成整数值？
  - 小数点后面没有数字

- 如果数值本身是整数，小数点后面跟着 0，它是否会转换为浮点数？
  - 不会，依然是整数值

```
let floatNum1 = 1.; // 小数点后面没有数字，当成整数1处理
let floatNum2 = 10.0 // 小数点后面是零，当成整数10处理
```

- 浮点值是可以怎么表示非常大或非常小的数值？

  - 用科学计数法

- 科学计数法是用来表示什么数值的？

  - 用来表示一个应该乘以 10 的给定次幂的数值

  ```
  let floatNum = 3.125e7; //等于 31250000
  ```

- 科学计数法的优点？
  - 更简洁

- 默认情况下，ECMAScript 会将什么样的浮点数转换为科学计数法？

  - 小数点后至少 6 个零的浮点值

    （如 0.000 0003 会被转换为 3e-7）

- 浮点值的精确度最高可达到多少？
  - 17位小数
- 浮点值的算术计算有什么问题？
  - 不够准确
    - 例如 0.1 + 0.2 得到的不是 0.3

- 为什么很难测试特定的浮点值？

  - 因为存在微小的舍入错误

    ```
    if (a + b == 0.3) { //别这么做！
    	console.log("You got 0.3.");
    }
    ```

- 为什么会存在舍入错误？
  - 因为使用了 IEEE 754 数值

#### 2. 值的范围

- ECMAScript 能支持表示这个世界上的所有数值吗？

  - 不支持
    - 因为内存的限制

- ECMAScript 可以表示的最小和最大的数值保存在哪里？

  - 最小数值保存在 Number.MIN_VALUE 中

  - 最大数值保存在 Number.MAX_VALUE 中

- 如果某个计算得到的数值结果超出了 JS 可以表示的范围，会发生什么？

  - 这个数值会被自动转换为一个特殊的 Infinity（无穷）值
    - 负数以 -Infinity（负无穷大）表示
    - 正数以 Infinity（正无穷大）表示

- 如果计算返回正 Infinity 或负 Infinity，该值能不能再进一步用于计算？

  - 不能
    - 因为 Infinity 没有可用于计算的数值表示形式

- 如何确定一个值是不是有限大（介于最小值和最大值之间）？

  - 使用 isFinite() 函数

    ```
    let result = Number.MAX_VALUE + Number.MAX_VALUE;
    console.log(isFinite(result)); //false
    ```

- 在计算非常大或非常小的数值时，需要注意什么？
  - 检测一下计算结果是否超出范围

- Number 的哪两个属性可以表示正、负 Infinity？
  - Number.NEGATIVE_INFINITY
  - Number.POSITIVE_INFINITY

#### 3. NaN

- NaN 表示什么意思？

  - 不是数值（Not A Number）

- NaN 用来表示什么？

  - 用来表示本来要返回数值的操作失败了

    （而不是抛出错误）

- 在 ECMAScript 中，0、+0、-0 相除会发生什么？

  - 会返回 NaN

    ```
    console.log(0/0); // NaN
    consolr.log(-0/+0); // NaN
    ```

- 如果分子是非 0 值，分母是有符号 0 或无符号 0，会发生什么？

  - 返回 Infinity 或 -Infinity

    ```
    console.log(5/0); // Infinity
    console.log(5/-0); // -Infinity
    ```

- NaN 有哪几个特点？

  - 任何涉及 NaN 的操作始终返回 NaN（如 NaN/10）

  - NaN 不等于包括 NaN 在内的任何值

    ```
    console.log(NaN == NaN); //false
    ```
  
- 如何判断一个数是否是 NaN？

  - 使用 isNaN() 函数

- isNaN() 函数的原理是什么？

  - 函数会把参数转换为数值

    - 任何不能转换为数值的值

      都会使函数返回 true

    ```
    console.log(isNaN(NaN)); // true
    console.log(isNaN(10)); // false，10是数值
    console.log(isNaN("10")); // false，可以转换为数值10
    console.log(isNaN("blue")); // true，不可以转换为数值
    console.log(isNaN(true)); // false，可以转换为数值1
    ```

- isNaN() 用于测试对象的原理是什么？

  - 首先调用对象的 valueOf（）方法

  - 然后判断返回的值

    是否可以转换为数值

    - 如果不能

      再调用 toString（）方法

      并测试其返回值

#### 4. 数值转换

- 哪些函数可以将非数值转换为数值？
  - Number（） 
  - parseInt（）
  - parseFloat（）

- Number（）可用于什么场景？
  - 用于将任何数据类型转换为数值
    - 是转型函数

- parseInt（）和 parseFloat（）可用于什么场景？
  - 用于将字符串转换为数值

- Number（）函数基于什么规则执行转换？

  - 布尔值

    - true 转换为 1
    - false 转换为 0

  - 数值

    - 直接返回

  - null

    - 返回 0

  - undefined

    - 返回 NaN

  - 字符串

    - 如果字符串包含数值字符（包括数值字符前面加、减号的情况）

      则转换为一个十进制数值

      - Number("1") 返回 1
      - Number("123") 返回 123
      - Number("011") 返回 11（忽略前面的 0 ）

    - 如果字符串包含有效的浮点值格式如“1.1”

      则会返回相应的浮点值（同样忽略前面的 0 ）

    - 如果字符串包含有效的十六进制格式如“0xf”

      则会转换为与该十六进制值对应的十进制整数

    - 如果是空字符串，

      则返回 0

    - 如果字符串包含除上述情况之外的其它字符

      则返回 NaN

  - 对象，

    调用 valueOf（）方法

    并按照上述规则转换返回的值

    - 如果转换的结果是 NaN

      则调用 toString（）方法

      再按照转换字符串的规则转换
  
  ```
  let num1 = Number("Hello World"); // NaN
  let num2 = Number(""); // 0
  let num3 = Number("000011"); // 11
  let num4 = Number(true); // 1
  ```

- 需要整数时，使用什么函数？

  - 使用 parseInt（）函数

    - 因为 parseInt（）更专注于

      字符串是否包含数值模式

- parseInt（）函数的转换规则是什么？

  - 字符串最前面的空格会被忽略

    从第一个非空格字符开始转换

  - 如果第一个字符不是

    数值字符、加号、减号

    返回 NaN

  - 如果是空字符串，返回 NaN

  - 如果第一个字符是数值字符、加号、减号

    则继续依次检测每个字符

    直到字符串末尾

    或碰到非数值字符

    - 如“1234blue”会被转换成 1234

      因为 ”blue“被忽略

    - 如“22.5”会被转换成 22

      因为小数点不是有效的整数字符

- parseInt（）函数能不能识别不同的整数格式（十进制、八进制、十六进制）？

  - 能

- parseInt（）函数识别整数格式的规则是什么？

  - 如果字符串以“0x”开头

    会被解释为十六进制整数

  - 如果字符串以“0”开头，且紧跟数值字符

    在非严格模式下

    会被解释为八进制整数

    ```
    let num1 = parseInt("1234blue"); // 1234
    let num2 = parseInt(""); // NaN
    let num3 = parseInt("0xA"); // 10，解释为十六进制整数
    let num4 = parseInt(22.5); // 22
    let num5 = parseInt("70"); // 70，解释为十进制值
    let num6 = parseInt("0xf"); // 15，解释为十六进制整数
    ```

- parseInt（）函数的第二个参数是用来做什么的？
  - 用来指定底数（进制数）

- 如果知道要解析的值是十六进制，应该怎么用 parseInt（）函数？

  - 传入 16 作为 parseInt（）函数的第二个参数

    ```
    let num = parseInt("0xAF", 16); // 175
    ```

- 如果 parseInt（）函数提供了十六进制参数，字符串前面的“0x”是否可以省略？

  - 可以

    ```
    let num1 = parseInt("AF", 16); // 175
    let num2 = parseInt("AF"); // NaN
    ```

- parseInt（）函数的第二个参数有什么优点？

  - 可以扩展转换后的结果类型

    ```
    let num1 = parseInt("10", 2); // 2，按二进制解析
    let num2 = parseInt("10", 8); // 8，按八进制解析
    let num3 = parseInt("10", 10); // 10, 按十进制解析
    let num4 = parseInt("10", 16); // 16, 按十六进制解析
    ```

- 为什么建议始终要传parseInt（）函数的底数参数？

  - 因为如果不传底数参数

    相当于让 parseInt（）自己决定如何解析

    有解析出错的风险

    - 传底数可以防止解析出错

- parseFloat（）的解析顺序是怎样的？

  - 从位置 0 开始检测每个字符

  - 解析到字符串末尾或者

    解析到一个无效的浮点数值字符为止

- parseFloat（）如何判断字符串中的小数点是否有效？

  - 第一次出现的小数点有效
  - 第二次出现的小数点无效
    - 此时字符串剩余字符会被忽略
    - 因此“22.34.5”会被转换成 22.34

- parseFloat（）的特点是什么？

  - 忽略字符串开头的 0

  - 只解析十进制

    - 因此不能指定底数

  - 十六进制数值始终会返回 0

  - 如果字符串表示整数（没有小数点或者小数点后只有一个零）

    则返回整数

  ```
  let num1 = parseFloat("1234blue"); // 1234, 按整数解析
  let num2 = parseFloat("0xA"); // 0
  let num3 = parseFloat("22.5"); // 22.5
  let num4 = parseFloat("22.34.5"); // 22.34
  let num5 = parseFloat("0908.5"); // 908.5
  let num6 = parseFloat("3.125e7"); // 31250000
  ```

### 3.4.6 String 类型

- String（字符串）数据类型表示什么序列？

  - 表示零或多个 16 位 Unicode 字符序列

- 字符串可以使用什么符号标示？

  - 双引号（“）
  - 单引号（‘）
  - 反引号（`）

  ```
  let firstName = "John";
  let lastName = 'Jacob';
  let lastName = `Jingleheimerschmidt`;
  ```

- ECMAScript 语法中表示字符串的引号有区别吗？

  - 没有区别

- 用某种引号作为字符串开头时，需要注意什么？

  - 必须用该种引号作为字符串结尾

    ```
    let firstName = 'Nicholas"; // 语法错误：开头和结尾的引号必须时同一种
    ```

#### 1. 字符字面量

- 字符串数据类型中的字符字面量是用来做什么的？

  - 用来表示

    - 非打印字符

    - 有其它用途的字符

| 字面量 | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| \n     | 换行                                                         |
| \t     | 制表                                                         |
| \b     | 退格                                                         |
| \r     | 回车                                                         |
| \f     | 换页                                                         |
| \\\    | 反斜杠（ \ ）                                                |
| \\'    | 单引号（ ' ），在字符串以单引号标示时使用，例如 'He said,  \\'hey.\\' ' |
| \\"    | 双引号（ ” ）                                                |
| \\`    | 反引号（ ` ）                                                |
| \xnn   | 以十六进制编码 nn 表示的字符（其中 n 是十六进制数字0~F），例如\x41等于“A” |
| \unnnn | 以十六进制编码 nnnn 表示的 Unicode 字符（其中 n 是十六进制数字0~F） |

- 字符字面量有哪些特点？

  - 可以出现在字符串中的任意位置

  - 只算一个字符

    ```
    let text = "This is the letter sigma: \u03a3.";
    ```

    - 变量 text 仍然是 28 个字符长

- 如何获取字符串的长度？

  - 通过字符串的 length 属性

    ```
    console.log(text.length); // 28
    ```

    - 这个属性返回字符串中 16 位字符的个数

#### 2. 字符串的特点

- 字符串的值一旦创建，还能不能改变？

  - 不能
    - ECMAScript 中的字符串是不可变的

- 如何修改某个变量中的字符串值？

  - 先销毁原始的字符串

  - 然后将包含新值的另一个字符串

    保存到该变量

    - 这是早期的浏览器拼接字符串时非常慢的原因

- 下面的代码执行时，后台发生了什么？

  ```
  let lang = "Java";
  lang = lang + "Script";
  ```

  - 首先分配一个容纳 10 个字符的空间

  - 然后填充上 “Java” 和 “Script”

  - 最后销毁原始的字符串 “Java” 和字符串 “Script”

    因为这两个字符串都没有用了

#### 3. 转换为字符串

- 把一个值转换为一个字符串有哪两种方式？

  - 用 toString（）方法

  - 用加号操作符

    给一个值加上一个空字符串”“

- toString（）方法唯一的用途是什么？

  - 返回当前值的字符串等价物

    ```
    let age = 11;
    let ageAsString = age.toString(); // 字符串“11”
    let found = true;
    let foundAsString = found.toString(); // 字符串“true”
    ```

- toString（）方法可见于哪些值？

  - 数值
  - 布尔值
  - 对象
  - 字符串值

- 哪些值没有 toString（）方法？

  - null
  - undefined

- toString（）方法的参数是用来做什么的？

  - 用来表示以什么底数来输出数值的字符串

  - 默认情况下，toString（）返回数值的十进制字符表示

    ```
    let num = 10;
    console.log(num.toString()); // "10"
    console.log(num.toStting(2)); // "1010"
    console.log(num.toString(8)); // "12"
    console.log(num.toString(10)); // "10"
    console.log(num.toString(16)); // "a"
    ```

- 如何确定一个值是不是 null 或 undefined ？

  - 使用 String（）转型函数

- String（）函数遵循哪些规则？

  - 如果值有 toString（）方法

    则调用该方法（不传参数）

    并返回结果

  - 如果值是 null，返回 “null”

  - 如果值是 undefined，返回“undefined”

    ```
    let value1 = 10;
    let value2 = true;
    let value3 = null;
    let value4;
    console.log(String(value1)); // "10"
    console.log(String(value2)); // "true"
    console.log(String(value3)); // "null"
    console.log(String(value4)); // "undefined"
    ```

#### 4.模板字面量

- 模板字面量的特点？

  - 保留换行字符

  - 可以跨行定义字符

    ```
    let myMultiLineString = 'first line\nsecond line';
    let myMultiLineTemplateLiteral = `first line
    second line`;
    console.log(myMultiLineString);
    // first line
    // second line
    console.log(myMultiLineTemplateLiteral);
    // first line
    // second line
    console.log(myMultiLineString === myMultiLineTemplateLiteral); // true
    ```

- 模板字面量在什么情况下特别有用？

  - 定义模板时

    ```
    let pageHTML = `
    <div>
    	<a href="#">
    		<span>Jake</span>
    	</a>
    </div>`;
    ```

- 使用模板字面量要注意什么？

  - 格式正确的模板字符串

    看起来可能会缩进不当

    - 因为模板字面量会保持反引号内部的空格

    ```
    // 这个模板字面量在换行符之后有25个空格符
    let myTemplateLiteral = `first line
    						 second line`;
    console.log(myTemplateLiteral.length); // 47
    
    // 这个模板字面量以一个换行符开头
    let secondTemplateLiteral = `
    first line
    second line`;
    console.log(secondTemplateLiteral[0] === '\n'); // true
    
    // 这个模板字面量没有意料之外的字符
    let thirdTemplateLiteral = `first line
    second line`;
    console.log(thirdTemplateLiteral);
    //first line
    //second line
    ```

#### 5. 字符串插值

- 字符串插值是什么意思？

  - 可以在一个连续定义中

    插入一个或多个值

- 从技术上讲，模板字面量是什么？

  - 是一种特殊的 JS 句法表达式

    求值后得到字符串

- 模板字面量的原理是什么？

  - 立即求值

    并转换为字符串实例

- 任何插入的变量从哪里取值？
  - 从最接近的作用域中取值

- 如何实现字符串插值？

  - 通过在 ${}中使用一个 JS 表达式实现

    ```
    let value = 5;
    let exponent = 'second';
    // 以前，字符串插值是这样实现的
    let interpolatedString =
        value + ' to the ' + exponent + ' power is ' + (value * value);
    // 现在，可以用模板字面量这样实现：
    let interpolatedTemplateLiteral =
        `${value} to the ${exponent} power is ${value * value}`;
    console.log(interpolatedString); // 5 to the second power is 25
    console.log(interpolatedTemplateLiteral); // 5 to the second power is 25
    ```

- 字符串插值有哪些特点？

  - 所有插入的值都使用 toString（）强制转型为字符串

    ```
    let foo = {toString: () => 'World'};
    console.log(`Hello, ${foo}!`); // Hello World!
    ```

  - 任何 JS 表达式都可以用于插值

  - 嵌套的模板字符串无须转义

  ```
  console.log(`Hello, ${`World`}!`); // Hello, World!
  ```

  - 模板可以插入自己之前的值

  ```
  let value = '';
  function append() {
  	value = `${value}abc`;
  	console.log(value);
  }
  append(); // abc
  append(); // abcabc
  append(); // abcabcabc
  ```

#### 6. 模板字面量标签函数

- 标签函数可以用来干什么？
  - 用来自定义插值行为
- 标签函数接收到的参数依次是什么？
  - 原始字符串数组
  - 每个表达式求值的结果

- 标签函数的返回值是什么？

  - 对模板字面量求值

    得到的字符串

- 标签函数的例子

  ```
  let a = 6;
  let b = 9;
  
  function simpleTag(strings, aValExpression, bValExpression, sumExpression) {
      console.log(strings);
      console.log(aValExpression);
      console.log(bValExpression);
      console.log(sumExpression);
      return 'foobar';
  }
  let untaggedResult = `${a} + ${b} = ${a + b}`;
  let taggedResult = simpleTag `${a} + ${b} = ${a + b}`;
  // ["", " + ", " = ", ""]
  // 6
  // 9
  // 15
  console.log(untaggedResult); // "6 + 9 = 15"
  console.log(taggedResult); // "foobar"
  ```

- 表达式参数的数量是可变的，如何将参数收集到一个数组中？

  - 使用剩余操作符（...）

  ```
  let a = 6;
  let b = 9;
  
  function simpleTag(strings, ...expressions) {
      console.log(strings);
      for (const expression of expressions) {
          console.log(expression);
      }
      return 'foobar';
  }
  let untaggedResult = `${a} + ${b} = ${a + b}`;
  let taggedResult = simpleTag `${a} + ${b} = ${a + b}`;
  // ["", " + ", " = ", ""]
  // 6
  // 9
  // 15
  console.log(untaggedResult); // "6 + 9 = 15"
  console.log(taggedResult); // "foobar"
  ```

- 对于有 n 个插值的模板字面量，

  传给标签函数的表达式参数个数是多少？

  传给标签函数第一个参数所包含的字符串个数是多少？

  - 表达式参数个数是 n
  - 第一个参数所包含的字符串个数是 n + 1

- 如何把原始字符串和

  对表达式求值的结果

  拼接起来

  作为默认返回的字符串？

  ```
  let a = 6;
  let b = 9;
  
  function zipTag(strings, ...expressions) {
      return strings[0] +
          expressions.map((e, i) => `${e}${strings[i + 1]}`)
          .join('');
  }
  let untaggedResult = `${a} + ${b} = ${a + b}`;
  let taggedResult = zipTag `${a} + ${b} = ${a + b}`;
  console.log(untaggedResult); // 6 + 9 = 15
  console.log(taggedResult); // 6 + 9 = 15
  ```

#### 7. 原始字符串

- 如何使用模板字面量

  直接获取原始的模板字面量内容（如换行符或Unicode字符）

  而不是转换后的字符？

  - 使用默认的 String.raw 标签函数

    ```
    // Unicode示例
    // \u00A9 是版权符号
    console.log(`\u00A9`); // ©
    console.log(String.raw `\u00A9`); // \u00A9
    
    // 换行符示例
    // first line
    // second line
    console.log(`first line\nsecond line`);
    
    // "first line\nsecond line"
    console.log(String.raw `first line\nsecond line`);
    
    // 对实际的换行符是不行的
    // 它们不会被转换成转义序列的形式
    console.log(`first line
    second line`);
    // first line
    // second line
    
    console.log(String.raw `first line
    second line`);
    // first line
    // second line
    ```
  
  - 也可以通过标签函数的第一个参数
  
    即字符串数组的 .raw 属性
  
    取得每个字符串的原始内容
  
  ```
  function printRaw(strings) {
      console.log('Actual characters:');
      for (const string of strings) {
          console.log(string);
      }
      console.log('Escaped characters:');
      for (const rawString of strings.raw) {
          console.log(rawString);
      }
  }
  printRaw `\u00A9${'and'}\n`;
  // Actual characters:
  // ©
  // (换行符)
  // Escaped characters:
  // \u00A9
  // \n
  ```

### 3.4.7 Symbol 类型

- 符号（Symbol）的特点是什么？

  - 符号是原始值
  - 符号实例唯一，不可变

- 创建符号的目的是什么？

  - 确保对象属性使用唯一标识符

    不会发生属性冲突的危险

- 符号是用来做什么的？

  - 用来创建唯一记号

    用作非字符串形式的对象属性

#### 1. 符号的基本用法

- 如何初始化一个符号？

  - 使用 Symbol（）函数初始化

- typeof 操作符对符号返回什么？

  - symbol

    - 因为符号本身是原始类型

    ```
    let sym = Symbol();
    console.log(typeof sym); // symbol
    ```

- Symbol（）函数的参数是什么数据类型，用来做什么的？

  - 字符串

  - 用来作为对符号的描述

    将来通过这个字符串来调试代码

- Symbol（）的参数与符号定义或标识有关吗？

  - 完全无关

    ```
    let genericSymbol = Symbol();
    let otherGenericSymbol = Synbol();
    let fooSymbol = Symbol('foo');
    let otherFooSymbol = Symbol('foo');
    console.log(genericSymbol == otherFooSymbol); // false
    console.log(fooSymbol == otherFooSymbol); // false
    ```

- 符号是否有字面量语法？

  - 没有
    - 这是符号发挥作用的关键

- 如何保证创建的属性

  不会覆盖已有的对象属性

  （无论是符号属性还是字符串属性）？

  - 创建 Symbol（）实例

    并将其用作对象的新属性

    ```
    let genericSymbol = Symbol();
    console.log(genericSymbol); // Symbol()
    let fooSymbol = Symbol('foo');
    console.log(fooSymbol); // Symbol(foo)
    ```

- 为什么Symbol（）函数不能与 new 关键字一起作为构造函数使用？

  - 为了避免创建符号包装对象

- 什么类型支持构造函数

  且可用于初始化包含原始值的包装对象？

  - Boolean

  - String

  - Number

    ```
    let myBoolean = new Boolean();
    console.log(typeof myBoolean); // "object"
    
    let myString = new String();
    console.log(typeof myString); // "object"
    
    let myNumber = new Number();
    console.log(typeof myNumber); // "object"
    
    let mySymbol = new Symbol(); // TypeError: Symbol is not a constructor
    ```

- 如何使用符号包装对象？

  - 使用 Object（）函数

  ```
  let mySymbol = Symbol();
  let myWrappedSymbol = Object(mySymbol);
  console.log(typeof myWrappedSymbol); // "object"
  ```

#### 2. 使用全局符号注册表

- 如何实现在运行时的不同部分

  共享和重用符号实例？

  - 使用 Symbol.for（）方法

    - 用一个字符串作为键

    - 在全局符号注册表中创建

      并重用符号

  ```
  let fooGlobalSymbol = Symbol.for('foo');
  console.log(typeof fooGlobalSymbol); // symbol
  ```

- Symbol.for（）方法的原理是什么？
  - 对每个字符串键都执行幂等操作

- 第一次使用某个字符串调用时，Symbol.for（）方法会做什么？

  - 会检查全局运行时注册表
  - 发现不存在对应的符号
    - 于是生成一个新符号实例
    - 并把该符号实例添加到注册表中

  ```
  let fooGlobalSymbol = Symbol.for('foo'); // 创建新符号
  let otherFooGlobalSymbol = Symbol.for('foo'); // 重用已有符号
  console.log(fooGlobalSymbol === otherFooGlobalSymbol); // true
  ```

- 如果采用相同的符号描述，

  在全局注册表中定义的符号跟

  使用 Symbol（）定义的符号就相同吗？

  - 不相同

  ```
  let localSymbol = Symbol('foo');
  let globalSymbol = Symbol.for('foo');
  console.log(localSymbol === globalSymbol); // false
  ```

- 为什么作为参数传给 Symbol.for() 的任何值

  都会被转换为字符串？

  - 因为创建全局注册表中的符号

    必须使用字符串键来创建

- 注册表中使用的键同时也会被用作什么？

  - 符号描述

  ```
  let emptyGlobalSymbol = Symbol.for();
  console.log(emptyGlobalSymbol); // Symbol(undefined)
  ```

- 如何查询全局注册表？

  - 使用 Symbol.keyFor（）

- Symbol.keyFor() 返回什么？

  - 返回该全局符号对应的字符串键
  - 如果查询的不是全局符号
    - 则返回 undefined

  ```
  // 创建全局符号
  let s = Symbol.for('foo');
  console.log(Symbol.keyFor(s)); // foo
  // 创建普通符号
  let s2 = Symbol('bar');
  console.log(Symbol.keyFor(s2)); // undefined
  ```

  - 如果传给 Symbol.keyFor() 的不是符号，

    则该方法抛出 TypeError

    ```
    Symbol.keyFor(123); // TypeError: 123 is not a symbol
    ```

#### 3. 使用符号作为属性

- 哪些地方可以使用符号？

  - 凡是可以使用字符串或数值

    作为属性的地方

    - 包括了对象字面量属性和 

      Object.defineProperty()/

      Object.defineProperties() 定义的属性

- 对象字面量只能在什么情况中使用符号作为属性？

  - 在计算属性语法中

    ```
    let s1 = Symbol('foo'),
        s2 = Symbol('bar'),
        s3 = Symbol('baz'),
        s4 = Symbol('qux');
    let o = {
        [s1]: 'foo val'
    };
    // 这样也可以： o[s1] = 'foo val'
    console.log(o);
    //Symbol(foo): foo val
    
    Object.definedProperty(o, s2, {
        value: 'bar val'
    });
    console.log(o);
    // {Symbol(foo): foo val, Symbol(bar): bar val}
    Object.defineProperties(o, {
        [s3]: {
            value: 'baz val'
        },
        [s4]: {
            value: 'qux val'
        }
    });
    console.log(o);
    // {Symbol(foo): foo val, Symbol(bar): bar val,
    // Symbol(baz): baz val, Symbol(qux): qux val}
    ```

- Object.getOwnPropertyNames() 返回什么？

  - 返回对象实例的常规属性数组

- Object.getOwnPropertySymbols() 返回什么？

  - 返回对象实例的符号属性数组

- Object.getOwnPropertyNames() 和 

  Object.getOwnPropertySymbols() 的返回值之间有什么关系？

  - 两个方法的返回值彼此互斥

- Object.getOwnPropertyDescriptors() 会返回什么？

  - 会返回同时包含

    常规属性和

    符号属性描述符

    的对象

- Reflect.ownKeys() 会返回哪两种类型的键？

  - 常规类型
  - 符号类型

- ```
  let s1 = Symbol('foo'),
      s2 = Symbol('bar');
  
  let o = {
      [s1]: 'foo val',
      [s2]: 'bar val',
      baz: 'baz val',
      qux: 'qux val'
  };
  // [Symbol(foo), Symbol(bar)]
  console.log(Object.getOwnPropertySymbols(o));
  
  // ["baz", "qux"]
  console.log(Object.getOwnPropertyNames(o));
  
  // {baz: {...}, qux: {...}, Symbol(foo): {...}, Symbol(bar): {...}}
  console.log(Object.getOwnPropertyDescriptors(o));
  
  // ["baz", "qux", Symbol(foo), Symbol(qux)]
  console.log(Reflect.ownKeys(o));
  ```

- 为什么直接创建并用作属性的符号不会丢失？

  - 因为符号属性是

    对内存中符号

    的一个引用

- 如果没有显式地保存对这些属性的引用，

  要怎么做才能找到相应的属性键？

  - 必须遍历对象的所有符号属性

```
let o = {
    [Symbol('foo')]: 'foo val',
    [Symbol('bar')]: 'bar val'
};

// {Symbol(foo): "foo val", Symbol(bar): "bar val"}
console.log(o);

let barSymbol = Object.getOwnPropertySymbols(o)
    .find((symbol) => symbol.toString().match(/bar/));

// Symbol(bar)
console.log(barSymbol);
```

#### 4. 常用内置符号

- 常用内置符号用来做什么？
  - 用来暴露语言内部行为
    - 开发者可以直接访问、重写或模拟这些行为
  
- 这些内置符号都以什么形式存在？
  - 以 Symbol工厂函数的

    字符串属性
  
    的形式存在
  
- 常用内置符号最重要的用途之一是什么？

  - 重新定义常用内置符号

    从而改变原生结构的行为

- 已知 for-of 循环会在相关对象上使用 Symbol.iterator 属性，

  如何改变 for-of 在迭代该对象时的行为？

  - 通过修改在自定义对象上 Symbol.iterator 的值

- 内置符号是什么？

  - 是一个全局函数 Symbol 的普通字符串属性
    - 这个属性指向一个符号的实例

- 内置符号属性的特点有哪些？
  - 不可写
  - 不可枚举
  - 不可配置
  
- 引用符号在规范中的名称有什么特点？
  - 前缀为 @@
    - 比如，@@iterator 指的就是 Symbol.iterator

#### 5. Symbol.asyncIterator

-  Symbol.asyncIterator符号表示什么？
  
  - 该符号作为一个属性
  
    表示一个实现异步迭代器 API 的函数
  
- Symbol.asyncIterator 符号表示的函数返回什么？
  - 返回对象默认的 AsyncIterator

- Symbol.asyncIterator符号由什么语句使用？

  - 由 for-await-of 语句使用

- for-await-of 循环会利用这个函数执行什么操作？

  - 异步迭代操作

- for-await-of 循环原理是什么？

  - 会调用以 Symbol.asyncIterator 为键的函数

  - 并期望这个函数返回一个

    实现迭代器 API 的对象

  - 返回的对象是

    实现该 API 的 AsyncIterator

  ```
  class Foo {
      async *[Symbol.asyncIterator]() {}
  }
  let f = new Foo();
  
  // AsyncGenerator {<suspended>}
  console.log(f[Symbol.asyncIterator]());
  ```

- 技术上，这个由 Symbol.asyncIterator 函数生成的对象

  应该如何返回 Promise 实例？

  - 可以通过显示地调用 next() 方法返回

  - 也可以隐式地通过异步生成器函数返回

  ```
  class Emitter {
      constructor(max) {
          this.max = max;
          this.asyncIdx = 0;
      }
      async *[Symbol.asyncIterator]() {
          while (this.asyncIdx < this.max) {
              yield new Promise((resolve) => resolve(this.asyncIdx++));
          }
      }
  }
  async function asyncCount() {
      let emitter = new Emitter(5);
      for await (const x of emitter) {
          console.log(x);
      }
  }
  asyncCount();
  // 0
  // 1
  // 2
  // 3
  // 4
  ```

#### 6. Symbol.hasInstance

- Symbol.hasInstance 符号是什么？

  - 该符号作为一个属性表示一个方法

    - 该方法决定一个构造器对象

      是否认可一个对象

      是它的实例

- Symbol.hasInstance符号由什么操作符使用？
  - instanceof 操作符

- instanceof 操作符可以用来做什么？
  - 用来确定

    一个对象实例的原型链上
  
    是否有原型
  
- instanceof 的典型使用场景是什么？

  - 如下

    ```
    function Foo() {}
    let f = new Foo();
    console.log(f instanceof Foo); // true
    
    class Bar {}
    let b = new Bar();
    console.log(b instanceof Bar); // true
    ```

- 在 ES6 中，instanceof 操作符会使用什么为键的函数？
  -  Symbol.hasInstance 为键的函数
  
- instanceof 操作符 和 Symbol.hasInstance 函数执行时的异同？

  - 会执行同样的操作
  - 操作数对调

  ```
  function Foo() {}
  let f = new Foo();
  console.log(Foo[Symbol.hasInstance](f)); // true
  
  class Bar {}
  let b = new Bar();
  console.log(Bar[Symbol.hasInstance](b)); // true
  ```

- Symbol.hasInstance属性是否在所有函数和类上都可以调用？

  - 是
    - 因为Symbol.hasInstance属性定义在 Function 的原型上

-  instanceof 操作符的原理是什么？

  - instanceof 会在原型链上

    寻找 Symbol.hasInstance 属性定义

    就跟在原型链上寻找其它属性一样

- 如何重新定义Symbol.hasInstance函数？

  - 可以在继承的类上

    通过静态方法

    重新定义这个函数

  ```
  class Bar {}
  class Baz extends Bar {
      static[Symbol.hasInstance]() {
          return false;
      }
  }
  let b = new Baz();
  console.log(Bar[Symbol.hasInstance](b)); // true
  console.log(b instanceof Bar); // true
  console.log(Baz[Symbol.hasInstance](b)); // false
  console.log(b instanceof Baz); // false
  ```

#### 7. Symbol.isConcatSpreadable

- Symbol.isConcatSpreadable符号是什么？

  - 该符号作为一个属性表示一个布尔值

- 如果Symbol.isConcatSpreadable符号是 true 或 false 时，分别表示什么？

  - true 表示对象应该用 Array.prototype.concat()

    打平其数组元素

  - false 表示整个对象被追加到数组末尾

-  Array.prototype.concat()方法的行为是什么？

  - 根据接收到的对象类型

    选择如何将一个类数组对象

    拼接成数组实例

- 如何修改 Array.prototype.concat()方法的行为？

  - 修改 Symbol.isConcatSpreadable 的值

    可以修改该行为

- 数组对象和类数组对象默认情况下有什么区别？
  - 数组对象：被打平到已有的数组
  - 类数组对象：被追加到数组末尾

- 不是类数组对象的对象在 Symbol.isConcatSpreadable 为 true 时会怎么样？

  - 该对象会被忽略

  ```
  let initial = ['foo'];
  let array = ['bar'];
  console.log(array[Symbol.isConcatSpreadable]); // undefined
  console.log(initial.concat(array)); // ['foo', 'bar']
  array[Symbol.isConcatSpreadable] = false;
  console.log(initial.concat(array)); // ['foo', Array(1)]
  ```

  ```
  let arrayLikedObject = {
      length: 1,
      0: 'baz'
  };
  console.log(arrayLikedObject[Symbol.isConcatSpreadable]); // undefined
  console.log(initial.concat(arrayLikedObject)); // ['foo', {...}]
  arrayLikedObject[Symbol.isConcatSpreadable] = true;
  console.log(initial.concat(arrayLikedObject)); // ['foo', 'baz']
  
  let otherObject = new Set().add('qux');
  console.log(otherObject[Symbol.isConcatSpreadable]); // undefined
  console.log(initial.concat(otherObject)); // ['foo', Set(1)]
  otherObject[Symbol.isConcatSpreadable] = true;
  console.log(initial.concat(otherObject)); // ['foo']
  ```

#### 8. Symbol.iterator

- Symbol.iterator 符号表示的是什么？

  - 表示一个实现迭代器 API 的函数

- Symbol.iterator 符号表示的函数返回什么？

  - 返回对象默认的迭代器

- Symbol.iterator 符号表示的函数由什么语句使用？

  - 由 for-of 语句使用

- for-of 循环会利用这个函数执行什么操作？

  - 执行迭代操作

- for-of 循环的原理是什么？

  - 调用以Symbol.iterator 为键的函数，

  - 并默认这个函数会返回

    一个实现迭代器 API 的对象

  - 返回的对象是实现该 API 的Generator

```
class Foo {
    *[Symbol.iterator]() {}
}
let f = new Foo();
console.log(f[Symbol.iterator]()); // Generator {<suspend>}
```

- 技术上，这个由 Symbol.iterator 函数生成的对象

  应该通过什么方式陆续返回值？

  - 通过显式地调用 next（）方法返回
  - 隐式地通过生成器函数返回

  ```
  class Emitter {
      constructor(max) {
              this.max = max;
              this.idx = 0;
          }
          *[Symbol.iterator]() {
              while (this.idx < this.max) {
                  yield this.idx++;
              }
          }
  }
  
  function count() {
      let emitter = new Emitter(5);
      for (const x of emitter) {
          console.log(x);
      }
  }
  count();
  // 0
  // 1
  // 2
  // 3
  // 4
  ```

#### 9. Symbol.match

- 以 Symbol.match 为键的函数是一个什么方法？
  - 是一个正则表达式方法
- 以 Symbol.match 为键的函数用来做什么？
  - 用正则表达式去匹配字符串

- 以 Symbol.match 为键的函数由谁使用？
  - 由String.prototype.match()方法使用
- String.prototype.match()方法的原理是什么？
  - 会使用以 Symbol.match 为键的函数来对正则表达式求值

- 以 Symbol.match 为键的函数定义在哪里？

  - 正则表达式的原型上

- String.prototype.match() 方法的有效参数是什么？

  - 所有正则表达式实例

    ```
    console.log(RegExp.prototype[Symbol.match]);
    // ƒ [Symbol.match]() { [native code] }
    
    console.log('foobar'.match(/bar/));
    // ["bar", index: 3, input: "foobar", groups: undefined]
    ```

- 给 String.prototype.match() 方法传入非正则表达式值会导致什么？

  - 非正则表达式值

    会被转换为 RegExp 对象

- 如何让 String.prototype.match() 方法 直接使用非正则表达式实例？

  - 重新定义 Symbol.match 函数

- Symbol.match 函数接收一个什么参数？

  - 调用 match（）方法的字符串实例

- Symbol.match 函数返回值有什么限制？

  - 没有限制

  ```
  class FooMatcher {
      static[Symbol.match](target) {
          return target.includes('foo');
      }
  }
  console.log('foobar'.match(FooMatcher)); // true
  console.log('barbaz'.match(FooMatcher)); // false
  class StringMatcher {
      constructor(str) {
              this.str = str;
          }
          [Symbol.match](target) {
              return target.includes(this.str);
          }
  }
  console.log('foobar'.match(new StringMatcher('foo'))); // true
  console.log('barbaz'.match(new StringMatcher('qux'))); // false 
  ```

#### 10. Symbol.replace

- 以 Symbol.replace为键的函数是用来做什么的？

  - 用来替换

    一个字符串中匹配的子串

- 以 Symbol.replace为键的函数由谁使用？

  - 由 String.prototype.replace() 方法使用

-  String.prototype.replace() 方法的原理是什么？

  - 使用以 Symbol.replace为键的函数

    来对正则表达式求值

- 以 Symbol.replace为键的函数定义在哪里？
  - 正则表达式的原型上
- 以 Symbol.replace为键的函数的有效参数是什么？
  - 所有正则表达式

```
console.log(RegExp.prototype[Symbol.replace]);
// ƒ [Symbol.replace]() { [native code] }
console.log('foobarbaz'.replace(/bar/, 'qux'));
// fooquxbaz
```

- 给以 Symbol.replace为键的函数传入非正则表达式值会导致什么？
  - 导致该非正则表达式值被转换为 RegExp 对象
- 如何让以 Symbol.replace为键的函数直接使用参数？
  - 重新定义 Symbol.replace 函数
-  Symbol.replace 函数接收哪两个参数？
  - 调用 replace（）方法的字符串实例（target）
  - 替换字符串（replacement）

- Symbol.replace 函数返回的值是否有限制？

  - 没有限制

  ```
  class FooReplacer {
      static [Symbol.replace](target, replacement) {
          return target.split('foo').join(replacement);
      }
  }
  console.log('barfoobaz'.replace(FooReplacer, 'qux'));
  // barquxbaz
  
  class StringReplacer {
      constructor(str) {
          this.str = str
      }
      [Symbol.replace](target, replacement) {
          return target.split(this.str).join(replacement);
      }
  }
  console.log('barfoobaz'.replace(new StringReplacer('foo'), 'qux'));
  // barfoobaz
  ```

#### 11. Symbol.search

- 以Symbol.search为键的函数返回什么？

  - 返回字符串中匹配正则表达式的索引

- 以Symbol.search为键的函数由谁使用？

  - 由 String.prototype.search() 方法使用

-  String.prototype.search() 方法的原理是什么

  - 使用以Symbol.search为键的函数

    来对正则表达式求值

- 以 Symbol.replace为键的函数定义在哪里？
  - 正则表达式的原型上
- 以 Symbol.replace为键的函数的有效参数是什么？
  - 所有正则表达式

```
console.log(RegExp.prototype[Symbol.search]);
// ƒ [Symbol.search]() { [native code] }
console.log('foobar'.search(/bar/));
// 3
```

- 给以 Symbol.replace为键的函数传入非正则表达式值会导致什么？
  - 导致该非正则表达式值被转换为 RegExp 对象
- 如何让以 Symbol.replace为键的函数直接使用参数？
  - 重新定义 Symbol.replace 函数
-  Symbol.replace 函数接收哪一个参数？
  - 调用 replace（）方法的字符串实例

- Symbol.replace 函数返回的值是否有限制？
  - 没有限制

```
class FooSearcher {
    static[Symbol.search](target) {
        return target.indexof('foo');
    }
}
console.log('foobar'.search(FooSearcher)); // 0
console.log('barfoo'.search(FooSearcher)); // 3
console.log('barbaz'.search(FooSearcher)); // -1
class StringSearcher {
    constructor(str) {
            this.str = str;
        }
        [Symbol.search](target) {
            return target.indexof(this.str);
        }
}
console.log('foobar'.search(new StringSearcher('foo'))); // 0
console.log('barfoo'.search(new StringSearcher('foo'))); // 3
console.log('barbaz'.search(new StringSearcher('qux'))); // -1
```

#### 12. Symbol.species

- 以 Symbol.species 为键的函数是用来做什么的？

  - 该函数作为创建派生对象的构造函数

  - 用来对内置类型实例方法的返回值

    暴露实例化派生对象的方法

- 以 Symbol.species 为键的函数在哪里最常用？

  - 在内置类型中最常用

- 使用 Symbol.species 可以做什么？

  - 定义静态的获取器（getter）方法

    可以覆盖新创建实例的原型定义 

```
class Bar extends Array {}
class Baz extends Array {
    static get[Symbol.species]() {
        return Array;
    }
}
let bar = new Bar();
console.log(bar instanceof Array); // true
console.log(bar instanceof Bar); // true
bar = bar.concat('bar');
console.log(bar instanceof Array); // true
console.log(bar instanceof Bar); // true
let baz = new Baz();
console.log(baz instanceof Array); // true
console.log(baz instanceof Baz); // false
```

#### 13. Symbol.split

- 以Symbol.split为键的函数用来做什么的？

  - 用来在匹配表达式的索引位置

    拆分字符串

- 以Symbol.split为键的函数由谁使用？

  - String.prototype.split() 方法使用

- String.prototype.split() 方法的原理是什么

  - 使用以Symbol.split为键的函数

    来对正则表达式求值

- 以 Symbol.split为键的函数定义在哪里？
  - 正则表达式的原型上
- 以 Symbol.split为键的函数的有效参数是什么？
  - 所有正则表达式

```
console.log(RegExp.prototype[Symbol.split]);
// ƒ [Symbol.split]() { [native code] }
console.log('foobarbaz'.split(/bar/));
// ['foo', 'baz']
```

- 给以 Symbol.split为键的函数传入非正则表达式值会导致什么？
  - 导致该非正则表达式值被转换为 RegExp 对象
- 如何让以 Symbol.split为键的函数直接使用参数？
  - 重新定义 Symbol.split函数
-  Symbol.split函数接收哪一个参数？
  - 调用 split（）方法的字符串实例

- Symbol.split函数返回的值是否有限制？
  - 没有限制

```
class FooSplitter {
    static[Symbol.split](target) {
        return target.split('foo');
    }
}
console.log('barfoobaz'.split(FooSplitter));
// ['bar', 'baz']
class StringSplitter {
    constructor(str) {
            this.str = str;
        }
        [Symbol.split](target) {
            return target.split(this.str);
        }
}
console.log('barfoobaz'.split(new StringSplitter('foo')));
// ['bar', 'baz']
```

