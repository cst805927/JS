# 第 3 章 语言基础

## 本章内容

- 语法
- 数据类型
- 流控制语句
- 理解函数

## 3.1 语法

### 3.1.1 区分大小写

- ECMAScript 一切都区分大小写

### 3.1.2 标识符

- 标识符是什么？
  - 是变量、函数、属性、函数参数的名字
- 组成标识符的字符有哪些规定？
  - 第一个字符必须是
    - 字母、
    - 下划线（_）
    - 美元符号（$）
  - 剩下的字符可以是
    - 第一个字符允许的3种
    - 数字
  
- 标识符的最佳实践是什么？

  - 驼峰大小写形式

    - 第一个单词的首字母小写

      后面每个单词的首字母大写

- 哪些字符不能作为标识符？
  - 关键字
  - 保留字
  - true、false
  - null

### 3.1.3 注释

- ECMAScript注释有哪几种？

  - 单行注释

    ```
    // 单行注释
    ```

  - 块注释

    ```
    /* 这是多行
    注释 */
    ```

### 3.1.4 严格模式

- 严格模式是什么？
  - 是一种 JS 解析和执行模型

- 严格模式的特点是什么？

  - 处理 ECMAScript 3 的一些不规范的写法
  - 对于不安全的活动将抛出错误
    - 保证代码安全运行
  - 禁用在未来版本中可能会使用的语法
    - 为新版本做好铺垫。

- 严格模式常见的限制有哪些？

  - 所有的变量要先声明

  - 函数中 this 对象的默认值是 undefined,

    - 而不是全局对象 window。

  - 禁止使用 delete 运算符删除不可删除的属性

  - 函数声明中不能定义同名参数

    - 如 sum（x，x）{}

  - 禁止使用以 0 为前缀的八进制数字

    - 如 010

  - 禁止使用 with 语句。

  - 不能将 eval 和 arguments 

    用作变量、函数、参数的名称。

- 如何开启严格模式？

  - 在脚本开头加上一行“use strict”

- “use strict”指令是否有副作用？

  - 没有副作用

- 老版的浏览器会怎么处理 “use strict” 指令?

  - 作为一行字符串直接忽略。 

- 选择严格模式的目的是什么？

  - 不破坏 ECMAScript 3 的语法

- 如何单独指定一个函数在严格模式下执行

  - ```
    function doSomeThing () {
    	"use strict";
    	// 函数体
    }
    ```

- 所有现代浏览器都支持严格模式吗？
  - 是的

### 3.1.5 语句

- ECMAScript 中的语句是以什么结尾的？

  - 分号

- 省略分号意味着什么？

  - 意味着由解析器确定语句在哪里结尾

- 加分号由什么好处？

  - 防止省略造成的问题
    - （如避免输入内容不完整）

  - 便于开发者删除空行来压缩代码

    - （如果没有分号，只删除空行，会导致语法错误）

  - 在某些情况下提升性能

    - 因为解析器会尝试

      在合适的位置补上分号

      以纠正语法错误


- 分号的自动补全是指什么？
  - JS 解释器就会根据自己的判断在某个位置插入分号

- 分号会在什么时候自动补全?

  - 省略了分号
  - 并且无法正确解析代码时

- 自动补全分号有什么弊端?

  - 可能改变代码的行为，

    - 例如一条以“(、[、/、+、-”这些字符开头的语句，

      有可能会与前一条语句合并在一起，

      作为一个整体被解析

```
var total = sum
(x + y);
//相当于
var total = sum(x + y);
```

- 代码块由什么组成？

  - 由一个左花括号（{）开始，

    一个右花括号（}）标识结束

- 控制语句的最佳实践是什么？

  - 始终使用代码块

    - 即使要执行的只有一条语句

- 使用代码块有什么好处？
  - 让内容更清晰
  - 在修改代码时减少出错的可能性

## 3.2 关键字与保留字

- ECMA-262 保留的关键字有哪些？

  - ```
    break		do			in			   typeof
    case		else		instanceof		var
    catch		export		new				void
    class		extends		return			while
    const		finally		super			with
    continue	for			switch			yield
    debugger	function	this
    default		if			throw
    delete		import		try
    ```

- 关键字能否用作标识符或属性名？
  - 不能

- ECMA-262 未来的保留字有哪些？

  - ```
    始终保留：
    enum
    严格模式下保留：
    implements	package		public
    interface	protected	static
    let			private
    模板代码中保留：
    await
    ```

## 3.3 变量

- ECMAScript 变量是什么类型的？
  - 松散类型（弱类型）
    - 变量可以用来保存任何类型的数据
- 变量的是用来做什么的？
  - 用来保存任意值的命名占位符
- 有什么关键字可以声明变量，每个关键字在哪些版本中可以使用？
  - var 
    - 所有版本
  - const
    - ES 6 及更晚的版本
  - let
    - ES 6 及更晚的版本

### 3.3.1 var 关键字

- 如何使用 var 操作符定义变量？

  - ```
    var message;
    ```

- 不初始化的情况下，变量会保存什么值？
  - 特殊值 undefined

- 可以同时定义变量并设置它的值吗？

  - 可以

  - ```
    var message = "hi"
    ```

- 可以改变值的数据类型吗？

  - 可以，但不推荐

  - ```
    var message = "hi"
    message = 100
    ```

#### 1. var 声明作用域

- var 的关键问题是什么？

  - 使用 var 操作符定义的变量

    会成为

    包含它的函数的局部变量

    - 意味着变量会在函数退出时被销毁

  - ```
    function test() {
    	var messaage = "hi"; // 局部变量
    }
    test();
    console.log(message); // 出错
    ```

- 如何创建一个全局变量？

  - 省略 var 操作符

    ```
    function test() {
    	message = "hi"; // 全局变量
    }
    test();
    console.log(message);
    ```

- 为什么不推荐通过省略 var 操作符定义全局变量？

  - 很难维护

    - 在局部作用域定义的全局变量很难维护

  - 造成困惑

    - 不能马上断定

      省略 var 操作符是不是有意为之

  - 在严格模式下，会抛出 ReferenceError 错误

    - 如果给未声明的变量赋值

- 如何定义多个变量？

  - 在一条语句用逗号分割每个变量

    ```
    var message = "hi",
    	found = false,
    	age = 29;
    ```

- 在严格模式下，不能定义名字是什么的变量，否则会导致语法错误？
  - eval
  - arguments

#### 2. var 声明提升

- 下面的代码是否会报错？

  ```
  function foo() {
  	console.log(age);
  	var age = 26;
  }
  foo(); // undefined
  ```

  - 不会报错

    - 因为用 var 声明的变量

      会提升到函数作用域顶部

- 提升是什么意思？

  - 把所有变量声明

    都拉到函数作用域的顶部

- 能不能多次使用 var 声明同一个变量？

  - 能

    ```
    function foo() {
    	var age = 16;
    	var age = 26;
    	var age = 36;
    	console.log(age);
    }
    foo() // 36
    ```

### 3.3.2 let 声明

- let 和 var 的重要区别有哪些？

  - 全局作用域中声明的变量是否会成为 window 对象的属性

    - let 不会

    - var 会

  - 提升

    - let 不会提升
    - var 会提升

  - 声明的范围不同

    - let 块作用域
    - var 函数作用域

    ```
    if (true) {
    	var name = 'Matt';
    	console.log(name); // Matt
    }
    console.log(name); // Matt
    ```

    ```
    if (true) {
    	let age = 26;
    	console.log(age); // 26
    }
    console.log(age); // ReferenceError: age 没有定义
    ```

    - 因为 age 的作用域仅限于该块内部

- 块作用域和函数作用域的关系？
  - 块作用域是函数作用域的子集

- 适用于 var 作用域的限制是否适用于 let ？
  - 是
    - 因为块作用域是函数作用域的子集

- let 是否允许同一个块作用域中出现冗余声明？

  - 不允许

    ```
    var name;
    var name;
    ```

    ```
    let age;
    let age; // SyntaxError：标识符age已经声明过了
    ```

- 嵌套使用相同的标识符是否会报错？

  - 不会

    - 因为同一个块中没有重复声明

    ```
    var name = 'Nicholas';
    console.log(name); // 'Nicholas'
    if (true) {
    	var name = 'Matt';
    	console.log(name); // 'Matt'
    }
    ```

    ```
    let age = 10;
    console.log(age); // 10
    if (true) {
    	let age = 26;
    	console.log(age) // 26
    }
    ```

- let 和 var 声明的是什么？

  - 指出变量在相关作用域如何存在

  ```
  var name;
  let name; // SyntaxError
  ```

  ```
  let age;
  var age; // SyntaxError
  ```

#### 1.  暂时性死区

- let 和 var 的重要区别有哪些？

  - 声明的范围不同

    - let 块作用域
    - var 函数作用域

  - 提升

    - let 不会提升
    - var 会提升

    ```
    // name会被提升
    console.log(name); // undefined
    var name = 'Matt';
    ```

    ```
    // age不会被提升
    console.log(age); // ReferenceError:age没有定义
    let age = 26;
    ```

  - 全局作用域中声明的变量是否会成为 window 对象的属性

    - let 不会

    - var 会

- 什么是“暂时性死区”？

  - 在 let 声明之前的执行瞬间

- 在“暂时性死区”阶段引用任何后面才声明的变量会发生什么？
  - 抛出 ReferenceError

#### 2. 全局声明

- var 和 let 有什么区别？

  - 声明的范围不同

    - let 块作用域
    - var 函数作用域

  - 提升

    - let 不会提升
    - var 会提升

  - 全局作用域中声明的变量是否会成为 window 对象的属性

    - let 不会

    - var 会

    ```
    var name = 'Matt';
    console.log(window.name); // 'Matt'
    ```

    ```
    let age = 26;
    console.log(window.age); // undefined
    ```

#### 3. 条件声明

- 使用 var 冗余声明时，JS 引擎会怎么做？

  - 在作用域顶部

    将冗余声明

    合并为一个声明
    
    - 因为声明会被提升

- let 会不会检查前面是否声明过同名变量？

  - 不会
    - 因为 let 的作用域是块

- let 有没有可能在没有声明的情况下声明变量

  - 不可能
    - 因为 let 的作用域是块


  ```
      <script>
        var name = "Nicholas";
        let age = 26;
      </script>
      <script>
        // 脚本不确定页面是否已经声明了同名变量
        // 那脚本可以假设还没有声明过
  
        // 这里没问题，因为可以被作为提升声明来处理
        // 不需要检查之前是否声明过同名变量
        var name = "Matt";
  
        // 如果age之前声明过，这里会报错
        let age = 36; // SyntaxError: Identifier 'age' has already been declared
      </script>
  ```

  - 用 try/catch 语句或 typeof 操作符也不能解决

    ```
        <script>
          var name = "Nicholas";
          let age = 36;
        </script>
        <script>
          // 脚本不确定页面是否已经声明了同名变量
          // 那脚本可以假设还没有声明过
    
          // name被限制在if{}块的作用域内
          if (typeof name === "undefined") {
            let name;
          }
          // 因此这个赋值是全局赋值
          name = "Matt";
    
          try {
            // 如果age没有声明过，这里会报错
            console.log(age); // 36
          } catch (error) {
            let age;
          }
          // age被限制在catch()块的作用域内
          // 因此这个赋值是全局赋值
          age = 26;
        </script>
    ```

- let 是否可以依赖条件声明模式？
  - 不可以
    - 因为 let 的作用域是块
  
- 条件声明模式的缺点是什么？
  - 让程序更难理解

#### 4. for 循环中的 let 声明

- 用 var 定义for 循环的迭代变量会有什么问题？

  - 迭代变量会渗透到循环体外部

    ```
    for (var i = 0; i < 5; i++) {
    	// 循环逻辑
    }
    console.log(i); // 5
    ```

- 改用 let 后，迭代变量渗透到外部的问题是否还存在？

  - 不存在

    - 因为迭代变量的作用域

      仅限于 for 循环块内部

      ```
      for (let i = 0; i < 5; i++) {
      	// 循环逻辑
      }
      console.log(i); // ReferenceError: i没有定义
      ```

- 在使用 var 时，对迭代变量最常见的问题是什么？

  - 对迭代变量的奇特声明和修改

    ```
    for (var i = 0; i < 5; i++) {
    	setTimeout(() => console.log(i), 0)
    }
    // 输出 5，5，5，5，5
    ```

- 退出循环时，使用 var 定义的迭代变量保存的是什么？
  - 保存的是导致循环退出的值：5
    - 退出循环之后
    
      执行 setTimeout 时，
    
      所有的 i 都是同一个变量 5

- 在使用 let 声明迭代变量时，JS 引擎会做什么？

  - JS 引擎会为每个迭代循环

    声明一个新的迭代变量

    - 此时每个setTimeout 引用的都是不同的变量

      ```
      for (let i = 0; i < 5; i++) {
      	setTimeout(() => console.log(i), 0)
      }
      // 输出 0，1，2，3，4
      ```

- let 每次迭代声明一个独立变量的行为

  是否适用于所有风格的 for 循环？

  - 是
    - 包括 for-in 和 for-of

### 3.3.3 const 声明

- const 和 let 的重要区别是什么？

  - const 声明变量时

    必须初始化变量

    且不能修改
    
    ```
    const age = 25;
    age = 36; // TypeError: 给常量赋值
    ```
    

- const 和 let 有哪些共同点？

  - 不允许重复声明

    ```
    const name = 'Matt';
    const name = 'Nicholas'; // SyntaxError
    ```

  - 声明的作用域是块

    ```
    const name = 'Matt';
    if (true) {
    	const name = 'Nicholas';
    }
    console.log(name); // Matt
    ```

- 如果 const 变量引用的是一个对象，是否可以修改这个对象内部的属性？

  - 可以

    - 因为 const 声明的限制

      只适用于
      
      它指向的变量的引用
    
    ```
    const person = {};
    person.name = 'Matt'; // ok
    ```

- 能否用 const 来声明迭代变量？

  - 不能

    - 因为迭代变量会自增

    ```
    for (const i = 0; i < 10; i++) {} // TypeError:给常量赋值
    ```

- 每次迭代用 const 只创建一个新变量，适用于什么循环？

  - for-in ：遍历 key

  - for-of ：遍历 value

    ```
    for (const key in {a: 1, b: 2}) {
    	console.log(key);
    }
    // a, b
    
    for (const value of [1, 2, 3, 4, 5]) {
    	cosole.log(value);
    }
    // 1, 2, 3, 4, 5
    ```

### 3.3.4 声明风格及最佳实践

#### 1. 不使用 var

- 只使用 let 和 const 的好处是什么？
  - 提升代码质量
    - 因为变量有了
      - 明确的作用域、
      - 声明位置、
      - 不变的值

#### 2. const 优先，let 次之

- 使用 const 声明变量的好处有哪些？
  - 让浏览器运行时
  
    强制保持变量不变
  
  - 让静态代码分析工具
  
    提前发现不合法的赋值操作
  
- 什么时候使用 let ？
  - 提前知道未来会有修改时，再使用 let

## 3.4 数据类型

- ECMAScript 的简单数据类型有哪几种？
  - 6 种简单数据类型（原始类型）
  - Undefined
  - Null
  - Boolean
  - Number
  - String
  - Symbol（ES6 新增）

- 有一种复杂数据类型叫什么？
  - Object（对象）
- Object 是什么？
  - Object是一种无序名值对的集合

- 在 ECMAScript 中能否定义自己的数据类型？
  - 不能

### 3.4.1 typeof 操作符

- 如何确定变量的数据类型？

  - 用 typeof 操作符

- 对一个值用 typeof 操作符会返回什么？

  - 全是小写字符串
  - “undefined” 未定义
  - “boolean” 布尔值
  - “string” 字符串
  - “number” 数值
  - “object” 对象或null
  - “function” 函数
  - “symbol” 符号

- 使用 typeof 操作符的例子

  ```
  let message = "some string";
  console.log(typeof message); // "string"
  console.log(typeof(message)); // "string"
  console.log(typeof 95); // "number"
  ```

- typeof 是不是一个函数？是否需要参数？

  - 不是一个函数
    - 是一个操作符

  - 因为不是函数，所以不需要参数，
    - 但可以使用参数

- 为什么调用 typeof null 返回的是 “object” ？
  - 因为特殊值 null 被认为是一个空对象的引用

- 为什么要通过 typeof 操作符区分函数和其他对象？

  - 因为函数也有自己特殊的属性

    - 但严格来讲，

      函数被认为是对象，

      并不代表一种数据类型


- typeof 操作符的优先级是怎样的？
  - 高于赋值操作符（=）
- 如何区分 null 和对象？
  - 使用 Object.prototype.toString() 

```
const toString = Object.prototype.toString();
toString.call(null); // "[object Null]"
```

### 3.4.2 Undefined 类型

- undefined类型有几个值？

  - 只有一个值

    特殊值 undefined

- 什么情况下相当于给变量赋值为undefined值？

  - 当使用 var 或 let 声明了变量

    但没有初始化时

    ```
    let message;
    console.log(message === undefined); // true
    ```

- 为什么不要显式地给某个变量设置 undefined？

  - 因为字面量 undefined 主要用于比较
  - 而且在 ES 3 之前不存在

- 增加特殊值 undefined 的目的是什么？

  - 为了明确

    空对象（null）和

    未初始化变量的区别

- 包含 undefined 值的变量与未定义变量有什么区别？

  - ```
    let message; 
    console.log(message); // "undefined"
    console.log(age); // 报错：age未定义
    ```
  
- 对未声明的变量，只能执行的哪个有用的操作？

  - 对它调用 typeof

    - 对它调用 delete 也不会报错，

      但这个操作没用

      严格模式下会报错

- 对未初始化的变量调用 typeof，返回的结果是什么？

  - “undefined”

- 对未声明的变量调用 typeof，返回的结果是什么？

  - “undefined”

- 为什么建议在声明变量的同时进行初始化？

  - 因为这样做之后

    当 typeof 返回 “undefined” 时

    就一定有变量未声明

    而不是声明了未初始化

- undefined 是一个真值还是假值？

  - 假值

    ```
    let message; // 这个变量被声明了，只是值为 undefined
    // age 没有声明
    if (message) {
    	// 这个块不会执行
    }
    if (!message) {
    	// 这个块会执行
    }
    if (age) {
    	// 这里会报错
    }
    ```

- void 运算符能执行什么操作？
  - 能忽略操作数的计算结果
  - 同时返回undefined。

```
void(0); // undefined
```

### 3.4.3 Null 类型

- Null 类型有哪些值？

  - 只有一个值

    即特殊值 null

- 逻辑上讲，null值表示什么意思？

  - 表示一个空对象指针

    - 这也是 typeof null 返回 “object” 的原因


    ```
    let car = null;
    console.log(typeof car); // "object"
    ```

- 在定义将来要保存对象值的变量时，建议使用什么初始化

  - 使用 null 来初始化，不要使用其他值

- 为什么要用 null 来初始化？

  - 因为只要检查这个变量的值是不是 null

    就知道这个变量

    是否在后来

    被重新赋予了一个对象的引用
    
    ```
    if (car !== null) {
    	// car是一个对象的引用
    }
    ```

- 为什么 ECMA-262 将 undefined 和 null 定义为表面相等？

  - 因为 undefined 值是由 null 值派生而来的

    ```
    console.log(null == undefined); // true
    ```

    - == 操作符会转换操作数的数据类型

- null 是一个真值还是假值？

  - 假值

    ```
    let message = null;
    if (message) {
    	// 这个块不会执行
    }
    if (!message) {
    	// 这个块会执行
    }
    ```

- undefined和 null 有哪些相同点?
  - (1）都有空缺的意思。
  - (2）不包含方法和属性。
  - (3）都是假值。
  - (4）都只有一个值。
- undefined和 null 有哪些不同点?
  - (1）含义不同，
    - undefined表示一个未定义的值，
    - null表示一个空的对象。
  - (2）类型不同，
    - typeof undefined，得到“undefined";
    - typeof null，得到“object”。
  - (3）数字转换不同，
    - Number(undefined) = NaN
    - Number(null) = 0
  - (4）在非严格模式中的表现不同，
    - undefined可以是一个标识符，
      - 能被当作变量来使用和赋值
    - null不可以是一个标识符

### 3.4.4 Boolean 类型

- Boolean 类型有哪几个字面量？

  - 有两个字面量
    - true
    - false

- true 是否等于 1，false 是否等于 0 ？

  - 这两个布尔值不同于数值

    - true 不等于 1

    - false 不等于 0

      ```
      let found = true;
      let lost = false;
      ```

- 布尔值字面量 true 和 false 是否区分大小写？

  - 是

    - 因此 True 和 False（及其它大小混写形式）

      是有效的标识符

      但不是布尔值

- 如何将一个其他类型的值转换为布尔值？

  - 调用 Boolean() 转型函数

    ```
    let message = "Hello World!";
    let messageAsBoolean = Boolean(message);
    ```

    | 数据类型  | 转换为 true 的值       | 转换为 false 的值 |
    | --------- | ---------------------- | ----------------- |
    | Boolean   | true                   | false             |
    | String    | 非空字符串             | “”（空字符串）    |
    | Number    | 非零数值（包括无穷值） | 0，NaN            |
    | Object    | 任意对象               | null              |
    | Undefined |                        | undefined         |

- 像 if 等流控制语句会自动执行什么？

  - 其它类型到布尔值的转换

    ```
    let message = "Hello World!";
    if (message) {
    	console.log("Value is true");
    }
    ```

### 3.4.5 Number 类型

- Number 类型使用什么格式表示整数和浮点数？

  - IEEE 754 格式

- 如何创建八进制字面量？

  - 第一个数字必须是零（0）
  - 然后是相应的八进制数字（0 ~ 7）

- 如果八进制字面量中包含的数字超出了应有的范围，会发生什么？

  - 会忽略前缀的零

  - 后面的数字序列会被当成十进制数

    ```
    let octalNum1 = 070; // 八进制的56
    let octalNum2 = 079; // 无效的八进制，当成79处理
    let octalNum3 = 08; // 无效的八进制，当成8处理
    ```

- 在严格模式下八进制字面量可以使用吗

  - 不能，会抛出语法错误

- 如何创建十六进制字面量？

  - 前缀必须是 0x（区分大小写）
  - 后面是十六进制数字（0 ~ 9 以及 A ~ F）

- 十六进制中的数字有大小写区分吗？

  - 没有，大小写均可

    ```
    let hexNum1 = 0xA; // 十六进制10
    let hexNum2 = 0x1f; // 十六进制31
    ```

- 在数学操作中遇到八进制或十六进制会发生什么？
  - 都被视为十进制数值
- 正零（+0）和负零（-0）等同吗？
  - 在所有情况下都认为是等同的

#### 1. 浮点值

- 如何定义一个浮点值

  - 数值中必须包含小数点

  - 小数点后面必须至少有一个数字

  - 小数点前面不是必须有整数，但推荐加上

    ```
    let floatNum1 = 1.1;
    let floatNum2 = 0.1;
    let floatNum3 = .1; // 有效，但不推荐
    ```

- 为什么 ECMAScript 总是想方设法把浮点值转换为整数值？

  - 因为存储浮点值使用的内存空间

    是存储整数值的两倍

- 在什么情况下，浮点值会变成整数值？
  - 小数点后面没有数字

- 如果数值本身是整数，小数点后面跟着 0，它是否会转换为浮点数？
  - 不会，依然是整数值

```
let floatNum1 = 1.; // 小数点后面没有数字，当成整数1处理
let floatNum2 = 10.0 // 小数点后面是零，当成整数10处理
```

- 浮点值是可以怎么表示非常大或非常小的数值？

  - 用科学计数法

- 科学计数法是用来表示什么数值的？

  - 用来表示一个应该乘以 10 的给定次幂的数值

  ```
  let floatNum = 3.125e7; //等于 31250000
  ```

- 科学计数法的优点？
  - 更简洁

- 默认情况下，ECMAScript 会将什么样的浮点数转换为科学计数法？

  - 小数点后至少 6 个零的浮点值

    （如 0.000 0003 会被转换为 3e-7）

- 浮点值的精确度最高可达到多少？
  - 17位小数
- 浮点值的算术计算有什么问题？
  - 不够准确
    - 例如 0.1 + 0.2 得到的不是 0.3

- 为什么很难测试特定的浮点值？

  - 因为存在微小的舍入错误

    ```
    if (a + b == 0.3) { //别这么做！
    	console.log("You got 0.3.");
    }
    ```

- 为什么会存在舍入错误？
  - 因为使用了 IEEE 754 数值

#### 2. 值的范围

- ECMAScript 能支持表示这个世界上的所有数值吗？

  - 不支持
    - 因为内存的限制

- ECMAScript 可以表示的最小和最大的数值保存在哪里？

  - 最小数值保存在 Number.MIN_VALUE 中

  - 最大数值保存在 Number.MAX_VALUE 中

- 如果某个计算得到的数值结果超出了 JS 可以表示的范围，会发生什么？

  - 这个数值会被自动转换为一个特殊的 Infinity（无穷）值
    - 负数以 -Infinity（负无穷大）表示
    - 正数以 Infinity（正无穷大）表示

- 如果计算返回正 Infinity 或负 Infinity，该值能不能再进一步用于计算？

  - 不能
    - 因为 Infinity 没有可用于计算的数值表示形式

- 如何确定一个值是不是有限大（介于最小值和最大值之间）？

  - 使用 isFinite() 函数

    ```
    let result = Number.MAX_VALUE + Number.MAX_VALUE;
    console.log(isFinite(result)); //false
    ```

- 在计算非常大或非常小的数值时，需要注意什么？
  - 检测一下计算结果是否超出范围

- Number 的哪两个属性可以表示正、负 Infinity？
  - Number.NEGATIVE_INFINITY
  - Number.POSITIVE_INFINITY

#### 3. NaN

- NaN 表示什么意思？

  - 不是数值（Not A Number）

- NaN 用来表示什么？

  - 用来表示本来要返回数值的操作失败了

    （而不是抛出错误）

- 在 ECMAScript 中，0、+0、-0 相除会发生什么？

  - 会返回 NaN

    ```
    console.log(0/0); // NaN
    consolr.log(-0/+0); // NaN
    ```

- 如果分子是非 0 值，分母是有符号 0 或无符号 0，会发生什么？

  - 返回 Infinity 或 -Infinity

    ```
    console.log(5/0); // Infinity
    console.log(5/-0); // -Infinity
    ```

- NaN 有哪几个特点？

  - 任何涉及 NaN 的操作始终返回 NaN（如 NaN/10）

  - NaN 不等于包括 NaN 在内的任何值

    ```
    console.log(NaN == NaN); //false
    ```
  
- 如何判断一个数是否是 NaN？

  - 使用 isNaN() 函数

- isNaN() 函数的原理是什么？

  - 函数会把参数转换为数值

    - 任何不能转换为数值的值

      都会使函数返回 true

    ```
    console.log(isNaN(NaN)); // true
    console.log(isNaN(10)); // false，10是数值
    console.log(isNaN("10")); // false，可以转换为数值10
    console.log(isNaN("blue")); // true，不可以转换为数值
    console.log(isNaN(true)); // false，可以转换为数值1
    ```

- isNaN() 用于测试对象的原理是什么？

  - 首先调用对象的 valueOf（）方法

  - 然后判断返回的值

    是否可以转换为数值

    - 如果不能

      再调用 toString（）方法

      并测试其返回值

#### 4. 数值转换

- 哪些函数可以将非数值转换为数值？
  - Number（） 
  - parseInt（）
  - parseFloat（）

- Number（）可用于什么场景？
  - 用于将任何数据类型转换为数值
    - 是转型函数

- parseInt（）和 parseFloat（）可用于什么场景？
  - 用于将字符串转换为数值

- Number（）函数基于什么规则执行转换？

  - 布尔值

    - true 转换为 1
    - false 转换为 0

  - 数值

    - 返回十进制表示

  - null

    - 返回 0

  - undefined

    - 返回 NaN

  - 字符串

    - 如果字符串包含数值字符（包括数值字符前面加、减号的情况）

      则转换为一个十进制数值

      - Number("1") 返回 1
      - Number("123") 返回 123
      - Number("011") 返回 11（忽略前面的 0 ）

    - 如果字符串包含有效的浮点值格式如“1.1”

      则会返回相应的浮点值（同样忽略前面的 0 ）

    - 如果字符串包含有效的十六进制格式如“0xf”

      则会转换为与该十六进制值

      对应的十进制整数

    - 如果是空字符串，

      则返回 0

    - 如果字符串包含除上述情况之外的其它字符

      则返回 NaN

  - 对象，

    调用 valueOf（）方法

    并按照上述规则转换返回的值

    - 如果转换的结果是 NaN

      - 则调用 toString（）方法

        再按照转换字符串的规则转换

  ```
  let num1 = Number("Hello World"); // NaN
  let num2 = Number(""); // 0
  let num3 = Number("000011"); // 11
  let num4 = Number(true); // 1
  ```

- 需要整数时，使用什么函数？

  - 使用 parseInt（）函数

    - 因为 parseInt（）更专注于

      字符串是否包含数值模式

- parseInt（）函数的转换规则是什么？

  - 字符串最前面的空格会被忽略

    从第一个非空格字符开始转换

  - 如果第一个字符不是

    数值字符、加号、减号

    返回 NaN

  - 如果是空字符串，返回 NaN

  - 如果第一个字符是数值字符、加号、减号

    - 则继续依次检测每个字符

      - 直到字符串末尾

    
      - 或碰到非数值字符
    

    - 如“1234blue”会被转换成 1234

      因为 ”blue“被忽略

    - 如“22.5”会被转换成 22
    
      因为小数点不是有效的整数字符

- parseInt（）函数能不能识别不同的整数格式（十进制、八进制、十六进制）？

  - 能

- parseInt（）函数识别整数格式的规则是什么？

  - 如果字符串以“0x”开头

    会被解释为十六进制整数

  - 如果字符串以“0”开头，且紧跟数值字符

    在非严格模式下

    会被解释为八进制整数

    ```
    let num1 = parseInt("1234blue"); // 1234
    let num2 = parseInt(""); // NaN
    let num3 = parseInt("0xA"); // 10，解释为十六进制整数
    let num4 = parseInt(22.5); // 22
    let num5 = parseInt("70"); // 70，解释为十进制值
    let num6 = parseInt("0xf"); // 15，解释为十六进制整数
    ```

- parseInt（）函数的第二个参数是用来做什么的？
  - 用来指定底数（进制数）

- 如果知道要解析的值是十六进制，应该怎么用 parseInt（）函数？

  - 传入 16 作为 parseInt（）函数的第二个参数

    ```
    let num = parseInt("0xAF", 16); // 175
    ```

- 如果 parseInt（）函数提供了十六进制参数，字符串前面的“0x”是否可以省略？

  - 可以

    ```
    let num1 = parseInt("AF", 16); // 175
    let num2 = parseInt("AF"); // NaN
    ```

- parseInt（）函数的第二个参数有什么优点？

  - 可以扩展转换后的结果类型

    ```
    let num1 = parseInt("10", 2); // 2，按二进制解析
    let num2 = parseInt("10", 8); // 8，按八进制解析
    let num3 = parseInt("10", 10); // 10, 按十进制解析
    let num4 = parseInt("10", 16); // 16, 按十六进制解析
    ```

- 为什么建议始终要传parseInt（）函数的底数参数？

  - 因为如果不传底数参数

    相当于让 parseInt（）自己决定如何解析

    有解析出错的风险

    - 传底数可以防止解析出错

- parseFloat（）的解析顺序是怎样的？

  - 从位置 0 开始检测每个字符

  - 解析到字符串末尾或者

    解析到一个无效的浮点数值字符为止

- parseFloat（）如何判断字符串中的小数点是否有效？

  - 第一次出现的小数点有效
  - 第二次出现的小数点无效
    - 此时字符串剩余字符会被忽略
    - 因此“22.34.5”会被转换成 22.34

- parseFloat（）的特点是什么？

  - 忽略字符串开头的 0

  - 只解析十进制

    - 因此不能指定底数

  - 十六进制数值始终会返回 0

  - 如果字符串表示整数（没有小数点或者小数点后只有一个零）

    则返回整数

  ```
  let num1 = parseFloat("1234blue"); // 1234, 按整数解析
  let num2 = parseFloat("0xA"); // 0
  let num3 = parseFloat("22.5"); // 22.5
  let num4 = parseFloat("22.34.5"); // 22.34
  let num5 = parseFloat("0908.5"); // 908.5
  let num6 = parseFloat("3.125e7"); // 31250000
  ```

### 3.4.6 String 类型

- String（字符串）数据类型表示什么序列？

  - 表示零或多个 16 位 Unicode 字符序列

- 字符串可以使用什么符号标示？

  - 双引号（“）
  - 单引号（‘）
  - 反引号（`）

  ```
  let firstName = "John";
  let lastName = 'Jacob';
  let lastName = `Jingleheimerschmidt`;
  ```

- ECMAScript 语法中表示字符串的引号有区别吗？

  - 没有区别

- 用某种引号作为字符串开头时，需要注意什么？

  - 必须用该种引号作为字符串结尾

    ```
    let firstName = 'Nicholas"; // 语法错误：开头和结尾的引号必须时同一种
    ```

#### 1. 字符字面量

- 字符串数据类型中的字符字面量是用来做什么的？

  - 用来表示

    - 非打印字符

    - 有其它用途的字符

| 字面量 | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| \n     | 换行                                                         |
| \t     | 制表                                                         |
| \b     | 退格                                                         |
| \r     | 回车                                                         |
| \f     | 换页                                                         |
| \\\    | 反斜杠（ \ ）                                                |
| \\'    | 单引号（ ' ），在字符串以单引号标示时使用，例如 'He said,  \\'hey.\\' ' |
| \\"    | 双引号（ ” ）                                                |
| \\`    | 反引号（ ` ）                                                |
| \xnn   | 以十六进制编码 nn 表示的字符（其中 n 是十六进制数字0~F），例如\x41等于“A” |
| \unnnn | 以十六进制编码 nnnn 表示的 Unicode 字符（其中 n 是十六进制数字0~F） |

- 字符字面量有哪些特点？

  - 可以出现在字符串中的任意位置

  - 只算一个字符

    ```
    let text = "This is the letter sigma: \u03a3.";
    ```

    - 变量 text 仍然是 28 个字符长

- 如何获取字符串的长度？

  - 通过字符串的 length 属性

    ```
    console.log(text.length); // 28
    ```

    - 这个属性返回字符串中 16 位字符的个数

#### 2. 字符串的特点

- 字符串的值一旦创建，还能不能改变？

  - 不能
    - ECMAScript 中的字符串是不可变的

- 如何修改某个变量中的字符串值？

  - 先销毁原始的字符串

  - 然后将包含新值的另一个字符串

    保存到该变量

    - 这是早期的浏览器拼接字符串时非常慢的原因

- 下面的代码执行时，后台发生了什么？

  ```
  let lang = "Java";
  lang = lang + "Script";
  ```

  - 首先分配一个容纳 10 个字符的空间

  - 然后填充上 “Java” 和 “Script”

  - 最后销毁原始的字符串 “Java” 和字符串 “Script”

    因为这两个字符串都没有用了

#### 3. 转换为字符串

- 把一个值转换为一个字符串有哪两种方式？

  - 用 toString（）方法

  - 用加号操作符

    - 给一个值加上一个空字符串”“

- toString（）方法唯一的用途是什么？

  - 返回当前值的字符串等价物

    ```
    let age = 11;
    let ageAsString = age.toString(); // 字符串“11”
    let found = true;
    let foundAsString = found.toString(); // 字符串“true”
    ```

- toString（）方法可见于哪些值？

  - 数值
  - 布尔值
  - 对象
    - 普通对象默认转化为"[object, Object]"
    - null转化为"[object Null]"
  - 字符串值

- 哪些值没有 toString（）方法？

  - null
  - undefined

- toString（）方法的参数是用来做什么的？

  - 用来表示以什么底数来输出数值的字符串

  - 默认情况下，toString（）返回数值的十进制字符表示

    ```
    let num = 10;
    console.log(num.toString()); // "10"
    console.log(num.toString(2)); // "1010"
    console.log(num.toString(8)); // "12"
    console.log(num.toString(10)); // "10"
    console.log(num.toString(16)); // "a"
    ```

- 如何确定一个值是不是 null 或 undefined ？

  - 使用 String（）转型函数

- String（）函数遵循哪些规则？

  - 如果值有 toString（）方法

    - 则调用该方法（不传参数）

      并返回结果

  - 如果值是 null，

    - 返回 “null”

  - 如果值是 undefined，
  
    - 返回“undefined”
  
    ```
    let value1 = 10;
    let value2 = true;
    let value3 = null;
    let value4;
    console.log(String(value1)); // "10"
    console.log(String(value2)); // "true"
    console.log(String(value3)); // "null"
    console.log(String(value4)); // "undefined"
    ```

#### 4.模板字面量

- 模板字面量的特点？

  - 保留换行字符

  - 可以跨行定义字符

    ```
    let myMultiLineString = 'first line\nsecond line';
    let myMultiLineTemplateLiteral = `first line
    second line`;
    console.log(myMultiLineString);
    // first line
    // second line
    console.log(myMultiLineTemplateLiteral);
    // first line
    // second line
    console.log(myMultiLineString === myMultiLineTemplateLiteral); // true
    ```

- 模板字面量在什么情况下特别有用？

  - 定义模板时

    ```
    let pageHTML = `
    <div>
    	<a href="#">
    		<span>Jake</span>
    	</a>
    </div>`;
    ```

- 使用模板字面量要注意什么？

  - 格式正确的模板字符串

    看起来可能会缩进不当

    - 因为模板字面量会保持反引号内部的空格

    ```
    // 这个模板字面量在换行符之后有25个空格符
    let myTemplateLiteral = `first line
    						 second line`;
    console.log(myTemplateLiteral.length); // 47
    
    // 这个模板字面量以一个换行符开头
    let secondTemplateLiteral = `
    first line
    second line`;
    console.log(secondTemplateLiteral[0] === '\n'); // true
    
    // 这个模板字面量没有意料之外的字符
    let thirdTemplateLiteral = `first line
    second line`;
    console.log(thirdTemplateLiteral);
    //first line
    //second line
    ```

#### 5. 字符串插值

- 字符串插值是什么意思？

  - 可以在一个连续定义中

    插入一个或多个值

- 从技术上讲，模板字面量是什么？

  - 是一种特殊的 JS 句法表达式

    求值后得到字符串

- 模板字面量的原理是什么？

  - 立即求值

    并转换为字符串实例

- 任何插入的变量从哪里取值？
  - 从最接近的作用域中取值

- 如何实现字符串插值？

  - 通过在 ${}中使用一个 JS 表达式实现

    ```
    let value = 5;
    let exponent = 'second';
    // 以前，字符串插值是这样实现的
    let interpolatedString =
        value + ' to the ' + exponent + ' power is ' + (value * value);
    // 现在，可以用模板字面量这样实现：
    let interpolatedTemplateLiteral =
        `${value} to the ${exponent} power is ${value * value}`;
    console.log(interpolatedString); // 5 to the second power is 25
    console.log(interpolatedTemplateLiteral); // 5 to the second power is 25
    ```

- 字符串插值有哪些特点？

  - 所有插入的值都使用 toString（）强制转型为字符串

    ```
    let foo = {toString: () => 'World'};
    console.log(`Hello, ${foo}!`); // Hello World!
    ```

  - 任何 JS 表达式都可以用于插值

  - 嵌套的模板字符串无须转义

  ```
  console.log(`Hello, ${`World`}!`); // Hello, World!
  ```

  - 模板可以插入自己之前的值

  ```
  let value = '';
  function append() {
  	value = `${value}abc`;
  	console.log(value);
  }
  append(); // abc
  append(); // abcabc
  append(); // abcabcabc
  ```

#### 6. 模板字面量标签函数

- 标签函数可以用来干什么？
  - 用来自定义插值行为
- 标签函数接收到的参数依次是什么？
  - 原始字符串数组
  - 每个表达式求值的结果

- 标签函数的返回值是什么？

  - 对模板字面量求值

    得到的字符串

- 标签函数的例子

  ```
  let a = 6;
  let b = 9;
  
  function simpleTag(strings, aValExpression, bValExpression, sumExpression) {
      console.log(strings);
      console.log(aValExpression);
      console.log(bValExpression);
      console.log(sumExpression);
      return 'foobar';
  }
  let untaggedResult = `${a} + ${b} = ${a + b}`;
  let taggedResult = simpleTag `${a} + ${b} = ${a + b}`;
  // ["", " + ", " = ", ""]
  // 6
  // 9
  // 15
  console.log(untaggedResult); // "6 + 9 = 15"
  console.log(taggedResult); // "foobar"
  ```

- 表达式参数的数量是可变的，如何将参数收集到一个数组中？

  - 使用剩余操作符（...）

  ```
  let a = 6;
  let b = 9;
  
  function simpleTag(strings, ...expressions) {
      console.log(strings);
      for (const expression of expressions) {
          console.log(expression);
      }
      return 'foobar';
  }
  let untaggedResult = `${a} + ${b} = ${a + b}`;
  let taggedResult = simpleTag `${a} + ${b} = ${a + b}`;
  // ["", " + ", " = ", ""]
  // 6
  // 9
  // 15
  console.log(untaggedResult); // "6 + 9 = 15"
  console.log(taggedResult); // "foobar"
  ```

- 对于有 n 个插值的模板字面量，

  传给标签函数的表达式参数个数是多少？

  传给标签函数第一个参数所包含的字符串个数是多少？

  - 表达式参数个数是 n
  - 第一个参数所包含的字符串个数是 n + 1

- 如何把原始字符串和

  对表达式求值的结果

  拼接起来

  作为默认返回的字符串？

  ```
  let a = 6;
  let b = 9;
  
  function zipTag(strings, ...expressions) {
      return strings[0] +
          expressions.map((e, i) => `${e}${strings[i + 1]}`)
          .join('');
  }
  let untaggedResult = `${a} + ${b} = ${a + b}`;
  let taggedResult = zipTag `${a} + ${b} = ${a + b}`;
  console.log(untaggedResult); // 6 + 9 = 15
  console.log(taggedResult); // 6 + 9 = 15
  ```

#### 7. 原始字符串

- 如何使用模板字面量

  直接获取原始的模板字面量内容（如换行符或Unicode字符）

  而不是转换后的字符？

  - 使用默认的 String.raw 标签函数

    ```
    // Unicode示例
    // \u00A9 是版权符号
    console.log(`\u00A9`); // ©
    console.log(String.raw `\u00A9`); // \u00A9
    
    // 换行符示例
    // first line
    // second line
    console.log(`first line\nsecond line`);
    
    // "first line\nsecond line"
    console.log(String.raw `first line\nsecond line`);
    
    // 对实际的换行符是不行的
    // 它们不会被转换成转义序列的形式
    console.log(`first line
    second line`);
    // first line
    // second line
    
    console.log(String.raw `first line
    second line`);
    // first line
    // second line
    ```
  
  - 也可以通过标签函数的第一个参数
  
    即字符串数组的 .raw 属性
  
    取得每个字符串的原始内容
  
  ```
  function printRaw(strings) {
      console.log('Actual characters:');
      for (const string of strings) {
          console.log(string);
      }
      console.log('Escaped characters:');
      for (const rawString of strings.raw) {
          console.log(rawString);
      }
  }
  printRaw `\u00A9${'and'}\n`;
  // Actual characters:
  // ©
  // (换行符)
  // Escaped characters:
  // \u00A9
  // \n
  ```

### 3.4.7 Symbol 类型

- 符号（Symbol）的特点是什么？

  - 符号是原始值
  - 符号实例唯一，不可变

- 创建符号的目的是什么？

  - 确保对象属性使用唯一标识符

    不会发生属性冲突的危险

- 符号是用来做什么的？

  - 用来创建唯一记号

    用作非字符串形式的对象属性

#### 1. 符号的基本用法

- 如何初始化一个符号？

  - 使用 Symbol（）函数初始化

- typeof 操作符对符号返回什么？

  - symbol

    - 因为符号本身是原始类型

    ```
    let sym = Symbol();
    console.log(typeof sym); // symbol
    ```

- Symbol（）函数的参数是什么数据类型，用来做什么的？

  - 字符串

  - 用来作为对符号的描述

    将来通过这个字符串来调试代码

- Symbol（）的参数与符号定义或标识有关吗？

  - 完全无关

    ```
    let genericSymbol = Symbol();
    let otherGenericSymbol = Synbol();
    let fooSymbol = Symbol('foo');
    let otherFooSymbol = Symbol('foo');
    console.log(genericSymbol == otherFooSymbol); // false
    console.log(fooSymbol == otherFooSymbol); // false
    ```

- 符号是否有字面量语法？

  - 没有
    - 这是符号发挥作用的关键

- 如何保证创建的属性

  不会覆盖已有的对象属性

  （无论是符号属性还是字符串属性）？

  - 创建 Symbol（）实例

    并将其用作对象的新属性

    ```
    let genericSymbol = Symbol();
    console.log(genericSymbol); // Symbol()
    let fooSymbol = Symbol('foo');
    console.log(fooSymbol); // Symbol(foo)
    ```

- 为什么Symbol（）函数不能与 new 关键字一起作为构造函数使用？

  - 为了避免创建符号包装对象

- 什么类型支持构造函数

  且可用于初始化包含原始值的包装对象？

  - Boolean

  - String

  - Number

    ```
    let myBoolean = new Boolean();
    console.log(typeof myBoolean); // "object"
    
    let myString = new String();
    console.log(typeof myString); // "object"
    
    let myNumber = new Number();
    console.log(typeof myNumber); // "object"
    
    let mySymbol = new Symbol(); // TypeError: Symbol is not a constructor
    ```

- 如何使用符号包装对象？

  - 使用 Object（）函数

  ```
  let mySymbol = Symbol();
  let myWrappedSymbol = Object(mySymbol);
  console.log(typeof myWrappedSymbol); // "object"
  ```

#### 2. 使用全局符号注册表

- 如何实现在运行时的不同部分

  共享和重用符号实例？

  - 使用 Symbol.for（）方法

    - 用一个字符串作为键

    - 在全局符号注册表中创建

      并重用符号

  ```
  let fooGlobalSymbol = Symbol.for('foo');
  console.log(typeof fooGlobalSymbol); // symbol
  ```

- Symbol.for（）方法的原理是什么？
  - 对每个字符串键都执行幂等操作

- 第一次使用某个字符串调用时，Symbol.for（）方法会做什么？

  - 会检查全局运行时注册表
  - 发现不存在对应的符号
    - 于是生成一个新符号实例
    - 并把该符号实例添加到注册表中

  ```
  let fooGlobalSymbol = Symbol.for('foo'); // 创建新符号
  let otherFooGlobalSymbol = Symbol.for('foo'); // 重用已有符号
  console.log(fooGlobalSymbol === otherFooGlobalSymbol); // true
  ```

- 如果采用相同的符号描述，

  在全局注册表中定义的符号跟

  使用 Symbol（）定义的符号就相同吗？

  - 不相同

  ```
  let localSymbol = Symbol('foo');
  let globalSymbol = Symbol.for('foo');
  console.log(localSymbol === globalSymbol); // false
  ```

- 为什么作为参数传给 Symbol.for() 的任何值

  都会被转换为字符串？

  - 因为创建全局注册表中的符号

    必须使用字符串键来创建

- 注册表中使用的键同时也会被用作什么？

  - 符号描述

  ```
  let emptyGlobalSymbol = Symbol.for();
  console.log(emptyGlobalSymbol); // Symbol(undefined)
  ```

- 如何查询全局注册表？

  - 使用 Symbol.keyFor（）

- Symbol.keyFor() 返回什么？

  - 返回该全局符号对应的字符串键
  - 如果查询的不是全局符号
    - 则返回 undefined

  ```
  // 创建全局符号
  let s = Symbol.for('foo');
  console.log(Symbol.keyFor(s)); // foo
  // 创建普通符号
  let s2 = Symbol('bar');
  console.log(Symbol.keyFor(s2)); // undefined
  ```

  - 如果传给 Symbol.keyFor() 的不是符号，

    则该方法抛出 TypeError

    ```
    Symbol.keyFor(123); // TypeError: 123 is not a symbol
    ```

#### 3. 使用符号作为属性

- 哪些地方可以使用符号？

  - 凡是可以使用字符串或数值

    作为属性的地方

    - 包括了对象字面量属性和 

      Object.defineProperty()/

      Object.defineProperties() 定义的属性

- 对象字面量只能在什么情况中使用符号作为属性？

  - 在计算属性语法中

    ```
    let s1 = Symbol('foo'),
        s2 = Symbol('bar'),
        s3 = Symbol('baz'),
        s4 = Symbol('qux');
    let o = {
        [s1]: 'foo val'
    };
    // 这样也可以： o[s1] = 'foo val'
    console.log(o);
    //Symbol(foo): foo val
    
    Object.definedProperty(o, s2, {
        value: 'bar val'
    });
    console.log(o);
    // {Symbol(foo): foo val, Symbol(bar): bar val}
    Object.defineProperties(o, {
        [s3]: {
            value: 'baz val'
        },
        [s4]: {
            value: 'qux val'
        }
    });
    console.log(o);
    // {Symbol(foo): foo val, Symbol(bar): bar val,
    // Symbol(baz): baz val, Symbol(qux): qux val}
    ```

- Object.getOwnPropertyNames() 返回什么？

  - 返回对象实例的常规属性数组

- Object.getOwnPropertySymbols() 返回什么？

  - 返回对象实例的符号属性数组

- Object.getOwnPropertyNames() 和 

  Object.getOwnPropertySymbols() 的返回值之间有什么关系？

  - 两个方法的返回值彼此互斥

- Object.getOwnPropertyDescriptors() 会返回什么？

  - 会返回同时包含

    常规属性和

    符号属性描述符

    的对象

- Reflect.ownKeys() 会返回哪两种类型的键？

  - 常规类型
  - 符号类型

- ```
  let s1 = Symbol('foo'),
      s2 = Symbol('bar');
  
  let o = {
      [s1]: 'foo val',
      [s2]: 'bar val',
      baz: 'baz val',
      qux: 'qux val'
  };
  // [Symbol(foo), Symbol(bar)]
  console.log(Object.getOwnPropertySymbols(o));
  
  // ["baz", "qux"]
  console.log(Object.getOwnPropertyNames(o));
  
  // {baz: {...}, qux: {...}, Symbol(foo): {...}, Symbol(bar): {...}}
  console.log(Object.getOwnPropertyDescriptors(o));
  
  // ["baz", "qux", Symbol(foo), Symbol(qux)]
  console.log(Reflect.ownKeys(o));
  ```

- 为什么直接创建并用作属性的符号不会丢失？

  - 因为符号属性是

    对内存中符号

    的一个引用

- 如果没有显式地保存对这些属性的引用，

  要怎么做才能找到相应的属性键？

  - 必须遍历对象的所有符号属性

```
let o = {
    [Symbol('foo')]: 'foo val',
    [Symbol('bar')]: 'bar val'
};

// {Symbol(foo): "foo val", Symbol(bar): "bar val"}
console.log(o);

let barSymbol = Object.getOwnPropertySymbols(o)
    .find((symbol) => symbol.toString().match(/bar/));

// Symbol(bar)
console.log(barSymbol);
```

#### 4. 常用内置符号

- 常用内置符号用来做什么？
  - 用来暴露语言内部行为
    - 开发者可以直接访问、重写或模拟这些行为
  
- 这些内置符号都以什么形式存在？
  - 以 Symbol工厂函数的

    字符串属性
  
    的形式存在
  
- 常用内置符号最重要的用途之一是什么？

  - 重新定义常用内置符号

    从而改变原生结构的行为

- 已知 for-of 循环会在相关对象上使用 Symbol.iterator 属性，

  如何改变 for-of 在迭代该对象时的行为？

  - 通过修改在自定义对象上 Symbol.iterator 的值

- 内置符号是什么？

  - 是一个全局函数 Symbol 的普通字符串属性
    - 这个属性指向一个符号的实例

- 内置符号属性的特点有哪些？
  - 不可写
  - 不可枚举
  - 不可配置
  
- 引用符号在规范中的名称有什么特点？
  - 前缀为 @@
    - 比如，@@iterator 指的就是 Symbol.iterator

#### 5. Symbol.asyncIterator

-  Symbol.asyncIterator符号表示什么？
  
  - 该符号作为一个属性
  
    表示一个实现异步迭代器 API 的函数
  
- Symbol.asyncIterator 符号表示的函数返回什么？
  - 返回对象默认的 AsyncIterator

- Symbol.asyncIterator符号由什么语句使用？

  - 由 for-await-of 语句使用

- for-await-of 循环会利用这个函数执行什么操作？

  - 异步迭代操作

- for-await-of 循环原理是什么？

  - 会调用以 Symbol.asyncIterator 为键的函数

  - 并期望这个函数返回一个

    实现迭代器 API 的对象

  - 返回的对象是

    实现该 API 的 AsyncIterator

  ```
  class Foo {
      async *[Symbol.asyncIterator]() {}
  }
  let f = new Foo();
  
  // AsyncGenerator {<suspended>}
  console.log(f[Symbol.asyncIterator]());
  ```

- 技术上，这个由 Symbol.asyncIterator 函数生成的对象

  应该如何返回 Promise 实例？

  - 可以通过显示地调用 next() 方法返回

  - 也可以隐式地通过异步生成器函数返回

  ```
  class Emitter {
      constructor(max) {
          this.max = max;
          this.asyncIdx = 0;
      }
      async *[Symbol.asyncIterator]() {
          while (this.asyncIdx < this.max) {
              yield new Promise((resolve) => resolve(this.asyncIdx++));
          }
      }
  }
  async function asyncCount() {
      let emitter = new Emitter(5);
      for await (const x of emitter) {
          console.log(x);
      }
  }
  asyncCount();
  // 0
  // 1
  // 2
  // 3
  // 4
  ```

#### 6. Symbol.hasInstance

- Symbol.hasInstance 符号是什么？

  - 该符号作为一个属性表示一个方法

    - 该方法决定一个构造器对象

      是否认可一个对象

      是它的实例

- Symbol.hasInstance符号由什么操作符使用？
  - instanceof 操作符

- instanceof 操作符可以用来做什么？
  - 用来确定

    一个对象实例的原型链上
  
    是否有原型
  
- instanceof 的典型使用场景是什么？

  - 如下

    ```
    function Foo() {}
    let f = new Foo();
    console.log(f instanceof Foo); // true
    
    class Bar {}
    let b = new Bar();
    console.log(b instanceof Bar); // true
    ```

- 在 ES6 中，instanceof 操作符会使用什么为键的函数？
  -  Symbol.hasInstance 为键的函数
  
- instanceof 操作符 和 Symbol.hasInstance 函数执行时的异同？

  - 会执行同样的操作
  - 操作数对调

  ```
  function Foo() {}
  let f = new Foo();
  console.log(Foo[Symbol.hasInstance](f)); // true
  
  class Bar {}
  let b = new Bar();
  console.log(Bar[Symbol.hasInstance](b)); // true
  ```

- Symbol.hasInstance属性是否在所有函数和类上都可以调用？

  - 是
    - 因为Symbol.hasInstance属性定义在 Function 的原型上

-  instanceof 操作符的原理是什么？

  - instanceof 会在原型链上

    寻找 Symbol.hasInstance 属性定义

    就跟在原型链上寻找其它属性一样

- 如何重新定义Symbol.hasInstance函数？

  - 可以在继承的类上

    通过静态方法

    重新定义这个函数

  ```
  class Bar {}
  class Baz extends Bar {
      static[Symbol.hasInstance]() {
          return false;
      }
  }
  let b = new Baz();
  console.log(Bar[Symbol.hasInstance](b)); // true
  console.log(b instanceof Bar); // true
  console.log(Baz[Symbol.hasInstance](b)); // false
  console.log(b instanceof Baz); // false
  ```

#### 7. Symbol.isConcatSpreadable

- Symbol.isConcatSpreadable符号是什么？

  - 该符号作为一个属性表示一个布尔值

- 如果Symbol.isConcatSpreadable符号是 true 或 false 时，分别表示什么？

  - true 表示对象应该用 Array.prototype.concat()

    打平其数组元素

  - false 表示整个对象被追加到数组末尾

-  Array.prototype.concat()方法的行为是什么？

  - 根据接收到的对象类型

    选择如何将一个类数组对象

    拼接成数组实例

- 如何修改 Array.prototype.concat()方法的行为？

  - 修改 Symbol.isConcatSpreadable 的值

    可以修改该行为

- 数组对象和类数组对象默认情况下有什么区别？
  - 数组对象：被打平到已有的数组
  - 类数组对象：被追加到数组末尾

- 不是类数组对象的对象在 Symbol.isConcatSpreadable 为 true 时会怎么样？

  - 该对象会被忽略

  ```
  let initial = ['foo'];
  let array = ['bar'];
  console.log(array[Symbol.isConcatSpreadable]); // undefined
  console.log(initial.concat(array)); // ['foo', 'bar']
  array[Symbol.isConcatSpreadable] = false;
  console.log(initial.concat(array)); // ['foo', Array(1)]
  ```

  ```
  let arrayLikedObject = {
      length: 1,
      0: 'baz'
  };
  console.log(arrayLikedObject[Symbol.isConcatSpreadable]); // undefined
  console.log(initial.concat(arrayLikedObject)); // ['foo', {...}]
  arrayLikedObject[Symbol.isConcatSpreadable] = true;
  console.log(initial.concat(arrayLikedObject)); // ['foo', 'baz']
  
  let otherObject = new Set().add('qux');
  console.log(otherObject[Symbol.isConcatSpreadable]); // undefined
  console.log(initial.concat(otherObject)); // ['foo', Set(1)]
  otherObject[Symbol.isConcatSpreadable] = true;
  console.log(initial.concat(otherObject)); // ['foo']
  ```

#### 8. Symbol.iterator

- Symbol.iterator 符号表示的是什么？

  - 表示一个实现迭代器 API 的函数

- Symbol.iterator 符号表示的函数返回什么？

  - 返回对象默认的迭代器

- Symbol.iterator 符号表示的函数由什么语句使用？

  - 由 for-of 语句使用

- for-of 循环会利用这个函数执行什么操作？

  - 执行迭代操作

- for-of 循环的原理是什么？

  - 调用以Symbol.iterator 为键的函数，

  - 并默认这个函数会返回

    一个实现迭代器 API 的对象

  - 返回的对象是实现该 API 的Generator

```
class Foo {
    *[Symbol.iterator]() {}
}
let f = new Foo();
console.log(f[Symbol.iterator]()); // Generator {<suspend>}
```

- 技术上，这个由 Symbol.iterator 函数生成的对象

  应该通过什么方式陆续返回值？

  - 通过显式地调用 next（）方法返回
  - 隐式地通过生成器函数返回

  ```
  class Emitter {
      constructor(max) {
              this.max = max;
              this.idx = 0;
          }
          *[Symbol.iterator]() {
              while (this.idx < this.max) {
                  yield this.idx++;
              }
          }
  }
  
  function count() {
      let emitter = new Emitter(5);
      for (const x of emitter) {
          console.log(x);
      }
  }
  count();
  // 0
  // 1
  // 2
  // 3
  // 4
  ```

#### 9. Symbol.match

- 以 Symbol.match 为键的函数是一个什么方法？
  - 是一个正则表达式方法
- 以 Symbol.match 为键的函数用来做什么？
  - 用正则表达式去匹配字符串

- 以 Symbol.match 为键的函数由谁使用？
  - 由String.prototype.match()方法使用
- String.prototype.match()方法的原理是什么？
  - 会使用以 Symbol.match 为键的函数来对正则表达式求值

- 以 Symbol.match 为键的函数定义在哪里？

  - 正则表达式的原型上

- String.prototype.match() 方法的有效参数是什么？

  - 所有正则表达式实例

    ```
    console.log(RegExp.prototype[Symbol.match]);
    // ƒ [Symbol.match]() { [native code] }
    
    console.log('foobar'.match(/bar/));
    // ["bar", index: 3, input: "foobar", groups: undefined]
    ```

- 给 String.prototype.match() 方法传入非正则表达式值会导致什么？

  - 非正则表达式值

    会被转换为 RegExp 对象

- 如何让 String.prototype.match() 方法 直接使用非正则表达式实例？

  - 重新定义 Symbol.match 函数

- Symbol.match 函数接收一个什么参数？

  - 调用 match（）方法的字符串实例

- Symbol.match 函数返回值有什么限制？

  - 没有限制

  ```
  class FooMatcher {
      static[Symbol.match](target) {
          return target.includes('foo');
      }
  }
  console.log('foobar'.match(FooMatcher)); // true
  console.log('barbaz'.match(FooMatcher)); // false
  class StringMatcher {
      constructor(str) {
              this.str = str;
          }
          [Symbol.match](target) {
              return target.includes(this.str);
          }
  }
  console.log('foobar'.match(new StringMatcher('foo'))); // true
  console.log('barbaz'.match(new StringMatcher('qux'))); // false 
  ```

#### 10. Symbol.replace

- 以 Symbol.replace为键的函数是用来做什么的？

  - 用来替换

    一个字符串中匹配的子串

- 以 Symbol.replace为键的函数由谁使用？

  - 由 String.prototype.replace() 方法使用

-  String.prototype.replace() 方法的原理是什么？

  - 使用以 Symbol.replace为键的函数

    来对正则表达式求值

- 以 Symbol.replace为键的函数定义在哪里？
  - 正则表达式的原型上
- 以 Symbol.replace为键的函数的有效参数是什么？
  - 所有正则表达式

```
console.log(RegExp.prototype[Symbol.replace]);
// ƒ [Symbol.replace]() { [native code] }
console.log('foobarbaz'.replace(/bar/, 'qux'));
// fooquxbaz
```

- 给以 Symbol.replace为键的函数传入非正则表达式值会导致什么？
  - 导致该非正则表达式值被转换为 RegExp 对象
- 如何让以 Symbol.replace为键的函数直接使用参数？
  - 重新定义 Symbol.replace 函数
-  Symbol.replace 函数接收哪两个参数？
  - 调用 replace（）方法的字符串实例（target）
  - 替换字符串（replacement）

- Symbol.replace 函数返回的值是否有限制？

  - 没有限制

  ```
  class FooReplacer {
      static [Symbol.replace](target, replacement) {
          return target.split('foo').join(replacement);
      }
  }
  console.log('barfoobaz'.replace(FooReplacer, 'qux'));
  // barquxbaz
  
  class StringReplacer {
      constructor(str) {
          this.str = str
      }
      [Symbol.replace](target, replacement) {
          return target.split(this.str).join(replacement);
      }
  }
  console.log('barfoobaz'.replace(new StringReplacer('foo'), 'qux'));
  // barfoobaz
  ```

#### 11. Symbol.search

- 以Symbol.search为键的函数返回什么？

  - 返回字符串中匹配正则表达式的索引

- 以Symbol.search为键的函数由谁使用？

  - 由 String.prototype.search() 方法使用

-  String.prototype.search() 方法的原理是什么

  - 使用以Symbol.search为键的函数

    来对正则表达式求值

- 以 Symbol.replace为键的函数定义在哪里？
  - 正则表达式的原型上
- 以 Symbol.replace为键的函数的有效参数是什么？
  - 所有正则表达式

```
console.log(RegExp.prototype[Symbol.search]);
// ƒ [Symbol.search]() { [native code] }
console.log('foobar'.search(/bar/));
// 3
```

- 给以 Symbol.replace为键的函数传入非正则表达式值会导致什么？
  - 导致该非正则表达式值被转换为 RegExp 对象
- 如何让以 Symbol.replace为键的函数直接使用参数？
  - 重新定义 Symbol.replace 函数
-  Symbol.replace 函数接收哪一个参数？
  - 调用 replace（）方法的字符串实例

- Symbol.replace 函数返回的值是否有限制？
  - 没有限制

```
class FooSearcher {
    static[Symbol.search](target) {
        return target.indexof('foo');
    }
}
console.log('foobar'.search(FooSearcher)); // 0
console.log('barfoo'.search(FooSearcher)); // 3
console.log('barbaz'.search(FooSearcher)); // -1
class StringSearcher {
    constructor(str) {
            this.str = str;
        }
        [Symbol.search](target) {
            return target.indexof(this.str);
        }
}
console.log('foobar'.search(new StringSearcher('foo'))); // 0
console.log('barfoo'.search(new StringSearcher('foo'))); // 3
console.log('barbaz'.search(new StringSearcher('qux'))); // -1
```

#### 12. Symbol.species

- 以 Symbol.species 为键的函数是用来做什么的？

  - 该函数作为创建派生对象的构造函数

  - 用来对内置类型实例方法的返回值

    暴露实例化派生对象的方法

- 以 Symbol.species 为键的函数在哪里最常用？

  - 在内置类型中最常用

- 使用 Symbol.species 可以做什么？

  - 定义静态的获取器（getter）方法

    可以覆盖新创建实例的原型定义 

```
class Bar extends Array {}
class Baz extends Array {
    static get[Symbol.species]() {
        return Array;
    }
}
let bar = new Bar();
console.log(bar instanceof Array); // true
console.log(bar instanceof Bar); // true
bar = bar.concat('bar');
console.log(bar instanceof Array); // true
console.log(bar instanceof Bar); // true
let baz = new Baz();
console.log(baz instanceof Array); // true
console.log(baz instanceof Baz); // false
```

#### 13. Symbol.split

- 以Symbol.split为键的函数用来做什么的？

  - 用来在匹配表达式的索引位置

    拆分字符串

- 以Symbol.split为键的函数由谁使用？

  - String.prototype.split() 方法使用

- String.prototype.split() 方法的原理是什么

  - 使用以Symbol.split为键的函数

    来对正则表达式求值

- 以 Symbol.split为键的函数定义在哪里？
  - 正则表达式的原型上
- 以 Symbol.split为键的函数的有效参数是什么？
  - 所有正则表达式

```
console.log(RegExp.prototype[Symbol.split]);
// ƒ [Symbol.split]() { [native code] }
console.log('foobarbaz'.split(/bar/));
// ['foo', 'baz']
```

- 给以 Symbol.split为键的函数传入非正则表达式值会导致什么？
  - 导致该非正则表达式值被转换为 RegExp 对象
- 如何让以 Symbol.split为键的函数直接使用参数？
  - 重新定义 Symbol.split函数
-  Symbol.split函数接收哪一个参数？
  - 调用 split（）方法的字符串实例

- Symbol.split函数返回的值是否有限制？
  - 没有限制

```
class FooSplitter {
    static[Symbol.split](target) {
        return target.split('foo');
    }
}
console.log('barfoobaz'.split(FooSplitter));
// ['bar', 'baz']
class StringSplitter {
    constructor(str) {
            this.str = str;
        }
        [Symbol.split](target) {
            return target.split(this.str);
        }
}
console.log('barfoobaz'.split(new StringSplitter('foo')));
// ['bar', 'baz']
```

#### 14. Symbol.toPrimitive

- 以Symbol.toPrimitive为键的函数是用来做什么的？

  - 用来将对象转换为相应的原始值

- 以Symbol.toPrimitive为键的函数由谁使用？

  - 由 ToPrimitive抽象操作使用

- 很多内置操作都会强制对一个对象做什么？

  - 将对象转换为原始值
    - 包括字符串、数值、未指定的原始类型

- 如何改变将对象转换为原始值这种默认行为？

  - 对于一个自定义对象

    通过在这个实例的Symbol.toPrimitive属性上

    定义一个函数

```
class Foo {}
let foo = new Foo();
console.log(3 + foo); // 3[object Object]
console.log(3 - foo); // NaN
console.log(String(foo)); // [object Object]
class Bar {
    constructor() {
        this[Symbol.toPrimitive] = function (hint) {
            switch (hint) {
                case 'number':
                    return 3;
                case 'string':
                    return 'string bar';
                case 'default':
                default:
                    return 'default bar';
            }
        }
    }
}
let bar = new Bar();
console.log(3 + bar); // 3default bar
console.log(3 - bar); // 0
console.log(String(bar)); // string bar
```

#### 15. Symbol.toStringTag

- Symbol.toStringTag表示一个什么？

  - 作为一个属性

    表示一个字符串

- 以Symbol.toStringTag为键的字符串是用来做什么的？

  - 用来创建对象的默认字符串描述

- 以Symbol.toStringTag为键的字符串由谁使用？

  - 由 内置方法Object.prototype.toString() 使用

-  内置方法Object.prototype.toString() 的原理是什么？

  - 该方法会检索由 Symbol.toStringTag 指定的实例标识符

- 由 Symbol.toStringTag 指定的实例标识符默认为什么？

  - “Object”

- 内置类型已经指定了Symbol.toStringTag ，

  自定义类实例是否也指定了？

  - 没有指定
    - 需要自己定义

```
let s = new Set();
console.log(s); // Set(0) {size: 0}
console.log(s.toString()); // [object Set]
console.log(s[Symbol.toStringTag]); // Set
class Foo {}
let foo = new Foo();
console.log(foo); // Foo {}
console.log(foo.toString()); // [object Object]
console.log(foo[Symbol.toStringTag]); // undefined
class Bar {
    constructor() {
        this[Symbol.toStringTag] = 'Bar';
    }
}
let bar = new Bar();
console.log(bar); // Bar {Symbol(Symbol.toStringTag): 'Bar'}
console.log(bar.toString()); // [object Bar]
console.log(bar[Symbol.toStringTag]); // Bar
```

#### 16. Symbol.unscopbles

- Symbol.unscopbles表示一个什么？

  - 一个对象

- 以Symbol.unscopbles为键的对象有什么特点？

  - 该对象所有的以及继承的属性

    都会从关联对象的with环境绑定中排除

- 如何阻止某个属性出现在with环境绑定中？

  - 设置Symbol.unscopbles符号

    并让符号映射目标属性的键值为 true

```
let o = {
    foo: 'bar'
};
with(o) {
    console.log(foo); // bar
}
o[Symbol.unscopables] = {
    foo: true
};
with(o) {
    console.log(foo); // ReferenceError: foo is not defined
}
```

- 是否推荐使用with？
  - 不推荐
- 是否推荐使用Symbol.unscopables？
  - 不推荐

### 3.4.8 Object 类型

- ECMAScript中的对象是什么？

  - 是一组数据和功能的集合

- 如何创建一个对象？

  - 通过new操作符

    后跟对象类型的名称来创建

- 如何创建自己的对象？
  - 通过创建 Object类型的实例
  - 然后再给对象添加属性和方法

```
let o = new Object();
```

- 每个Object实例都有哪些属性和方法？

  - constructor
    - 用于创建当前对象的函数

  - hasOwnProperty(propertyName)

    - 用于判断当前对象实例（不是原型）上

      是否存在给定的属性

    - 要检查的属性名必须是字符串或符号

  - isPrototypeOf(object)

    - 用于判断当前对象是否为另一个对象的原型

  - propertyIsEnumerable(propertyName)

    - 用于判断给定的属性是否可以使用 for-in 语句枚举
    - 属性名必须是字符串

  - toLocaleString()

    - 返回对象的字符串表示
    - 该字符串反映对象所在的本地化执行环境

  - toString()

    - 返回对象的字符串表示

  - valueOf()

    - 返回对象对应的字符串、数值、布尔值表示
    - 通常与 toString() 的返回值相同

- 任何一个对象是否含有object实例的属性和方法？

  - 是
    - 因为Object是所有对象的基类

- 浏览器环境中的BOM和DOM是否会继承Object？

  - 不一定

    - 因为BOM和DOM都是

      由宿主环境定义和提供的宿主对象

    - 宿主对象不受 ECMA-262 的约束

### 3.4.9 字面量

- 字面量是什么？
  - 是一种在程序中可以直接使用的数据值
    - 通常它的值是固定的
- 字面量有哪几种类型？
  - 数字字面量、
  - 字符串字面量、
  - 对象字面量
  - 等

- 字面量的例子？

```
12 //整数
1.25 //浮点数
"abc" //字符串
{num: 1} //对象
[1, 2, 3] //数组
/\d+/g  // 正则表达式
true //布尔值
```

## 3.5 操作符

- 在应用给对象时，操作符通常会调用什么方法来取得可以计算的值？
  - valueOf（）
  - toString（）

### 3.5.1 一元操作符

- 一元操作符是什么？
  - 只操作一个值的操作符

#### 1. 递增/递减操作符

- 递增和递减操作符有哪两个版本？
  - 前缀版
    - 位于要操作的变量前面
  - 后缀版
    - 位于要操作的变量后面
- 前缀递增操作符会做什么？
  - 会给数值加 1

```
let age = 29;
++age;
```

- 上述例子实际上等于如下表达式

```
let age = 29;
age = age + 1;
```

- 前缀递减操作符会做什么？
  - 从一个数值减 1
- 在计算机科学中，副作用是什么意思？
  - 变量会在语句被求值之前改变

- 前缀递增操作符和前缀递减操作符是否有副作用？
  - 有副作用

```
let age = 29;
let anotherAge = --age + 2;
console.log(age); // 28
console.log(anotherAge); // 30
```

- 前缀递增和递减在语句中的优先级有什么关系？
  - 优先级相等

- 前缀递增和递减在语句中的执行顺序是什么？
  - 从左到右依次求值
    - 因为优先级相等

```
let num1 = 2;
let num2 = 20;
let num3 = --num1 + num2;
let num4 = num1 + num2;
console.log(num3); // 21
console.log(num4); // 21
```

- 后缀版和前缀版的主要区别是什么？

  - 后缀版递增和递减

    在语句被求值后才发生

```
let num1 = 2;
let num2 = 20;
let num3 = num1-- + num2;
let num4 = num1 + num2;
console.log(num3); // 22
console.log(num4); // 21
```

- 递增和递减操作符遵循哪些规则？

  - 对于字符串

    - 如果是有效的数值形式

      则转换为数值

      再应用改变

      - 变量类型从字符串变成数值

    - 如果不是有效的数值形式，

      则将变量的值设置为 NaN

      - 变量类型从字符串变成数值

  - 对于布尔值

    - 如果是 false，

      则转换为 0

      再应用改变

      - 变量类型从布尔值变成数值

    - 如果是 true

      则转换为1

      再应用改变

      - 变量类型从布尔值变成数值

  - 对于浮点值

    - 加 1 或减 1

  - 如果是对象

    则调用其 valueOf（）方法取得可以操作的值

    - 对取得的值应用上述规则

    - 如果是 NaN，

      则调用 toString（）

      并再次应用其他规则

      - 变量类型从对象变成数值

```
let s1 = "2";
let s2 = "z";
let b = false;
let f = 1.1;
let o = {
    valueOf () {
        return -1;
    }
}
console.log(++s1); // 3
console.log(++s2); // NaN
console.log(++b); // 1
console.log(--f); // 0.10000000000000009
console.log(--o); // -2
```

- 递增运算符（++）的优先级是怎样的？
  - 高于加法运算符（＋)
- 如果把++运算符单独放在一行，它会和哪里的语句合并？
  - 会和下面的语句合并，作为一个整体被解析。

#### 2. 一元加和减

- 一元加放在变量前面会发生什么？
  - 对数值没有什么影响

```
let num = 25;
num = +num;
console.log(num); // 25
```

- 如果一元加应用到非数值，会发生什么？
  - 会执行类型转换
  - 布尔值的 false 和 true 转换为 0 和 1
  - 字符串根据特殊规则进行解析
  - 对象会调用它们的 valueOf（）和 toString（）

```
let s1 = "01";
let s2 = "1.1";
let s3 = "z";
let b = false;
let f = 1.1;
let o = {
    valueOf () {
        return -1;
    }
};
s1 = +s1; // 1
s2 = +s2; // 1.1
s3 = +s3; // NaN
b = +b; // 0
f = +f; // 1.1
o = +o // -1
```

- 一元减是用来做什么的？
  - 主要用于把数值变成负值

```
let num = 25;
num = -num;
console.log(num); // -25
```

- 一元减应用到非数值时，会遵循什么规则？
  - 遵循与一元加同样的规则
    - 先对非数值进行转换，
    - 然后再取负值

```
let s1 = "01";
let s2 = "1.1";
let s3 = "z";
let b = false;
let f = 1.1;
let o = {
    valueOf () {
        return -1;
    }
}
s1 = -s1; // -1
s2 = -s2; // -1.1
s3 = -s3; // NaN
b = -b; // 0
f = -f; // -1.1
o = -o; // 1
```

- 一元加和减操作符可以用来做什么？
  - 基本的算术
  - 数据类型转换

### 3.5.2 位操作符

- ECMAScript 中的所有数值都以什么格式存储？
  - IEEE 754 64位格式存储
- 位操作是否直接应用到 64 位表示？
  - 不直接
- 位操作是如何应用到 64 位表示的？
  - 先把数值转换为 32 位整数
  - 再进行位操作
  - 之后再把结果转换为 64 位
- 为什么对于开发者而言，好像只有 32 位整数？
  - 因为 64 位整数存储格式是不可见的
    - 因此只需要考虑 32 位整数即可
- 有符号整数的32位是怎么划分的？
  - 前 31 位表示整数值
  - 第 32 位表示数值的符号
    - 如 0 表示正，1 表示负
- 符号位是哪一位？
  - 表示数值符号的第 32 位
- 符号位的值决定了什么？
  - 数值其余部分的格式

- 正值以什么格式存储？

  - 以真正的二进制格式存储
    - 即 31 位的每一位都代表 2 的幂
      - 第一位（称为第 0 位）表示 2^0
      - 第二位表示 2^1
      - 以此类推

- 如果一个位是空的，则会怎么处理？

  - 则以 0 填充

    - 相当于忽略不计

    - 比如数值 18 的二进制格式为 10010

      - 用了 5 个有效位

        决定了实际的值

      - 其余位省略

- 负数以什么格式存储？
  - 以一种成为二补数（补码）的二进制编码存储

- 一个数值的二补数通过哪几个步骤得到？
  1. 确定绝对值的二进制表示
  2. 找到数值的一个补数
  3. 给结果加1
- 在处理有符号整数时，需要注意什么？
  - 无法访问到第 31 位

- 在把负值输出为一个二进制字符串时，会得到什么？
  - 得到一个前面加了减号的绝对值

```
let num = -18;
console.log(num.toString(2)); // "-10010"
```

- 默认情况下，ECMAScript 中的所有整数都表示为哪种数？

  - 有符号数

- 无符号数的特点是什么？

  - 第 32 位不表示符号
    - 因为只有正值
  - 无符号整数比有符号整数的范围更大
    - 因为符号位用来表示数值了

- 在对 ECMAScript 中的数值应用位操作时

  后台会发生什么转换？

  -  64 位数值会转换位 32 位数值
  - 然后执行位操作
  - 最后把结果从 32 位转换为 64 位存储起来

- 这种后台的转换会导致什么副作用？

  - 特殊值 NaN 和 Infinity 

    会在位操作中被当成 0 处理

- 如果位操作符应用到非数值，会怎么处理？

  - 首先会使用 Number（）函数

    将该值转换为数值（这个过程时自动的）

  - 然后再应用位操作

    - 最终结果是数值

#### 1. 按位非

- 按位非操作符用什么表示
  - 波浪符（~）
- 按位非操作符的作用是什么？
  - 返回数值的一补数

```
let num1 = 25; 
let num2 = ~num1; 
console.log(num2); // -26
```

- 按位非是对数值进行什么操作？
  - 对数值取反并减 1

```
let num1 = 25; 
let num2 = -num1 - 1; 
console.log(num2); // -26
```

- 为什么位操作的速度会快得多？
  - 因为位操作是在数值的底层表示上完成的

#### 2. 按位与

- 按位与操作符是用什么符号表示？

  - 和号（&）

- 本质上，按位与是什么？

  - 是将两个数的每一个位对齐

  - 然后基于真值表中的规则

    对每一位执行相应的与操作

| 第一个数值的位 | 第二个数值的位 | 结果 |
| -------------- | -------------- | ---- |
| 1              | 1              | 1    |
| 1              | 0              | 0    |
| 0              | 1              | 0    |
| 0              | 0              | 0    |

- 按位与操作的规则是什么？
  - 在两个位都是 1 时，返回 1
  - 在任何一位是 0 时返回 0

```
let result = 25 & 3;
console.log(result); // 1
```

#### 3. 按位或

- 按位或操作符用什么符号表示？
  - 管道符（|）
- 按位或遵循的真值表？

| 第一个数值的位 | 第二个数值的和 | 结果 |
| -------------- | -------------- | ---- |
| 1              | 1              | 1    |
| 1              | 0              | 1    |
| 0              | 1              | 1    |
| 0              | 0              | 0    |

- 按位或操作遵循什么规则？
  - 至少一位是 1 时返回 1
  - 两位都是 0 时返回 0

```
let result = 25 | 3;
console.log(result); // 27
```

#### 4. 按位异或

- 按位异或用什么符号表示？
  - 脱字符（^）
- 按位异或的真值表？

| 第一个数的位 | 第二个数的位 | 结果 |
| ------------ | ------------ | ---- |
| 1            | 1            | 0    |
| 1            | 0            | 1    |
| 0            | 1            | 1    |
| 0            | 0            | 0    |

- 按位异或遵循什么规则？
  - 只在一位上是 1 的时候返回 1
  - 两位都是 1 或 0 时则返回 0

```
let result = 25 ^ 3;
console.log(result); // 26
```

#### 5. 左移

- 左移操作符用什么表示？
  - 两个小于号（<<）
- 左移操作符是怎么样操作的？
  - 按照指定的位数讲数值的所有位向左移动

```
let oldValue = 2;
let newValue = oldValue << 5;
console.log(oldValue.toString(2)); // 10
console.log(newValue.toString(2)); // 1000000
```

- 左移时，右端的空位怎么处理？
  - 用 0 填充这些空位
- 左移时是否会保留它所操作数值的符号？
  - 会保留符号
    - 比如 -2 左移 5 位，将得到 -64，而不是正 64

#### 6. 有符号右移

- 有符号右移由什么符号表示？
  - 两个大于号（>>）
- 有符号右移是怎么操作的？
  - 会将数值的所有 32 位都向右移
  - 同时保留符号（正或负）
- 有符号右移和左移的关系是什么？
  - 有符号右移实际上是左移的逆运算

```
let oldValue = 64;
let newValue = oldValue >> 5;
console.log(oldValue.toString(2)); // 1000000
console.log(newValue.toString(2)); // 10
```

- 右移时，左侧的空位怎么处理？
  - 用 0 填充这些空位

#### 7. 无符号右移

- 无符号右移由什么符号表示？
  - 三个大于号（>>>）
- 无符号右移会执行什么操作？
  - 会将数值的所有 32 位都向右移
- 对于正数，无符号右移与有符号右移的结果有什么关系？
  - 两种操作结果相同

```
let oldValue = 64;
let newValue = oldValue >>> 5;
console.log(oldValue.toString(2)); // 1000000
console.log(newValue.toString(2)); // 10
```

- 对于负数，无符号右移操作符会执行什么操作？

  - 会将负数的二进制表示

    当成正数的二进制表示来处理

- 为什么负数无符号右移之后结果会变得很大？
  - 因为负数是其绝对值的二补数

```
let oldValue = -64;
let newValue = oldValue >>> 5;
console.log(oldValue.toString(2)); // -1000000
console.log(newValue.toString(2)); // 111111111111111111111111110
```

### 3.5.3 布尔操作符

- 布尔操作符一共有哪几种？
  - 逻辑非
  - 逻辑与
  - 逻辑或

#### 1. 逻辑非

- 逻辑非操作符由什么符号表示？
  - 一个叹号（!）
- 逻辑非是不是能应用给 ECMAScript 中的任何值？
  - 是
- 逻辑非操作符返回什么值？
  - 始终返回布尔值
- 逻辑非操作符会执行什么操作？
  - 首先将操作数转换为布尔值
  - 然后再对其取反
- 逻辑非操作符遵循哪些规则？
  - 对象：false
  - 字符串
    - 空字符串：true
    - 非空字符串：false
  - 数值
    - 数值 0：true
    - 非 0 数值（包括 Infinity）：false
    - NaN：true
  - null：true
  - undefined：true

```
console.log(!false); // true
console.log(!'blue'); // false
console.log(!0); // true
console.log(!NaN); // true
console.log(!''); // true
console.log(!12345); // false
```

- 逻辑非操作符是否可以把任意值转换为布尔值？

  - 是

- 逻辑非操作符在什么情况下相当于Boolean（）？

  - 同时使用两个叹号（！！）

- 两个叹号（！！）会执行什么操作？

  - 无论操作数是什么类型

    - 第一个叹号总会返回布尔值

    - 第二个叹号对该布尔值取反

      从而取得变量真正的布尔值

```
console.log(!!'blue'); // true
console.log(!!0); // false
console.log(!!NaN); // false
console.log(!!''); // false
console.log(!!12345); // true
```

#### 2. 逻辑与

- 逻辑与操作符由什么符号表示？
  - 两个和号（&&）

```
let result = true && false;
```

- 逻辑与操作符遵循如下真值表

| 第一个操作数 | 第二个操作数 | 结果  |
| ------------ | ------------ | ----- |
| true         | true         | true  |
| true         | false        | false |
| false        | true         | false |
| false        | false        | false |

- 逻辑与操作符可用于哪些类型的操作数？

  - 任何类型

- 逻辑与操作符一定返回布尔值吗？

  - 不一定
    - 当有操作数不是布尔值时，逻辑与不一定返回布尔值

- 逻辑与操作符遵循哪些规则？

  - 如果第一个操作数求值为 false，就返回第一个操作数
  - 如果第一个操作数求值为 true，返回第二个操作数
  - 如果第一个操作数是 null，则返回 null
  - 如果第一个操作数是 NaN，则返回 NaN
  - 如果第一个操作数是 undefined，则返回 undefined

- 短路操作符是什么？

  - 如果第一个操作数决定了结果

    那么永远不会对第二个操作数求值

- 为什么说逻辑与操作符是短路操作符？

  - 因为如果第一个操作数是 false

  - 那么无论第二个操作数是什么值

    结果不可能等于 true

```
let found = true;
let result = (found && someUndeclaredVariable); // 这里会出错
console.log(result); // 不会执行这一行
```

- 上面的代码为什么会出错？
  - 因为 someUndeclaredVariable 没有事先声明

```
let found = false;
let result = (found && someUndeclaredVariable); // 不会出错
console.log(result); // 会执行
```

- 为什么上述代码不会出错？
  - 因为第一个操作数是 false
    - 此时对 && 右边的操作数求值是没有意义的

- 逻辑与操作符的重要特性是什么？
  - 短路

#### 3. 逻辑或

- 逻辑或操作符由什么符号表示？
  - 两个管道符（||）

```
let result = true || false;
```

- 逻辑或操作符遵循如下真值表

| 第一个操作数 | 第二个操作数 | 结果  |
| ------------ | ------------ | ----- |
| true         | true         | true  |
| true         | false        | true  |
| false        | true         | true  |
| false        | false        | false |

- 逻辑或操作符一定返回布尔值吗？
  - 不一定
    - 当有操作数不是布尔值时，逻辑或不一定返回布尔值
- 逻辑或操作符遵循哪些规则？
  - 如果第一个操作数求值为 true，就返回第一个操作数
  - 如果第一个操作数求值为 false，则返回第二个操作数
  - 如果第一个操作数是 null，则返回 null
  - 如果第一个操作数是 NaN，则返回 NaN
  - 如果第一个操作数是 undefined，则返回 undefined

- 逻辑与操作符的重要特性是什么？
  - 短路
- 在什么情况下，逻辑与操作符会短路？
  - 第一个操作数是 true
    - 第二个操作数就不会再求值了

```
let found = true;
let result = (found || someUndeclaredVariable); // 不会出错
console.log(result); // 会执行
```

- 利用短路特性，可以怎么使用逻辑与操作符？
  - 可以避免给变量赋值 null 或 undefined

```
let myObject = preferredObject || backupObject;
```

- 在这上述例子中，会执行什么操作？

  - 变量 myObject 会被赋予两个值中的一个

    - 其中，preferredObject 变量包含首选的值
    - backupObject 变量包含备选的值

  - 如果 preferredObject 不是 null

    则 preferredObject 的值就会赋给 myObject 

  - 如果 preferredObject 是 null

    则 backupObject 的值会赋给 myObject 

- 这种模式在 ECMAScript 代码中经常用于什么？
  - 变量赋值

- 逻辑或、逻辑与的优先级是怎样的？

  - 逻辑或的优先级高于逻辑与


### 3.5.4 乘性操作符

- 乘性操作符有哪 3 种？
  - 乘法
  - 除法
  - 取模

- 如果乘性操作符有不是数值的操作数，会执行什么操作？
  - 该操作数会在后台被使用 Number（）转型函数转换为数值
    - 意味着空字符串被当成 0
    - 布尔值 true 被当成 1

#### 1. 乘法操作符

- 乘法操作符由什么符号表示？
  - 一个星号
- 乘法操作符用来做什么？
  - 用来计算两个数值的乘积

```
let result = 34 * 56;
```

- 乘法操作符在处理特殊值有哪些特殊的行为？

  - 如果操作数都是数值，则执行常规运算

    - 如果 ECMAScript 不能表示乘积，则返回 Infinity 或 -Infinity

  - 如果任一操作数是 NaN，则返回 NaN

  - 如果操作数是 Infinity 乘以 0 ，则返回 NaN

  - 如果操作数是 Infinity 乘以非 0 的有限制 ，

    则根据第二个操作数的符号

    返回 Infinity 或 -Infinity

  - 如果操作数是 Infinity 乘以 Infinity ，则返回 Infinity 

  - 如果有不是数值的操作数，

    则先在后台用 Number（）将其转换为数值

    然后再应用上述规则

#### 2. 除法操作符

- 除法操作符由什么符号表示？
  - 一个斜杠（/）
- 除法操作符用来做什么？
  - 用来计算第一个操作数除以第二个操作数的商

```
let result = 66 / 11;
```

- 除法操作符在处理特殊值有哪些特殊的行为？

  - 如果操作数都是数值，则执行常规运算

    - 如果 ECMAScript 不能表示商，则返回 Infinity 或 -Infinity

  - 如果任一操作数是 NaN，则返回 NaN

  - 如果是 Infinity 除以 Infinity ，则返回 NaN

  - 如果是 0 除以 0 ，则返回 NaN

  - 如果是非 0 的有限制 除以 0，

    则根据第一个操作数的符号

    返回 Infinity 或 -Infinity

  - 如果操作数是 Infinity 除以任何数值，

    则根据第二个操作数的符号

    返回 Infinity 或 -Infinity

  - 如果有不是数值的操作数，

    则先在后台用 Number（）将其转换为数值

    然后再应用上述规则

#### 3. 取模操作符

- 取模操作符由什么符号表示？
  - 百分号（%）

```
let result = 26 % 5; // 1
```

- 取模操作符在处理特殊值有哪些特殊的行为？

  - 如果操作数都是数值，则执行常规除法运算，返回余数

  - 如果被除数是无限制，除数是有限制，则返回 NaN

  - 如果被除数是有限制，除数是 0 ，则返回 NaN

  - 如果是 Infinity 除以 Infinity ，则返回 NaN

  - 如果被除数是有限制，除数是无限制，则返回被除数

  - 如果被除数是 0 ，除数不是 0 ，则返回 0

  - 如果有不是数值的操作数，

    则先在后台用 Number（）将其转换为数值

    然后再应用上述规则

### 3.5.5 指数操作符

- 指数操作符由什么符号表示？
  - **

```
console.log(Math.pow(3, 2)); // 9
console.log(3 ** 2); // 9
console.log(Math.pow(16, 0.5)); // 4
console.log(16 ** 0.5); // 4
```

- 指数赋值操作符由什么符号表示？
  - **=

```
let squared = 3;
squared **= 2;
console.log(squared); // 9
let sqrt = 16;
sqrt **= 0.5;
console.log(sqrt); // 4
```

### 3.5.6 加性操作符

#### 1.  加法操作符 

```
let result = 1 + 2;
```

- 如果两个操作数都是数值，加法操作符根据哪些规则？

  - 如果有任一操作数是 NaN，则返回 NaN； 

  - 如果是 Infinity 加 Infinity ，则返回 Infinity； 

  - 如果是 -Infinity 加 -Infinity，则返回 -Infinity； 

  - 如果是 Infinity 加 -Infinity ，则返回 NaN； 

  - 如果是 +0 加 +0 ，则返回 +0； 

  - 如果是 -0 加 +0 ，则返回 +0； 

  - 如果是 -0 加 -0 ，则返回 -0 。 

- 如果有一个操作数是字符串，则要应用哪些规则？

  - 如果两个操作数都是字符串，
    - 则将第二个字符串拼接到第一个字符串后面； 

  - 如果只有一个操作数是字符串，

    - 则将另一个操作数转换为字符串，

    - 再拼接

- 如果有任一操作数是对象，则要应用哪些规则？

  - 则调用对象的 toString() 方法以获取字符串，
  - 再应用关于字符串的规则。

- 如果有任一操作数是 undefined 和 null ，

  则要应用哪些规则？

  - 则调用 String() 函数
    - 分别获取"undefined" 和 "null"  
  - 再应用关于字符串的规则

- 如果一个操作数是布尔值，另一个是数值，

  则要应用哪些规则？
  
  - 将布尔值转换为数值
    - true 转换为 1
    - false 转换为 0 
  
  - 再应用关于数值的规则


```
let result1 = 5 + 5; // 两个数值
console.log(result1); // 10
let result2 = 5 + "5"; // 一个数值和一个字符串
console.log(result2); // "55"
```

- 最常犯的一个错误，就是忽略加法操作中的什么？
  - 数据类型

```
let num1 = 5;
let num2 = 10;
let message = "The sum of 5 and 10 is " + num1 + num2;
console.log(message); // "The sum of 5 and 10 is 510"
```

- 这是因为每次加法运算都是独立完成的。

  - 第一次加法的操作数是一个字符串和一个数值（5），

    结果还是一个字符串。

  - 第二次加法仍然是用一个字符串去加一个数值（10），

    同样也会得到一个字符串。

- 如果想真正执行数学计算，然后把结果追加到字符串末尾，

  应该怎么做？

  - 只要使用一对括号即可： 

```
let num1 = 5;
let num2 = 10;
let message = "The sum of 5 and 10 is " + (num1 + num2);
console.log(message); // "The sum of 5 and 10 is 15"
```

#### 2 减法操作符

```
let result = 2 - 1;
```

- 如果两个操作数都是数值，则执行数学减法运算并返回结果。 
- 如果有任一操作数是 NaN，则返回 NaN。 

- 如果是 Infinity 减 Infinity，则返回NaN。 

- 如果是 -Infinity 减 -Infinity，则返回NaN。 

- 如果是 Infinity 减 -Infinity，则返回Infinity。 

- 如果是 -Infinity 减 Infinity ，则返回-Infinity。 

- 如果是 +0 减 +0 ，则返回 +0。 

- 如果是 +0 减 -0，则返回 -0。 

- 如果是 -0 减 -0，则返回 +0。 

- 如果有任一操作数是字符串、布尔值、null或undefined，则 

  - 先在后台使用Number()将其转换为数值，
    - 然后再根据前面的规则执行数学运算。
  - 如果转换结果是NaN，
    - 则减法计算的结果是NaN。 
  
- 如果有任一操作数是对象，则调用其valueOf()方法取得表示 

  - 它的数值。如果该值是NaN，则减法计算的结果是NaN。如果对 

  - 象没有valueOf()方法，则调用其toString()方法，然后再将得 

  - 到的字符串转换为数值

### **3.5.7** 关系操作符

- 关系操作符执行比较两个值的操作，
  - 小于（<）、
  - 大于（\>）、
  - 小于等于（<=）
  - 大于等于（\>=）

- 在将关系操作符应用到不同数据类型时 

  也会发生哪些类型转换和其他行为？

  - 都是数值，
    - 则执行数值比较。
  - 都是字符串，
    - 逐个比较字符串中对应字符的编码。 

  - 任一操作数是数值，

    - 则将另一个操作数转换为数值，

      执行数值比较。 

  - 如果有任一操作数是对象，
    - 则调用其valueOf()方法，
      - 取得结果后再根据前面的规则执行比较。
    - 如果没有valueOf()操作符，
      - 则调用toString()方法，
        - 取得结果后再根据前面的规则执行比较。 

  - 如果有任一操作数是布尔值，

    - 则将其转换为数值

      再执行比较。

### **3.5.8** 相等操作符 

- ECMAScript提供了两组操作符。

  - 第一组是等于和不等于，
    - 操作数在比较之前进行类型转换。
  - 第二组是全等和不全等， 
    - 操作数在比较之前不进行类型转换。

#### 1 等于和不等于 

- 等于操作符（==）
- 不等于操作符（!=）
- 这两个操作符都会先做什么再判断操作数是否相等？
  - 进行类型转换（通常称为强制类型转换）
- 在转换操作数的类型时，遵循哪些规则？

  - 布尔值
    - 转换为数值
    - false转换为0，true转换为1。 
  - 字符串
    - 转换为 数值，
  - 对象，不是对象，
    - 则调用 对象的 valueOf() 方法 
- 在进行比较时遵循那些规则？

  - null 和 undefined 相等。 
    - null 和 undefined 不能转换为其他类型的值

  - 如果有任一操作数是 NaN，

    - 则不相等

    - NaN 不等于 NaN。 

  - 如果两个操作数都是对象，
    - 则比较是不是同一个对象。
      - 如果同一个对象，则相等
      - 否则，不相等 

| 表达式            | 结果  |
| ----------------- | ----- |
| null == undefined | true  |
| "NaN" == NaN      | false |
| 5 == NaN          | false |
| NaN == NaN        | false |
| NaN != NaN        | true  |
| false == 0        | true  |
| true == 1         | true  |
| true == 2         | false |
| undefined == 0    | false |
| null == 0         | false |
| "5" == 5          | true  |

#### 2 全等和不全等 

- 全等操作符（===）
- 不全等操作符（!==）
- null === undefined 结果是什么，为什么？
  - false
  - 因为它们不是相同的数据类型。


### **3.5.9** 条件操作符 

```
variable = boolean_expression ? true_value : false_value;
```

```
let max = (num1 > num2) ? num1 : num2;
```

### **3.5.10** 赋值操作符 

- 赋值操作符用来做什么？
  - 将右边的值赋给左边的变量

```
let num = 10;
```

- 赋值操作符的结合性是什么方向？
  - 从右往左

- 复合赋值是什么？使用什么符号表示？
  - 是常见赋值操作的简写形式
  - 使用乘性、加性、位操作符后跟等号表示


```
let num = 10; 
num += 10; // num = num + 10
```

- 复合赋值操作符： 

  乘后赋值（*=） 

  除后赋值（/=） 

  取模后赋值（%=） 

  加后赋值（+=） 

  减后赋值（-=） 

  左移后赋值（<<=） 

  右移后赋值（\>>=） 

  无符号右移后赋值（\>>>=） 

### **3.5.11** 逗号操作符

```
let num1 = 1, num2 = 2, num3 = 3;
```

- 在赋值时使用逗号操作符分割值，

  最终会返回表达式中的哪个值？

  - 最后一个值

```
let num = (5, 1, 4, 8, 0); // num = 0
```

## **3.6** 语句

### **3.6.1** **if**语句 

```
if (condition) statement1 
else statement2
```

-  **if**语句的最佳实践是什么？
  - 使用语句块


```
if (i > 25) {
	// 只有一行代码的语句
	console.log('Greater than 25.');
} else {
	console.log('Less than or equal to 25.'); // 一个语句块
}
```

- 如何连续使用多个if语句？

```
if (i > 25) {
	console.log('Greater than 25.');
} else if (i < 0) {
	console.log('Less than 0.');
} else {
	console.log('Between 0 and 25, inclusive.');
}
```

### **3.6.2** **do-while**语句 

```
do {
	statement;
} while (expression);
```

```
let i = 0;
do {
	i += 2;
} while (i < 10);
```

### **3.6.3** **while**语句 

```
while (expression) {
	statement;
}
```

```
let i = 0;
while (i < 10) {
	i += 2;
}
```

### **3.6.4** **for**语句 

```
let count = 10;
for (let i = 0; i < count; i++) {
	console.log(i);
}
```

### **3.6.5** **for-in**语句 

- **for-in**语句是用来做什么的？
  - 枚举对象中的非符号键属性


```
for (const propName in window) {
	document.write(propName);
}
```

- 如果for-in循环要迭代的变量是null或undefined，

  会发生什么？

  - 则不执行循环体。

### **3.6.6** **for-of**语句 

- **for-of**语句是用做什么的？
  - 遍历可迭代对象的元素


```
for (const el of [2, 4, 6, 8]) {
	document.write(el);
}
```

- for-of循环会按照什么顺序迭代元素？

  - 按照对象的next()方法产生值的顺序

- 如果尝试迭代的变量不支持迭代会发生什么？
  - 则for-of语句会抛出错误。 


### **3.6.7** 标签语句

- 标签语句用来做什么的？
  - 给语句加标签


```
label: statement;
```

```
start: for (let i = 0; i < count; i++) {
	console.log(i);
}
```

- start是一个标签，
  - 可以在后面通过break或continue语句引用。
- 标签语句的典型应用场景是什么？
  - 嵌套循环。


### **3.6.8** **break**和**continue**语句 

- break语句用来做什么？
  - 立即退出循环，
  - 强制执行循环后的下一条语句。 

- continue语句用来做什么？
  - 立即退出循环
  - 会再次从循环顶部开始执行


```
let num = 0;
for (let i = 1; i < 10; i++) {
	if (i % 5 == 0) {
		break;
	}
	num++;
}
console.log(num); // 4
```

```
let num = 0;
for (let i = 1; i < 10; i++) {
	if (i % 5 == 0) {
		continue;
	}
	num++;
}
console.log(num); // 8
```

- break和continue都可以与什么语句一起使用？
  - 标签语句
  - 返回代码中特定的位置。

- 通常是在什么循环中，
  - 嵌套循环


```
let num = 0;
outermost: for (let i = 0; i < 10; i++) {
	for (let j = 0; j < 10; j++) {
		if (i == 5 && j == 5) {
			break outermost;
		}
		num++;
	}
}
console.log(num); // 55
```

- 添加标签不仅让break退出（使用变量j的）内部循环， 

  也会退出（使用变量i的）的外部循环。

```
let num = 0;
outermost: for (let i = 0; i < 10; i++) {
	for (let j = 0; j < 10; j++) {
		if (i == 5 && j == 5) {
			continue outermost;
		}
		num++;
	}
}
console.log(num); // 95
```

- continue语句会强制循环继续执行，
  - 但不是继续执行内部循环，而是继续执行外部循环。

### **3.6.9** **with**语句

- 将代码作用域设置为特定的对象

```
with (expression) statement;
```

- 使用with语句的主要场景是
  - 针对一个对象反复操作
  - 这时候将代码作用域设置为该对象能提供便利

```
let qs = location.search.substring(1);
let hostName = location.hostname;
let url = location.href;
```

```
with (location) {
	let qs = search.substring(1);
	let hostName = hostname;
	let url = href;
}
```

- 严格模式不允许使用with语句，否则会抛出错误。 

- 警告 由于with语句影响性能且难于调试其中的代码，
  - 通常不推荐在产品代码中使用with语句

### **3.6.10** **switch**语句

```
switch (expression) {
    case value1: statement break;
    case value2: statement break;
    case value3: statement break;
    case value4: statement break;
    default: statement
}
```

- 每个case（条件/分支）相当于什么？
  - 如果表达式等于后面的值
    - 则执行下面的语句
- break关键字会导致代码执行什么操作？
  - 跳出switch语句
- 如果没有break，代码会执行什么操作？
  - 会继续匹配下一个条件
- default关键字用来做什么？
  - 用来在任何条件都没有满足时
    - 指定默认执行的语句
- 如何避免不必要的条件判断？
  - 给每个条件后面都加上break
- 如果确实需要连续匹配几个条件，那么推荐怎么做？
  - 写个注释表明是故意忽略了break

```
switch (1) {
    case 25:
        // 跳过
    case 35:
        console.log("25 or 35");
        break;
    case 45:
        console.log("45");
        break;
    default:
        console.log("Other");
}
```

- switch语句可用于哪些数据类型？
  - 任何数据类型

- switch条件的值除了常量还可以是哪些值？
  - 变量
  - 表达式

```
switch ('hello world') {
	case 'hello' + ' world': // 表达式
		console.log('Greeting was found.');
		break;
	case 'goodbye':
		console.log('Closing was found.');
		break;
	default:
		console.log('Unexpected message was found.');
}
```

```
let num = 25;
switch (true) {
	case num < 0: // 表达式
		console.log('Less than 0.');
		break;
	case num >= 0 && num <= 10:
		console.log('Between 0 and 10.');
		break;
	case num > 10 && num <= 20:
		console.log('Between 10 and 20.');
		break;
	default:
		console.log('More than 20.');
}
```

- switch语句在比较每个条件的值时会使用什么操作符，
  - 全等操作符
    - 因此不会强制转换数据类型

## **3.7** 函数

```
function functionName (arg0, arg1, ..., argN) {
    statements
}
```

```
function sayHi(name, message) {
	console.log('Hello ' + name + ', ' + message);
}
```

```
sayHi("Nicholas", "how are you today?");
```

- 函数是否需要指定返回值？
  - 不需要

- 如果碰到return语句，函数就会执行什么操作？
  - 立即停止执行并退出
  - return语句后面的代码不会被执行。

- 严格模式对函数也有哪些限制？

  - 函数名不能是 eval 或 arguments；

  - 参数名不能是 eval 或 arguments；

  - 参数名不能相同


- 如果违反上述规则，则会导致什么？
  - 导致语法错误
  - 代码也不会执行

- 一个函数里是否可以有多个return语句 ？
  - 是

```
function diff(num1, num2) {
	if (num1 < num2) {
		return num2 - num1;
	} else {
		return num1 - num2;
	}
}
```

- 如果 return 不带返回值，函数会执行什么操作？
  - 立即停止执行
  - 返回 undefined
-  return 不带返回值通常用于什么场景？
  - 用于提前终止函数执行
    - 不是为了返回值

```
function sayHi(name, message) {
	return;
	console.log("Hello" + name); //不会执行
}
```

- 函数的最佳实践是什么？
  - 要么返回值，要么不返回值
- 函数是否能只在某个条件下返回值？
  - 不建议
    - 因为在调试时会带来麻烦
- 当关键字return、 break和 continue后紧跟着换行时，
  - 会执行什么操作？ 
    - 会在换行处自动补全分号


```
function isArray() {
    return
    true;
}
isArray();
```

```
function isArray() {
    return; // 自动补全分号
    true;
}
isArray();
```

## **3.8** 小结

- 基本数据类型有哪些？
  - Undefined、
  - Null、
  - Boolean、
  - Number、
  - String、
  - Symbol。 
- 有哪几种数值数据类型？
  - 只有Number一种
    - 不区分整数和浮点值，
- Object是一种什么数据类型，它是所有对象的什么？
  - 复杂数据类型
  - 它是所有对象的基类。 
- 严格模式的目的是什么？
  - 为容易出错的部分施加限制。 
- 基本操作符包括哪些？
  - 数学操作符、
  - 布尔操作符、
  - 关系操作符、
  - 相等操作符、
  - 赋值操作符
  - 等。 
- 流控制语句有哪些？，
  - if 语句、
  - for语句、
  - switch语句
  - 等
- 函数的特点有哪些？

  - 不需要指定函数的返回值

- 不指定返回值的函数会返回什么？
  - 特殊值undefined。
