# 第 **4** 章 变量、作用域与内存

## 本章内容

- 通过变量使用原始值与引用值 

- 理解执行上下文 

- 理解垃圾回收 

## **4.1** 原始值与引用值 

- 原始值是什么？

  - 简单的数据

- 引用值是什么？

  - 对象 

- 在把一个值赋给变量时，JS 引擎会做什么？
  - JS 引擎必须确定这个值是原始值还是引用值。

- 原始值有哪六种？

  - Undefined、
  - Null、
  - Boolean、
  - Number、
  - String
  - Symbol。

- 保存原始值的变量是按值访问的，
  - 因为操作的就是存储在变量中的实际值

- 保存引用值的变量是按引用访问的。 

- 引用值是保存在内存中的对象。

  JavaScript不允许直接访问内存位置，

  - 因此也就不能直接操作对象所在的内存空间。

- 在操作对象时，

  - 实际上操作的是对该对象的引用

    而非实际的对象本身。

### **4.1.1** 动态属性

- 引用值，可以随时添加、修改和删除其属性和方法 

```
let person = new Object();
person.name = 'Nicholas';
console.log(person.name); // "Nicholas"
```

- 原始值不能有属性，
  - 但给原始值添加属性不会报错。

```
let name = "Nicholas"; 
name.age = 27; 
console.log(name.age); // undefined
```

- 记住，只有引用值可以动态添加后面可以使用的属性。 

- 注意，原始类型的初始化可以只使用原始字面量形式。

  - 如果使用的是new关键字，

    则JavaScript会创建一个Object类型的实例，

    但其行为类似原始值。

    下面来看看这两种初始化方式的差异：

```
let name1 = 'Nicholas';
let name2 = new String('Matt');
name1.age = 27;
name2.age = 26;
console.log(name1.age); // undefined
console.log(name2.age); // 26
console.log(typeof name1); // string
console.log(typeof name2); // object
```

### **4.1.2** 复制值

- 把一个原始值赋值到另一个变量时，

  - 原始值会被复制到新变量的位置。

- 把引用值从一个变量赋给另一个变量时，

  - 存储在变量中的值也会被复制到新变量所在的位置。

  - 区别在于，

    复制的是一个指针， 

    指向存储在堆内存中的对象。

  - 操作完成后，两个变量实际上指向同一个对象

    - 因此一个对象上面的变化

      会在另一个对象上反映出来

  ```
  let obj1 = new Object();
  let obj2 = obj1;
  obj1.name = 'Nicholas';
  console.log(obj2.name); // "Nicholas"
  ```

![image-20220310210340119](C:\Users\KEVIN\AppData\Roaming\Typora\typora-user-images\image-20220310210340119.png)

### **4.1.3** 传递参数

- ECMAScript中所有函数的参数都是按值传递的。

  - 这意味着函数外的值

    会被复制到函数内部的参数中，

    就像从一个变量复制到另一个变量一样。

  - 如果是原始值，那么就跟原始值变量的复制一样，
  - 如果是引用值，那么就跟引用值变量的复制一样。

- 变量有按值和按引用访问，

  - 而传参则只有按值传递。 

- 在按值传递参数时，

  值会被复制到一个局部变量

  （即一个命名参数，arguments对象中的一个槽位）

```
function addTen(num) {
	num += 10;
	return num;
}
let count = 20;
let result = addTen(count);
console.log(count); // 20，没有变化
console.log(result); // 30
```

```
function setName(obj) {
	obj.name = 'Nicholas';
}
let person = new Object();
setName(person);
console.log(person.name); // "Nicholas"
```

- 即使对象是按值传进函数的，obj也会通过引用访问对象。

- 当函数内部给obj设置了name属性时， 

  - 函数外部的对象也会反映这个变化，

  - 因为obj指向的对象保存在全局作用域的堆内存上。

- 下面代码证明对象是按值传递的

```
function setName(obj) {
	obj.name = 'Nicholas';
	obj = new Object();
	obj.name = 'Greg';
}
let person = new Object();
setName(person);
console.log(person.name); // "Nicholas"
```

- 注意 ECMAScript中函数的参数就是局部变量。 

### **4.1.4** 确定类型 

## **4.2** 执行上下文与作用域 

### **4.2.1** 作用域链增强

### **4.2.2** 变量声明

#### 1. 使用**var**的函数作用域声明

#### 2. 使用**let**的块级作用域声明 

#### 3. 使用**const**的常量声明

#### 4. 标识符查找

## **4.3** 垃圾回收

### **4.3.1** 标记清理

### **4.3.2** 引用计数

### **4.3.3** 性能 

### **4.3.4** 内存管理

#### 1. 通过**const**和**let**声明提升性能 

#### 2. 隐藏类和删除操作 

#### 3. 内存泄漏

#### 4. 静态分配与对象池

## **4.4** 小结

