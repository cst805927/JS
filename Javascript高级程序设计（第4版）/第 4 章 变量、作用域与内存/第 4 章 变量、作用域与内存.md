# 第 **4** 章 变量、作用域与内存

## 本章内容

- 通过变量使用原始值与引用值 

- 理解执行上下文 

- 理解垃圾回收 

## **4.1** 原始值与引用值 

- 原始值是数据

- 引用值是对象。 

- 在把一个值赋给变量时，
  - JS 引擎必须确定这个值是原始值还是引用值。

- 6种原始值：

  - Undefined、Null、Boolean、Number、String和Symbol。

- 保存原始值的变量是按值访问的，
  - 因为操作的就是存储在变量中的实际值

- 保存引用值的变量是按引用访问的。 

- 引用值是保存在内存中的对象。

  JavaScript不允许直接访问内存位置，

  - 因此也就不能直接操作对象所在的内存空间。

- 在操作对象时，

  - 实际上操作的是对该对象的引用

    而非实际的对象本身。

### **4.1.1** 动态属性

- 引用值，可以随时添加、修改和删除其属性和方法 

```
let person = new Object();
person.name = 'Nicholas';
console.log(person.name); // "Nicholas"
```

- 原始值不能有属性，
  - 但给原始值添加属性不会报错。

```
let name = "Nicholas"; 
name.age = 27; 
console.log(name.age); // undefined
```

- 记住，只有引用值可以动态添加后面可以使用的属性。 

- 注意，原始类型的初始化可以只使用原始字面量形式。

  - 如果使用的是new关键字，

    则JavaScript会创建一个Object类型的实例，

    但其行为类似原始值。

    下面来看看这两种初始化方式的差异：

```
let name1 = 'Nicholas';
let name2 = new String('Matt');
name1.age = 27;
name2.age = 26;
console.log(name1.age); // undefined
console.log(name2.age); // 26
console.log(typeof name1); // string
console.log(typeof name2); // object
```

### **4.1.2** 复制值

- 把一个原始值赋值到另一个变量时，

  - 原始值会被复制到新变量的位置。

- 把引用值从一个变量赋给另一个变量时，

  - 存储在变量中的值也会被复制到新变量所在的位置。

  - 区别在于，

    复制的是一个指针， 

    指向存储在堆内存中的对象。

  - 操作完成后，两个变量实际上指向同一个对象

    - 因此一个对象上面的变化

      会在另一个对象上反映出来

  ```
  let obj1 = new Object();
  let obj2 = obj1;
  obj1.name = 'Nicholas';
  console.log(obj2.name); // "Nicholas"
  ```

![image-20220310210340119](C:\Users\KEVIN\AppData\Roaming\Typora\typora-user-images\image-20220310210340119.png)

### **4.1.3** 传递参数

- ECMAScript中所有函数的参数都是按值传递的。

  - 这意味着函数外的值

    会被复制到函数内部的参数中，

    就像从一个变量复制到另一个变量一样。

  - 如果是原始值，那么就跟原始值变量的复制一样，
  - 如果是引用值，那么就跟引用值变量的复制一样。

- 变量有按值和按引用访问，

  - 而传参则只有按值传递。 

- 在按值传递参数时，

  值会被复制到一个局部变量

  （即一个命名参数，arguments对象中的一个槽位）

```
function addTen(num) {
	num += 10;
	return num;
}
let count = 20;
let result = addTen(count);
console.log(count); // 20，没有变化
console.log(result); // 30
```

```
function setName(obj) {
	obj.name = 'Nicholas';
}
let person = new Object();
setName(person);
console.log(person.name); // "Nicholas"
```

- 即使对象是按值传进函数的，obj也会通过引用访问对象。

- 当函数内部给obj设置了name属性时， 

  - 函数外部的对象也会反映这个变化，

  - 因为obj指向的对象保存在全局作用域的堆内存上。

- 下面代码证明对象是按值传递的

```
function setName(obj) {
	obj.name = 'Nicholas';
	obj = new Object();
	obj.name = 'Greg';
}
let person = new Object();
setName(person);
console.log(person.name); // "Nicholas"
```

- 注意 ECMAScript中函数的参数就是局部变量。 

### **4.1.4** 确定类型 

