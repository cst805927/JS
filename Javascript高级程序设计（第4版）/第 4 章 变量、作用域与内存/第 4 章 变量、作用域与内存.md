# 第 **4** 章 变量、作用域与内存

## 本章内容

- 通过变量使用原始值与引用值 

- 理解执行上下文 

- 理解垃圾回收 

## **4.1** 原始值与引用值 

- 原始值是什么？

  - 简单的数据

- 引用值是什么？

  - 对象 

- 在把一个值赋给变量时，JS 引擎会做什么？
  - JS 引擎必须确定这个值是原始值还是引用值。

- 原始值有哪六种？

  - Undefined、
  - Null、
  - Boolean、
  - Number、
  - String
  - Symbol。

- 保存原始值的变量是按值访问的，
  - 因为操作的就是存储在变量中的实际值

- 保存引用值的变量是按引用访问的。 

- 引用值是保存在内存中的对象。

  JavaScript不允许直接访问内存位置，

  - 因此也就不能直接操作对象所在的内存空间。

- 在操作对象时，

  - 实际上操作的是对该对象的引用

    而非实际的对象本身。

### **4.1.1** 动态属性

- 引用值，可以随时添加、修改和删除其属性和方法 

```
let person = new Object();
person.name = 'Nicholas';
console.log(person.name); // "Nicholas"
```

- 原始值不能有属性，
  - 但给原始值添加属性不会报错。

```
let name = "Nicholas"; 
name.age = 27; 
console.log(name.age); // undefined
```

- 记住，只有引用值可以动态添加后面可以使用的属性。 

- 注意，原始类型的初始化可以只使用原始字面量形式。

  - 如果使用的是new关键字，

    则JavaScript会创建一个Object类型的实例，

    但其行为类似原始值。

    下面来看看这两种初始化方式的差异：

```
let name1 = 'Nicholas';
let name2 = new String('Matt');
name1.age = 27;
name2.age = 26;
console.log(name1.age); // undefined
console.log(name2.age); // 26
console.log(typeof name1); // string
console.log(typeof name2); // object
```

### **4.1.2** 复制值

- 把一个原始值赋值到另一个变量时，

  - 原始值会被复制到新变量的位置。

- 把引用值从一个变量赋给另一个变量时，

  - 存储在变量中的值也会被复制到新变量所在的位置。

  - 区别在于，

    复制的是一个指针， 

    指向存储在堆内存中的对象。

  - 操作完成后，两个变量实际上指向同一个对象

    - 因此一个对象上面的变化

      会在另一个对象上反映出来

  ```
  let obj1 = new Object();
  let obj2 = obj1;
  obj1.name = 'Nicholas';
  console.log(obj2.name); // "Nicholas"
  ```

![image-20220310210340119](C:\Users\KEVIN\AppData\Roaming\Typora\typora-user-images\image-20220310210340119.png)

### **4.1.3** 传递参数

- ECMAScript中所有函数的参数都是按值传递的。

  - 这意味着函数外的值

    会被复制到函数内部的参数中，

    就像从一个变量复制到另一个变量一样。

  - 如果是原始值，那么就跟原始值变量的复制一样，
  - 如果是引用值，那么就跟引用值变量的复制一样。

- 变量有按值和按引用访问，

  - 而传参则只有按值传递。 

- 在按值传递参数时，

  值会被复制到一个局部变量

  （即一个命名参数，arguments对象中的一个槽位）

```
function addTen(num) {
	num += 10;
	return num;
}
let count = 20;
let result = addTen(count);
console.log(count); // 20，没有变化
console.log(result); // 30
```

```
function setName(obj) {
	obj.name = 'Nicholas';
}
let person = new Object();
setName(person);
console.log(person.name); // "Nicholas"
```

- 即使对象是按值传进函数的，obj也会通过引用访问对象。

- 当函数内部给obj设置了name属性时， 

  - 函数外部的对象也会反映这个变化，

  - 因为obj指向的对象保存在全局作用域的堆内存上。

- 下面代码证明对象是按值传递的

```
function setName(obj) {
	obj.name = 'Nicholas';
	obj = new Object();
	obj.name = 'Greg';
}
let person = new Object();
setName(person);
console.log(person.name); // "Nicholas"
```

- 注意 ECMAScript中函数的参数就是局部变量。 

### **4.1.4** 确定类型 

- typeof操作符最适合用来做什么？
  - 它是判断一个变量是否为字符串、数值、布尔值 或undefined的最好方式。

- 如果值是对象或null，那么typeof 返回什么？
  - 返回"object"

```
let s = "Nicholas";
let b = true;
let i = 22;
let u;
let n = null;
let o = new Object();
console.log(typeof s); // string 
console.log(typeof i); // number 
console.log(typeof b); // boolean 
console.log(typeof u); // undefined 
console.log(typeof n); // object
console.log(typeof o); // object
```

- typeof对什么值的用处不大，为什么？
  - 引用值
  - 我们通常不关心一个值是不是对象，而是想知道它是什么类型的对象
- 如何确定一个对象是什么类型的实例？
  - 使用instanceof操作符

```
result = variable instanceof constructor
```

- 如果变量是给定引用类型的实例，则instanceof操作符返回什么？
  - true

```
console.log(person instanceof Object); // 变量person是Object吗？ 
console.log(colors instanceof Array); // 变量colors是Array吗？
console.log(pattern instanceof RegExp); // 变量pattern是RegExp吗？
```

- 按照定义，所有引用值都是谁的实例？

  - Object

- 此通过instanceof操作符检测任何引用值和Object构造函数都会返回什么？

  - true

- 用instanceof检测原始值，则始终会返回什么，为什么？

  - false
  - 因为原始值不是对象

- 注意 typeof操作符在用于检测函数时会返回什么？

  - "function"

- ECMA-262规定，任何实现什么方法的对象

  都应该 在 typeof 检测时返回"function"？

  - 内部 call 方法

## **4.2** 执行上下文与作用域 

- 变量或函数的上下文决定了什么？

  - 它们可以访问哪些数据，
  - 它们的行为。

- 每个上下文都有一个什么对象？

  - 变量对象（ variable object）

- 变量对象是用来存储什么的？

  - 这个上下文中定义的所有变量和函数

- 能否通过代码访问变量对象？

  - 不能

- 哪里会用到变量对象？

  - 后台处理数据会用到

- 什么是最外层的上下文？

  - 全局上下文

- 根据ECMAScript实现的宿主环境，表示全局上下文的对象是否一样？

  - 可能不一样

- 在浏览器中，全局上下文就是什么？

  - window对象

- 因此所有通过什么定义的全局变量和函数

  都会成为window对象的属性和方法。

  - var

- 使用let和const的顶级声明是否会定义在全局上下文中？

  - 不会

- 上 下文在其所有代码都执行完毕后会发生什么？

  - 会被销毁，
    - 包括定义在它上面的所有变量和函数

- 全局上下文在什么时候被销毁？

  - 应用程序退出前才会被销毁，
    - 关闭网页
    - 退出浏览器

- 每个函数调用是否都有自己的上下文？

  - 是

- 当代码执行流进入函数时，函数的上下文会被推到哪里？

  - 一个上下文栈

- 在函数执行完之后，上下文栈会做什么？

  - 会弹出该函数上下文
  - 将控制权返还给之前的执行上下文

- ECMAScript程序的执行流就是通过什么进行控制的？

  - 这个上下文栈

- 上下文中的代码在执行的时候，会创建什么？

  - 创建变量对象的一个作用域链

- 这个作用域链决定了什么？

  - 各级上下文中的代码在访问变量和函数时的顺序。

- 代码正在执行的上下文的变量对象在作用域链的哪个位置？

  - 最前端

- 如果上下文是函数，则其什么对象用作变量对象？

  - 活动对象（ activation object）

- 活动对象最初哪几个定义变量？

  - 只有一个定义变量 arguments。

- 全局上下文中是否存在定义变量？

  - 不存在

- 作用域链中的下一个变量对象来自哪里？

  - 包含上下文

- 全局上下文的变量对象始终是作用域链的第几个变量对象？

  - 最后一个

- 代码执行时的标识符解析是通过什么完成的？

  - 沿作用域链

    逐级搜索标识符名称

- 搜索过程始终哪里开始，然后往哪里找，直到找到标识符？

  - 从作用域链的最前端开始
  - 然后逐级往后

- 如果没有找到标识符，那么会发生什么？

  - 报错

```
var color = "blue";

function changeColor() {
    if (color === "blue") {
        color = "red";
    } else {
        color = "blue";
    }
}
changeColor();
```

- 函数changeColor()的作用域链包含哪几个对象？
  - 一个是它自己的变量对象（就是定义arguments对象的那个），
  - 另一个是全局上下文的变量对象。
- 这个函数内部为什么能够访问变量color？
  - 因为可以在作用域链中找到变量color
- 局部作用域中定义的变量可用于什么？
  - 在局部上下文中替换全局变量

```
var color = "blue";

function changeColor() {
    let anotherColor = "red";

    function swapColors() {
        let tempColor = anotherColor;
        anotherColor = color;
        color = tempColor; // 这里可以访问color、anotherColor和tempColor 
    }
    // 这里可以访问color和anotherColor，但访问不到tempColor 
    swapColors();
} // 这里只能访问color changeColor();
```

- 以上代码涉及哪几个上下文？
  - 全局上下文、
  - changeColor()的局部上下文
  - swapColors()的局部上下文。
- 全局上下文中有什么？
  - 一个变量color
  - 一个函 数changeColor()。
- changeColor()的局部上下文中有什么？
  - 一个变量 anotherColor
  - 一个函数swapColors()，
- swapColors()的局部上下文中有什么？
  - 一个变量tempColor， 
    - 只能在这个上下文中访问到。

![image-20220312082241581](C:\Users\86189\AppData\Roaming\Typora\typora-user-images\image-20220312082241581.png)

- 内部上下文是否可以访问外部上下文中的一切？怎么实现？
  - 可以
  - 通过作用域链

- 但外部上下文是否可以访问内部上下文的东西？
  - 无法访问内部上下文中的任何东西。
- 注意 函数参数被认为是哪个上下文中的变量？
  - 当前上下文

### **4.2.1** 作用域链增强 

- 执行上下文主要有哪两种？
  - 全局上下文
  - 函数上下文
- 哪些语句会导致在作用域链前端临时添加一个上下文？
  - try/catch语句的catch块 
  - with语句
- 对with语句来说，会添加什么对象？
  - 指定对象
- 对catch语句而言，则会添加什么对象？
  - 创建 一个新的变量对象

- catch语句创建的变量对象包含什么？
  -  会包含要抛出的错误对象的声明。

```
function buildUrl() {
    let qs = "?debug=true";
    with(location) {
        let url = href + qs;
    }
    return url;
}
```

- 上述代码with语句将什么对象作为上下文？
  - location对象
- 在with语句中使用var声明的变量url会成为什么上下文的一部分？
  - 函数上下文
- 使用var声明的变量url 是否可以作为函数的值被返回？
  - 是
- 使用let声明的变量url，在with块之外是否有定义？为什么?
  - 没有定义
    - 因为被限制在块级作用域中

### **4.2.2** 变量声明

#### 1. 使用**var**的函数作用域声明

- 在使用var声明变量时，变量会被自动添加到哪个上下文？
  - 最接近的上下文
- 在函数中，最接近的上下文就是什么？
  - 函数上下文
- 在with语句中，最接近的上下文是什么？
  - 函数上下文

- 如果变量未经声明就被初始化了，那么它就会自动被添加到什么上下文？
  - 全局上下文

```
function add(num1, num2) {
    var sum = num1 + num2;
    return sum;
}
let result = add(10, 20); // 30 
console.log(sum); // 报错：sum在这里不是有效变量
```

- 上述代码的变量sum在函数外部是否访问得到？
  - 不能
- 如何让变量sum在add()被调用之后就变成可以访问的？
  - 省略关键字var

```
function add(num1, num2) {
    sum = num1 + num2;
    return sum;
}
let result = add(10, 20); // 30 
console.log(sum); // 30
```

- 在调用add()之后，sum被添加到了什么上下文？

  - 全局上下文

- sum在函数退出之后是否依然存在？在后面是否可以访问到？

  - 存在
  - 因此在后面可以访问到

-  在严格模式下，未经声明就初始化变量是否会报错？

  - 会

- 为什么在初始化变量之前一定要先声明变量？

  - 因为未经声明就初始化的变量会导致很多问题

- 提升是一种什么现象？

  - var声明被拿到函数或全局作用域的顶部，
    - 位于作用域中所有代码之前。

- 提升的作用是什么？

  - 让同一作用域中的代码

    不必考虑变量是否已经声明

    就可以直接使用

```
var name = "Jake";
```

```
// 等价于： 
name = 'Jake';
var name;
```

```
function fn1() {
    var name = 'Jake';
}
```

```
// 等价于：
function fn2() {
    var name;
    name = 'Jake';
}
```

```
console.log(name); // undefined 
var name = 'Jake';
function() {
    console.log(name); // undefined 
    var name = 'Jake';
}
```

#### 2. 使用**let**的块级作用域声明

- let的作用域有什么特点？
  - let作用域是块级的，
- 块级作用域是由什么界定的？
  - 由最近的一对包含花括号{}界定。
- 块级作用域有哪些例子？
  - if块、
  - while块、
  - function块，
  - 单独的块

```
if (true) {
    let a;
}
console.log(a); // ReferenceError: a没有定义 
while (true) {
    let b;
}
console.log(b); // ReferenceError: b没有定义
function foo() {
    let c;
}
console.log(c); // ReferenceError: c没有定义
// 这没什么可奇怪的
// var声明也会导致报错

// 这不是对象字面量，而是一个独立的块
// JavaScript解释器会根据其中内容识别出它来
{
    let d;
}
console.log(d); // ReferenceError: d没有定义
```

- let是在同一作用域内能否声明两次？
  - 不能
- 重复 的var声明会发生什么？
  - 会被忽略
- 重复的let声明会发生什么？
  - 抛出SyntaxError。

```
var a;
var a; // 不会报错 
{
    let b;
    let b;
}
// SyntaxError: 标识符b已经声明过了
```

- let的行为非常适合在什么中声明变量？
  - 在循环中声明迭代变量
- 使用var声明的迭代变量会有什么问题？
  - 迭代变量会泄漏到循环外部

```
for (var i = 0; i < 10; ++i) {}
console.log(i); // 10 
for (let j = 0; j < 10; ++j) {}
console.log(j); // ReferenceError: j没有定义
```

- 为什么不能在声明之前使用let 变量？
  - 因为存在“暂时性死区”

#### 3. 使用**const**的常量声明

- 使用const声明的变量必须同时做什么？
  - 初始化为某个值。
- 一经声明，在其生命周期的任何时候都能不能再重新赋予新值？
  - 不能

```
const a; // SyntaxError: 常量声明时没有初始化 
const b = 3;
console.log(b); // 3
b = 4; // TypeError: 给常量赋值
```

- const除了要遵循以上规则，其他方面与let声明是一样的

```
if (true) {
    const a = 0;
}
console.log(a); // ReferenceError: a没有定义
while (true) {
    const b = 1;
}
console.log(b); // ReferenceError: b没有定义 
function foo() {
    const c = 2;
}
console.log(c); // ReferenceError: c没有定义 
{
    const d = 3;
}
console.log(d); // ReferenceError: d没有定义
```

- const声明只应用到哪里？
  - 顶级原语
  - 对象
- 赋值为对象的const变量能否再被重新赋值为其他引用值，
  - 不能
- const对象的键是否受限制？
  - 不受限制

```
const o1 = {};
o1 = {}; // TypeError: 给常量赋值 
const o2 = {};
o2.name = 'Jake'; 
console.log(o2.name); // 'Jake'
```

- 如何让整个对象都不能修改？
  - 使用Object.freeze()
    - 给属性赋值时虽然不会报错，
    - 但会静默失败

```
const o3 = Object.freeze({});
o3.name = 'Jake';
console.log(o3.name); // undefined
```

- const声明时，编译器做了什么？
  - 将其所有实例都替换成实际的值，
  - 而不会通过查询表进行变量查找。

- 为什么要尽可能地多使用const声明？
  - 因为保证提前发现重新赋值导致的bug

#### 4. 标识符查找

- 当在特定上下文中为读取或写入而引用一个标识符时，必须做什么？
  - 必须通过搜索确定这个标识符表示什么。
- 搜索开始于作用域链哪里？
  - 作用域链前端
- 以什么搜索对应的标识符？
  - 给定的名称


```
var color = 'blue';

function getColor() {
    return color;
}
console.log(getColor()); // 'blue'
```

- 在这个例子中，为确定color的值会进行哪几步搜索？

  - 第一步，搜索getColor()的变量对象， 查找名为color的标识符，未找到
  - 第二步，搜索下一个变量对象（来自全局上下文），找到，搜索结束

- 引用局部变量会让搜索怎么进行？

  - 自动停止，
  - 而不继续搜索下一级变量对象。

- 如果局部上下文中有一个同名的标识符，

  能不能在该上下文中

  引用父上下文中的同名标识符？

  - 不能

```
var color = 'blue';

function getColor() {
    let color = 'red';
    return color;
}
console.log(getColor()); // 'red'
```

- 使用块级作用域声明是否会改变搜索流程？
  - 不会

```
var color = 'blue';

function getColor() {
    let color = 'red'; {
        let color = 'green';
        return color;
    }
}
console.log(getColor()); // 'green'
```

## **4.3** 垃圾回收

- 垃圾回收基本思路是什么？
  - 确定哪个变量不会再使用，
  - 然后释放它占用的内存。
- 垃圾回收的周期性是什么意思？
  - 每隔一定时间就会自动运行。
- 垃圾回收有哪两种主要的标记策略？
  - 标记清理
  - 引用计数

### **4.3.1** 标记清理

- 最常用的垃圾回收策略是什么？

  - 标记清理

- 标记清理首先会做什么？

  - 会标记内存中所有变量

- 标记所有变量之后，会做什么？

  - 它会将所有

    - 在上下文中的变量，
    - 被在上下文中的变量引用的变量

    的标记去掉。

- 去掉标记之后，还被标记的变量是哪些？

  - 待删除的变量

- 垃圾回收程序做一次内存清理，会做什么？
  - 销毁带标记的所有值
  - 收回它们的内存

### **4.3.2** 引用计数

- 引用计数思路是什么？
  - 对每个值都记录它被引用的次数。
- 声明变量并给它赋一个引用值时，这个值的引用数为多少？
  - 1
- 如果同一个值又被赋给另一个变量，那么引用数会怎么变化？
  - 加 1
- 如果保存对该值引用的变量被其他值给覆盖了， 那么引用数怎么变化？
  - 减1。
- 当一个值的引用数为0时，就说明什么？
  - 没办法再访问到这个值了，
  - 因此可以安全地收回其内存了
- 垃圾回收程序下次运行的时候会释放什么值的内存？
  - 引用数为0的值
- 引用计数有什么严重的问题？
  - 循环引用
- 循环引用是什么意思？
  - 对象A有一个指针指向对象B，
  - 而对象B也引用了对象A。

```
function problem() {
    let objectA = new Object();
    let objectB = new Object();
    objectA.someOtherObject = objectB;
    objectB.anotherObject = objectA;
}
```

- 在这个例子中，objectA和objectB的引用数是多少？
  - 都是 2
- 在标记清理策略下，objectA和objectB是否会被清理？为什么？
  - 会被清理
  - 因为在函数结束后，这两个对象都不在作用域中。
- 而在引用计数策略下，objectA和 objectB是否会被清理？为什么？
  - 不会被清理
  - 因为它们的引用数不为 0
- 如果函数被多次调用，则会导致什么问题？
  - 大量内存不会被释放
- 在IE8及更早版本的IE中，BOM 和DOM中的对象属于什么对象模型？
  - 组件对象模型COM
    - （COM，Component Object Model）
- COM对象使用什么策略实现垃圾回收？
  - 引用计数
- 只要涉及COM对象，无法避免什么问题？
  - 循环引用

```
let element = document.getElementById("some_element");
let myObject = new Object();
myObject.element = element;
element.someObject = myObject;
```

- 如何避免涉及COM对象的循环引用问题？

  - 在确保不使用的情况下

    切断原生 JavaScript对象与DOM元素之间的连接。

```
myObject.element = null; 
element.someObject = null;
```

- 把变量设置为null实际上会发生什么？
  - 切断变量与其之前引用值之间的关系
  - 当下次垃圾回收程序运行时，这些值就会被删除，内存也会被回收。 
- IE9把BOM和DOM对象都改成了什么对象？有什么好处？
  - JavaScript 对象
  - 好处：
    - 避免了由于存在两套垃圾回收算法而导致的问题，
    - 消除了常见的内存泄漏现象。

### **4.3.3** 性能 

### **4.3.4** 内存管理

#### 1. 通过**const**和**let**声明提升性能 

#### 2. 隐藏类和删除操作 

#### 3. 内存泄漏

#### 4. 静态分配与对象池

## **4.4** 小结

