# 第 **10** 章 函数

- 本章内容

  - 函数表达式、函数声明及箭头函数 

  - 默认参数及扩展操作符 

  - 使用函数实现递归 

  - 使用闭包实现私有变量 

- 函数实际上是什么数据类型？
  - 对象
- 每个函数都是什么类型的实例？
  - Function类型
  - Function有属性和方法，跟其他引用类型一样。
- 因为函数是对象，所以函数名是什么？
  - 就是指向函数对象的指针，
  - 而且不一定与函数本身紧密绑定。
- 函数通常以什么方式定义？
  - 函数声明的方式

```
function sum (num1, num2) { 
	return num1 + num2;
}
```

- 注意函数定义最后是否有加分号？
  - 没有
- 另一种定义函数的语法是什么？
  - 函数表达式
- 函数表达式与函数声明是否是等价的？
  - 是

```
let sum = function(num1, num2) { 
	return num1 + num2; 
};
```

- 为什么function关键字后面没有名称？
  - ，因为不需要。
- 这个函数可以通过什么来引用？
  - 变量sum
- 为什么这里的函数末尾是有分号的？
  - 因为与任何变量初始化语句一样。 

- 还有一种定义函数的方式，叫作什么？
  - “箭头函数”

```
let sum = (num1, num2) => {
	return num1 + num2; 
};
```

- 最后一种定义函数的方式是使用什么构造函数？
  - Function构造函数。
- 这个构造函数接收什么参数？ 
  - 任意多个字符串参数，
  - 最后一个参数始终会被当成函数体，
  - 而之前的参数都是新函数的参数。

```
let sum = new Function("num1", "num2", "return num1 + num2"); // 不推荐
```

- 为什么不推荐使用这种语法来定义函数？
  - 因为这段代码会被解释两次：
    - 第一次是将它当作常规ECMAScript代码，
    - 第二次是解释传给构造函数的字符串。
  - 这显然会影响性能。
- 这几种实例化函数对象的方式之间是否存在差别？
  - 是
  - 存在微妙但重要的差别

## **10.1** 箭头函数 

- ECMAScript 6新增了使用什么语法定义函数表达式的能力？

  - 胖箭头（=>）

- 箭头函数实例化的函数对象与

  正式的函数表达式创建的函数对象行为有什么区别？

  - 相同的

- 任何可以使用函数表达式的地方，是否都可以使用箭头函数？

  - 是

```
let arrowSum = (a, b) => { 
	return a + b; 
};
let functionExpressionSum = function(a, b) { 
	return a + b; 
};
console.log(arrowSum(5, 8)); // 13 console.log(functionExpressionSum(5, 8)); // 13
```

-  箭头函数简洁的语法非常适合什么场景？
  - 嵌入函数的场景

```
let ints = [1, 2, 3]; console.log(ints.map(function(i) { 
	return i + 1; 
})); // [2, 3, 4]

console.log(ints.map((i) => { 
	return i + 1 
})); // [2, 3, 4]
```

-  如果只有一个参数，那是否可以不用括号？
  - 可以
- 只有什么的情况下，才需要使用括号？
  - 没有参数
  - 多个参数 

```
// 以下两种写法都有效 
let double = (x) => { 
	return 2 * x; 
};
let triple = x => { 
	return 3 * x; 
};
// 没有参数需要括号 
let getRandom = () => { 
	return Math.random();
};
// 多个参数需要括号 
let sum = (a, b) => { 
	return a + b; 
};
// 无效的写法： 
let multiply = a, b => { 
	return a * b; 
};
```

- 箭头函数是否可以不用大括号？
  - 可以
  - 但这样会改变函数的行为。
- 使用大括号就说明包含什么？
  - 包含“函数体”，
    - 可以在一个函数中包含多条语句，
    - 跟常规的函数一样。
- 如果不使用大括号，那么箭头后面能有几行代码？
  - 一行代码
- 省略大括号会隐式返回什么？
  - 这行代码的值

```
// 以下两种写法都有效，而且返回相应的值 
let double = (x) => { 
	return 2 * x; 
};
let triple = (x) => 3 * x; 

// 可以赋值 
let value = {}; 

let setName = (x) => x.name = "Matt"; 

setName(value); 

console.log(value.name); // "Matt"

// 无效的写法： 
let multiply = (a, b) => return a * b;
```

- 箭头函数不能使用什么？
  - arguments
  - super
  - new.target
- 箭头函是否能用作构造函数？
  - 不能
- 箭头函数是否有prototype属性？
  - 没有

## **10.2** 函数名

- 函数名是否跟其他包含对象指针的变量 

  具有相同的行为？

  - 是
  - 因为函数名就是指向函数的指针

- 一个函数是否可以有多个名称？
  - 可以

```
function sum(num1, num2) {
	return num1 + num2; 
}
console.log(sum(10, 10)); // 20 

let anotherSum = sum; 
console.log(anotherSum(10, 10)); // 20 

sum = null;
console.log(anotherSum(10, 10)); // 20
```

- 使用不带括号的函数名会访问什么？

  - 函数指针，
  - 而不会执行函数。

- anotherSum和sum是否指向同一个函数？

  - 是

- ECMAScript 6的所有函数对象都会暴露一个什么属性？

  - 一个只读的name属性，

- name属性保存什么？ 

  - 一个函数标识符，
    - 一个字符串化的变量名。

- 如果函数没有名称，name属性会显示什么？

  - 空字符串

- 如果它是使用Function构造函数创建的

  则name属性会标识成什么？

  - "anonymous"

```
function foo() {} 
let bar = function() {}; 
let baz = () => {};

console.log(foo.name); // foo 
console.log(bar.name); // bar 
console.log(baz.name); // baz 

console.log((() => {}).name); //（空字符串）

console.log((new Function()).name); // anonymous
```

- 如果函数是一个获取函数、设置函数、使用bind()实例化，

  那么name属性会保存什么？

  - 标识符前面会加上一个前缀：

```
function foo() {}

console.log(foo.bind(null).name); // bound foo 

let dog = { 
	years: 1, 
	get age() { 
		return this.years; 
	},
	set age(newAge) { 
		this.years = newAge; 
	}
}

let propertyDescriptor = Object.getOwnPropertyDescriptor(dog, 'age'); 

console.log(propertyDescriptor.get.name); // get age

console.log(propertyDescriptor.set.name); // set age
```

## **10.3** 理解参数

- ECMAScript函数是否关心传入的参数个数？

  - 不关心

- ECMAScript函数是否不关心这些参数的数据类型？

  - 不关心

- 定义函数时要接收两个参数，

  是否意味着调用时就传两个参数？

  - 否

- 如果传一个、三个，甚至一个也不传参数，解释器是否会报错？
  - 不会 

- 为什么会这样？

  - 因为ECMAScript函数的参数在内部表现为一个数组。

  - 函数被调用时总会接收一个数组，

    但函数并不关心这个数组中包含什么。

    - 如果数组中什么也没有，那没问题；
    - 如果数组的元素超出了要求，那也没问题。

- 在使用function关键字定义（非箭头）函数时，

  可以在函数内部访问什么对象，

  从中取得传进来的每个参数值？

  - arguments对象

- arguments对象是一个什么对象？
  - 类数组对象
  - （但不是Array的实例）
- 是否可以使用中括号语法访问arguments对象的元素？
  - 可以
  - （第一个参数是arguments[0]，
  - 第二个参数是arguments[1]）。
- 如何确定传进来多少个参数？
  - 可以访问arguments.length属性。 

```
function sayHi(name, message) { 
	console.log("Hello " + name + ", " + message);
}
```

- 可以通过什么取得name参数值？
  - arguments[0]
- 是否可以把函数重写成不声明参数？
  - 可以

```
function sayHi() { 
	console.log("Hello " + arguments[0] + ", " + arguments[1]); 
}
```

- ECMAScript函数的参数是否是必须写出来的？

  - 不是

- 在ECMAScript中的命名参数是否会创建

  让之后的调用

  必须匹配的函数签名？为什么？

  - 不会

  - 因为根本不存在验证命名参数的机制。

- 可以通过什么检查传入的参数个数？
  - arguments对象的length属性

```
function howManyArgs() { 	
	console.log(arguments.length);
}
howManyArgs("string", 45); // 2 
howManyArgs(); // 0 
howManyArgs(12); // 1
```

```
function doAdd() { 
	if (arguments.length === 1) { 
		console.log(arguments[0] + 10); 
	} else if (arguments.length === 2) { 
		console.log(arguments[0] + arguments[1]); 
	}
}
doAdd(10); // 20 
doAdd(30, 20); // 50
```

- arguments对象是否可以跟命名参数一起使用？
  - 可以

```
function doAdd(num1, num2) { 
	if (arguments.length === 1) { 
		console.log(num1 + 10); 
	} else if (arguments.length === 2) { 
		console.log(arguments[0] + num2); 
	}
}
```

- arguments的值是否会与对应的命名参数同步？
  - 是

```
function doAdd(num1, num2) {
	arguments[1] = 10;
    console.log(arguments[0] + num2); 
}
```

- num2是否也会修改值？

  - 会
  - 因为arguments对象的值会自动同步到对应的命名参数，
  - 因此两者的值都是10。

- num2和arguments[1]是否访问同一个内存地址？

  - 不是
  - 它们在内存中是分开的，只不过会保持同步而已。

- 如果只传了一个参数，然后把arguments[1]设置为某个值，

  那么 这个值是否会反映到第二个命名参数？

  - 不会

  - 因为arguments对象的长度是根据

    传入的参数个数确定的

    - 而非定义函数时给出的命名参数个数确定

- 对于命名参数而言，

  如果调用函数时没有传这个参数，

  那么它的值就是什么？

  - undefined

  - 类似于定义了变量而没有初始化。

- 严格模式下，arguments[1]赋值是否会影响num2的值？

  - 不会

- 严格模式下，在函数中尝试重写arguments对象会发生什么？

  - 导致语法错误。（代码也不会执行。） 

### 箭头函数中的参数 

- 如果函数是使用箭头语法定义的，

  那么传给函数的参数是否能使用arguments关键字访问？

  - 不能

  - 只能通过定义的命名参数访问。

```
function foo() { 
	console.log(arguments[0]);
}

foo(5); // 5 

let bar = () => { 
	console.log(arguments[0]);
};

bar(5);
// ReferenceError: arguments is not defined
```

- 如果把arguments对象提供给箭头函数？
  - 在包装函数中实现

```
function foo() { 

	let bar = () => { 
		console.log(arguments[0]); // 5
	};
	
	bar();
}

foo(5);
```

- 注意 ECMAScript中的所有参数都怎么传递的？
  - 按值传递的
- 是否可能按引用传递参数？
  - 不可能
- 如果把对象作为参数传递，那么传递的值是什么？
  - 这个对象的引用。

## **10.4** 没有重载

- 什么是签名？
  - （接收参数的类型和数量）
- ECMAScript函数是否有签名？为什么？
  - 没有
  - 因为参数是由包含零个或多个值的数组表示的。
- ECMAScript函数是否有重载？为什么？
  - 没有
  - 没有函数签名，自然也就没有重载。 

- 如果在ECMAScript中定义了两个同名函数，

  则会发生什么？

  - 后定义的会覆盖先定义的。 

```
function addSomeNumber(num) { 
	return num + 100; 
}
function addSomeNumber(num) { 
	return num + 200; 
}
let result = addSomeNumber(100); // 300
```

```
let addSomeNumber = function(num) { 
	return num + 100; 
};
addSomeNumber = function(num) {
	return num + 200; 
};
let result = addSomeNumber(100); // 300
```

- 如何模拟函数重载？

  - 可以通过检查参数的类型和数量，

  - 然后分别执行不同的逻辑

## **10.5** 默认参数值 

- ECMAScript 6之后是否支持显式定义默认参数？
  - 是
- 如何为参数赋一个默认值？
  - 只要在函数定义中的参数后面用=就可以

```
function makeKing(name = 'Henry') {
	return `King ${name} VIII`; 
}
console.log(makeKing('Louis')); // 'King Louis VIII' console.log(makeKing()); // 'King Henry VIII'
```

- 给参数传undefined相当于什么？
  - 没有传值，
  - 不过这样可以利用多个独立的默认值： 

```
function makeKing(name = 'Henry', numerals = 'VIII') { 
	return `King ${name} ${numerals}`; 
}
console.log(makeKing()); // 'King Henry VIII' console.log(makeKing('Louis')); // 'King Louis VIII' console.log(makeKing(undefined, 'VI')); // 'King Henry VI'
```

- 在使用默认参数时，

  arguments对象的值是否会反映参数的默认值？

  - 不反映

- arguments对象只反映什么参数？

  - 传给函数的参数。

- 修改命名参数是否会影响arguments对象？

  - 不会

- arguments对象始终以值为准？

  - 调用函数时传入的值

```
function makeKing(name = 'Henry') { 
	name = 'Louis'; 
	return `King ${arguments[0]}`; 
}
console.log(makeKing()); // 'King undefined' console.log(makeKing('Louis')); // 'King Louis'
```

- 默认参数值是否限于原始值或对象类型？

  - 不限于

  - 也可以使用调用函数返回的值：

```
let romanNumerals = ['I', 'II', 'III', 'IV', 'V', 'VI']; 

let ordinality = 0; 

function getNumerals() { 
	// 每次调用后递增 
	return romanNumerals[ordinality++];
}

function makeKing(name = 'Henry', 
numerals = getNumerals()) { 
	return `King ${name} ${numerals}`; 
}	

console.log(makeKing()); // 'King Henry I' 

console.log(makeKing('Louis', 'XVI')); // 'King Louis XVI' 

console.log(makeKing()); // 'King Henry II' 

console.log(makeKing()); // 'King Henry III'
```

- 函数的默认参数只有在什么时候才会求值？

  - 函数被调用时

- 函数的默认参数是否会在函数定义时求值？

  - 不会

- 计算默认值的函数只有在什么时候才会被调用？

  - 调用函数

    但未传相应参数时

- 箭头函数是否可以这样使用默认参数？

  - 可以

- 箭头函数在使用默认参数并且只有一个参数时，

  是否可以省略括号？

  - 不可以 

```
let makeKing = (name = 'Henry') => `King ${name}`; console.log(makeKing()); // King Henry
```

### 默认参数作用域与暂时性死区 

- 函数参数是否是在某个作用域中求值的？

  - 是

- 在求值默认参数时是否可以定义对象？

  - 可以

- 是否可以动态调用函数？

  - 可以

- 给多个参数定义默认值实际上跟

  使用什么关键字一样？

  - let关键字顺序声明变量

```
function makeKing(name = 'Henry', numerals = 'VIII') { 
	return `King ${name} ${numerals}`; 
}
console.log(makeKing()); // King Henry VIII
```

- 这里的默认参数会按照什么顺序依次被初始化？
  - 定义它们的顺序

```
function makeKing() { 
	let name = 'Henry'; 
	let numerals = 'VIII';
    return `King ${name} ${numerals}`; 
}
```

- 后定义默认值的参数是否可以引用先定义的参数？
  - 可以
  - 因为参数是按顺序初始化的

```
function makeKing(name = 'Henry', numerals = name) { 	return `King ${name} ${numerals}`; 
}
console.log(makeKing()); // King Henry Henry
```

- 参数初始化顺序遵循什么规则？
  - “暂时性死区”
- 什么是“暂时性死区”？
  - 即前面定义的参数不能引用后面定义的。

```
// 调用时不传第一个参数会报错
function makeKing(name = numerals, numerals = 'VIII') { 
	return `King ${name} ${numerals}`;
}
```

- 参数存在于自己的作用域中，它们是否能引用函数体的作用域？
  - 不能

```
// 调用时不传第二个参数会报错
function makeKing(name = 'Henry', numerals = defaultNumeral) { 
	let defaultNumeral = 'VIII'; 
	return `King ${name} ${numerals}`; 
}
```

## **10.6** 参数扩展与收集 

- ECMAScript 6新增了扩展操作符，

  使用它可以做什么？

  - 操作和组合集合数据

- 扩展操作符最有用的场景就是什么？
  - 函数定义中的参数列表
- 扩展操作符充分利用这门语言的什么特点？
  - 弱类型
  - 参数长度可变
- 扩展操作符可以用于什么？
  - 调用函数时传参
  - 定义函数参数。

### **10.6.1** 扩展参数

- 假设有如下函数定义，它会将所有传入的参数累加起来： 

```
let values = [1, 2, 3, 4]; 
function getSum() { 
	let sum = 0; 
	for (let i = 0; i < arguments.length; ++i) {
    	sum += arguments[i]; 
    }
    return sum; 
}
```

- 对可迭代对象应用扩展操作符，

  并将其作为一个参数传入，会发生什么？

  - 可以将可迭代对象拆分，

  - 并将迭代返回的每个值单独传入。 

```
console.log(getSum(...values)); // 10
```

- 在对数组使用扩展操作符传参的时候，

  是否可以在其前面或后面再传其他的值？

  为什么？

  - 可以，
  - 因为数组的长度已知

```
console.log(getSum(-1, ...values)); // 9 console.log(getSum(...values, 5)); // 15 console.log(getSum(-1, ...values, 5)); // 14 console.log(getSum(...values, ...[5,6,7])); // 28
```

```
let values = [1,2,3,4] 
function countArguments() { 
	console.log(arguments.length); 
}
countArguments(-1, ...values); // 5 countArguments(...values, 5); // 5 countArguments(-1, ...values, 5); // 6 countArguments(...values, ...[5,6,7]); // 7
```

- 在普通函数和箭头函数中是否可以将扩展操作符用于命名参数？
  - 可以
- 是否可以同时使用默认参数和扩展操作符？
  - 可以

```
function getProduct(a, b, c = 1) { 
	return a * b * c;
}
let getSum = (a, b, c = 0) => {
	return a + b + c; 
}
console.log(getProduct(...[1,2])); // 2 console.log(getProduct(...[1,2,3])); // 6 console.log(getProduct(...[1,2,3,4])); // 6 

console.log(getSum(...[0,1])); // 1 console.log(getSum(...[0,1,2])); // 3 console.log(getSum(...[0,1,2,3])); // 3
```

### **10.6.2** 收集参数

- 如何把不同长度的独立参数组合为一个数组？
  - 使用扩展操作符

```
function getSum(...values) {
	// 顺序累加values中的所有值
    // 初始值的总和为0 
    return values.reduce((x, y) => x + y, 0);
}
console.log(getSum(1,2,3)); // 6
```

- 收集参数的前面如果还有命名参数，则会怎么处理？
  - 只会收集其余的参数；
- 如果没有传入，则会得到一个什么？
  - 空数组。
- 为什么只能把收集参数作为最后一个参数？
  - 因为收集参数的结果可变，所以 

```
// 不可以 
function getProduct(...values, lastValue) {}

// 可以
function ignoreFirst(firstValue, ...values) { 
	console.log(values);
}
ignoreFirst(); // [] 
ignoreFirst(1); // []
ignoreFirst(1,2); // [2] 
ignoreFirst(1,2,3); // [2, 3]
```

- 箭头函数是否支持arguments对象？
  - 不支持
- 箭头函数是否支持收集参数的定义方式？
  - 支持
- 箭头函数如何实现与使用arguments一样的逻辑？

```
let getSum = (...values) => { 
	return values.reduce((x, y) => x + y, 0); 
}
console.log(getSum(1,2,3)); // 6
```

- 使用收集参数是否影响arguments对象？
  - 不影响
- arguments反映什么参数？
  - 调用时传给函数的参数

```
function getSum(...values) { 	

	console.log(arguments.length); // 3 	
    
	console.log(arguments); // [1, 2, 3] 
	
	console.log(values); // [1, 2, 3]
}
console.log(getSum(1,2,3))
```

