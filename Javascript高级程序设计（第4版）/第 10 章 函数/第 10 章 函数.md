# 第 **10** 章 函数

- 本章内容

  - 函数表达式、函数声明、箭头函数 

  - 默认参数及扩展操作符 

  - 使用函数实现递归 

  - 使用闭包实现私有变量 
- 函数实际上是什么数据类型？
  - 对象
- 每个函数都是什么类型的实例？
  - Function类型
- Function是否有属性和方法？
  - 有
    - 跟其他引用类型一样。

- 因为函数是对象，所以函数名是什么？
  - 指向函数对象的指针，
  - 而且不一定与函数本身紧密绑定。
- 函数通常以什么方式定义？
  - 函数声明的方式

```
function sum (num1, num2) { 
	return num1 + num2;
}
```

- 函数定义最后是否有加分号？
  - 没有
- 另一种定义函数的语法是什么？
  - 函数表达式
- 函数表达式与函数声明是否是等价的？
  - 是

```
let sum = function(num1, num2) { 
	return num1 + num2; 
};
```

- 为什么function关键字后面没有名称？
  - 因为不需要。
    - 这个函数可以通过变量sum来引用
- 为什么这里的函数末尾是有分号的？
  - 因为与任何变量初始化语句一样。 
- 还有一种定义函数的方式，叫作什么？
  - “箭头函数”

```
let sum = (num1, num2) => {
	return num1 + num2; 
};
```

- 最后一种定义函数的方式是使用什么构造函数？
  - Function构造函数。
- 这个构造函数接收什么参数？ 
  - 任意多个字符串参数，
  - 最后一个参数始终会被当成函数体，
  - 而之前的参数都是新函数的参数。

```
let sum = new Function("num1", "num2", "return num1 + num2"); // 不推荐
```

- 为什么不推荐使用这种语法来定义函数？
  - 因为这段代码会被解释两次：
    - 第一次是将它当作常规ECMAScript代码，
    - 第二次是解释传给构造函数的字符串。
  - 这显然会影响性能。
- 这几种实例化函数对象的方式之间是否存在差别？
  - 是
  - 存在微妙但重要的差别

## **10.1** 箭头函数 

- ECMAScript 6新增了使用什么语法定义函数表达式的能力？

  - 胖箭头（=>）语法

- 箭头函数实例化的函数对象与

  正式的函数表达式创建的函数对象行为有什么区别？

  - 相同的

- 任何可以使用函数表达式的地方，是否都可以使用箭头函数？

  - 是

```
let arrowSum = (a, b) => { 
	return a + b; 
};
let functionExpressionSum = function(a, b) { 
	return a + b; 
};
console.log(arrowSum(5, 8)); // 13 console.log(functionExpressionSum(5, 8)); // 13
```

-  箭头函数简洁的语法非常适合什么场景？
  - 嵌入函数的场景

```
let ints = [1, 2, 3]; console.log(ints.map(function(i) { 
	return i + 1; 
})); // [2, 3, 4]

console.log(ints.map((i) => { 
	return i + 1 
})); // [2, 3, 4]
```

-  如果只有一个参数，那是否可以不用括号？
  - 可以
- 只有什么的情况下，才需要使用括号？
  - 没有参数
  - 多个参数 

```
// 以下两种写法都有效 
let double = (x) => { 
	return 2 * x; 
};
let triple = x => { 
	return 3 * x; 
};
// 没有参数需要括号 
let getRandom = () => { 
	return Math.random();
};
// 多个参数需要括号 
let sum = (a, b) => { 
	return a + b; 
};
// 无效的写法： 
let multiply = a, b => { 
	return a * b; 
};
```

- 箭头函数是否可以不用大括号？
  - 可以
  - 但这样会改变函数的行为。
- 使用大括号就说明什么？
  - 包含“函数体”，
    - 可以在一个函数中包含多条语句，
    - 跟常规的函数一样。
- 如果不使用大括号，那么箭头后面能有几行代码？
  - 一行代码
- 省略大括号会隐式返回什么？
  - 这行代码的值

```
// 以下两种写法都有效，而且返回相应的值 
let double = (x) => { 
	return 2 * x; 
};
let triple = (x) => 3 * x; 

// 可以赋值 
let value = {}; 

let setName = (x) => x.name = "Matt"; 

setName(value); 

console.log(value.name); // "Matt"

// 无效的写法： 
let multiply = (a, b) => return a * b;
```

- 箭头函数不能使用什么？
  - arguments
  - super
  - new.target
- 箭头函是否能用作构造函数？
  - 不能
- 箭头函数是否有prototype属性？
  - 没有

## **10.2** 函数名

- 函数名是否跟

  包含对象指针的变量 

  具有相同的行为？

  - 是
  - 因为函数名就是指向函数的指针

- 一个函数是否可以有多个名称？
  - 可以

```
function sum(num1, num2) {
	return num1 + num2; 
}
console.log(sum(10, 10)); // 20 

let anotherSum = sum; 
console.log(anotherSum(10, 10)); // 20 

sum = null;
console.log(anotherSum(10, 10)); // 20
```

- 使用不带括号的函数名会访问什么？

  - 函数指针，
  - 而不会执行函数。

- anotherSum和sum是否指向同一个函数？

  - 是

- ECMAScript 6的所有函数对象都会暴露一个什么属性？

  - 一个只读的name属性，

- name属性保存什么？ 

  - 一个函数标识符，
    - 一个字符串化的变量名。

- 如果函数没有名称，name属性会显示什么？

  - 空字符串

- 如果它是使用Function构造函数创建的

  则name属性会标识成什么？

  - "anonymous"

```
function foo() {} 
let bar = function() {}; 
let baz = () => {};

console.log(foo.name); // foo 
console.log(bar.name); // bar 
console.log(baz.name); // baz 

console.log((() => {}).name); //（空字符串）

console.log((new Function()).name); // anonymous
```

- 如果函数是一个获取函数、设置函数、使用bind()实例化，

  那么name属性会保存什么？

  - 标识符前面会加上一个前缀：

```
function foo() {}

console.log(foo.bind(null).name); // bound foo 

let dog = { 
	years: 1, 
	get age() { 
		return this.years; 
	},
	set age(newAge) { 
		this.years = newAge; 
	}
}

let propertyDescriptor = Object.getOwnPropertyDescriptor(dog, 'age'); 

console.log(propertyDescriptor.get.name); // get age

console.log(propertyDescriptor.set.name); // set age
```

## **10.3** 理解参数

- ECMAScript函数是否关心传入的参数个数？

  - 不关心

- ECMAScript函数是否关心这些参数的数据类型？

  - 不关心

- 定义函数时要接收两个参数，

  是否意味着调用时就传两个参数？

  - 否

- 如果传一个、三个，甚至一个也不传参数，解释器是否会报错？
  - 不会 

- 为什么会这样？

  - 因为ECMAScript函数的参数在内部表现为一个数组。

  - 函数被调用时总会接收一个数组，

    但函数并不关心这个数组中包含什么。

    - 如果数组中什么也没有，那没问题；
    - 如果数组的元素超出了要求，那也没问题。

- 在使用function关键字定义（非箭头）函数时，

  可以在函数内部访问什么对象，

  从中取得传进来的每个参数值？

  - arguments对象

- arguments对象是一个什么对象？
  - 类数组对象
    - （但不是Array的实例）
  
- 可以使用什么语法访问arguments对象的元素？
  - 中括号语法
    - （第一个参数是arguments[0]，
    - 第二个参数是arguments[1]）。

```
function sayHi(name, message) { 
	console.log("Hello " + name + ", " + message);
}
```

- 可以通过什么取得name参数值？
  - arguments[0]
- 是否可以把函数重写成不声明参数？
  - 可以

```
function sayHi() { 
	console.log("Hello " + arguments[0] + ", " + arguments[1]); 
}
```

- ECMAScript函数的参数是否是必须写出来的？

  - 不是

- 在ECMAScript中的命名参数是否会创建

  让之后的调用

  必须匹配的函数签名？为什么？

  - 不会
  - 因为根本不存在验证命名参数的机制。

- 如何确定传进来多少个参数？

  - 可以访问arguments.length属性。 

```
function howManyArgs() { 	
	console.log(arguments.length);
}
howManyArgs("string", 45); // 2 
howManyArgs(); // 0 
howManyArgs(12); // 1
```

```
function doAdd() { 
	if (arguments.length === 1) { 
		console.log(arguments[0] + 10); 
	} else if (arguments.length === 2) { 
		console.log(arguments[0] + arguments[1]); 
	}
}
doAdd(10); // 20 
doAdd(30, 20); // 50
```

- arguments对象是否可以跟命名参数一起使用？
  - 可以

```
function doAdd(num1, num2) { 
	if (arguments.length === 1) { 
		console.log(num1 + 10); 
	} else if (arguments.length === 2) { 
		console.log(arguments[0] + num2); 
	}
}
```

- arguments的值是否会与对应的命名参数同步？
  - 是

```
function doAdd(num1, num2) {
	arguments[1] = 10;
    console.log(arguments[0] + num2); 
}
```

- num2是否也会修改值？

  - 会
  - 因为arguments对象的值会自动同步到对应的命名参数，
  - 因此两者的值都是10。

- num2和arguments[1]是否访问同一个内存地址？

  - 不是
  - 它们在内存中是分开的，只不过会保持同步而已。

- 如果只传了一个参数，然后把arguments[1]设置为某个值，

  那么 这个值是否会反映到第二个命名参数？

  - 不会

  - 因为arguments对象的长度是根据

    传入的参数个数确定的

    - 而非定义函数时给出的命名参数个数

- 对于命名参数而言，

  如果调用函数时没有传这个参数，

  那么它的值就是什么？

  - undefined

  - 类似于定义了变量而没有初始化。

- 严格模式下，arguments[1]赋值是否会影响num2的值？

  - 不会

- 严格模式下，在函数中尝试重写arguments对象会发生什么？

  - 导致语法错误。（代码也不会执行。） 

### 箭头函数中的参数 

- 如果函数是使用箭头语法定义的，

  那么传给函数的参数是否能使用arguments关键字访问？

  - 不能

  - 只能通过定义的命名参数访问。

```
function foo() { 
	console.log(arguments[0]);
}

foo(5); // 5 

let bar = () => { 
	console.log(arguments[0]);
};

bar(5);
// ReferenceError: arguments is not defined
```

- 如何把arguments对象提供给箭头函数？
  - 在包装函数中实现

```
function foo() { 

	let bar = () => { 
		console.log(arguments[0]); // 5
	};
	
	bar();
}

foo(5);
```

- 注意 ECMAScript中的所有参数都怎么传递的？
  - 按值传递的
- 是否可能按引用传递参数？
  - 不可能
- 如果把对象作为参数传递，那么传递的值是什么？
  - 这个对象的引用。

## **10.4** 没有重载

- 什么是签名？
  - （接收参数的类型和数量）
- ECMAScript函数是否有签名？为什么？
  - 没有
  - 因为参数是由包含零个或多个值的数组表示的。
- ECMAScript函数是否有重载？为什么？
  - 没有
  - 没有函数签名，自然也就没有重载。 

- 如果在ECMAScript中定义了两个同名函数，

  则会发生什么？

  - 后定义的会覆盖先定义的。 

```
function addSomeNumber(num) { 
	return num + 100; 
}
function addSomeNumber(num) { 
	return num + 200; 
}
let result = addSomeNumber(100); // 300
```

```
let addSomeNumber = function(num) { 
	return num + 100; 
};
addSomeNumber = function(num) {
	return num + 200; 
};
let result = addSomeNumber(100); // 300
```

- 如何模拟函数重载？

  - 可以通过检查参数的类型和数量，

  - 然后分别执行不同的逻辑

## **10.5** 默认参数值 

- ECMAScript 6之后是否支持显式定义默认参数？
  - 是
- 如何为参数赋一个默认值？
  - 只要在函数定义中的参数后面用=就可以

```
function makeKing(name = 'Henry') {
	return `King ${name} VIII`; 
}
console.log(makeKing('Louis')); // 'King Louis VIII' console.log(makeKing()); // 'King Henry VIII'
```

- 给参数传undefined相当于什么？
  - 没有传值，
  - 不过这样可以利用多个独立的默认值： 

```
function makeKing(name = 'Henry', numerals = 'VIII') { 
	return `King ${name} ${numerals}`; 
}
console.log(makeKing()); // 'King Henry VIII' console.log(makeKing('Louis')); // 'King Louis VIII' console.log(makeKing(undefined, 'VI')); // 'King Henry VI'
```

- 在使用默认参数时，

  arguments对象的值是否会反映参数的默认值？

  - 不反映

- arguments对象只反映什么参数？

  - 传给函数的参数。

- 修改命名参数是否会影响arguments对象？

  - 不会

- arguments对象始终以值为准？

  - 调用函数时传入的值

```
function makeKing(name = 'Henry') { 
	name = 'Louis'; 
	return `King ${arguments[0]}`; 
}
console.log(makeKing()); // 'King undefined' console.log(makeKing('Louis')); // 'King Louis'
```

- 默认参数值是否只能使用原始值或对象类型？

  - 不限于
    - 也可以使用调用函数返回的值：
  

```
let romanNumerals = ['I', 'II', 'III', 'IV', 'V', 'VI']; 

let ordinality = 0; 

function getNumerals() { 
	// 每次调用后递增 
	return romanNumerals[ordinality++];
}

function makeKing(name = 'Henry', 
numerals = getNumerals()) { 
	return `King ${name} ${numerals}`; 
}	

console.log(makeKing()); // 'King Henry I' 

console.log(makeKing('Louis', 'XVI')); // 'King Louis XVI' 

console.log(makeKing()); // 'King Henry II' 

console.log(makeKing()); // 'King Henry III'
```

- 函数的默认参数只有在什么时候才会求值？

  - 函数被调用时

- 函数的默认参数是否会在函数定义时求值？

  - 不会

- 计算默认值的函数只有在什么时候才会被调用？

  - 调用函数

    但未传相应参数时

- 箭头函数是否可以使用默认参数？

  - 可以

- 箭头函数在使用默认参数并且只有一个参数时，

  是否可以省略括号？

  - 不可以 

```
let makeKing = (name = 'Henry') => `King ${name}`; 

console.log(makeKing()); // King Henry
```

### 默认参数作用域与暂时性死区 

- 函数参数是否是在某个作用域中求值的？

  - 是

- 在求值默认参数时是否可以定义对象？

  - 可以

- 是否可以动态调用函数？

  - 可以

- 给多个参数定义默认值

  实际上跟使用什么关键字一样？

  - let关键字顺序声明变量

```
function makeKing(name = 'Henry', numerals = 'VIII') { 
	return `King ${name} ${numerals}`; 
}
console.log(makeKing()); // King Henry VIII
```

- 这里的默认参数会按照什么顺序依次被初始化？
  - 定义它们的顺序

```
function makeKing() { 
	let name = 'Henry'; 
	let numerals = 'VIII';
    return `King ${name} ${numerals}`; 
}
```

- 后定义默认值的参数是否可以引用先定义的参数？
  - 可以
  - 因为参数是按顺序初始化的

```
function makeKing(name = 'Henry', numerals = name) { 	return `King ${name} ${numerals}`; 
}
console.log(makeKing()); // King Henry Henry
```

- 参数初始化顺序遵循什么规则？
  - “暂时性死区”
- 什么是“暂时性死区”？
  - 即前面定义的参数不能引用后面定义的。

```
// 调用时不传第一个参数会报错
function makeKing(name = numerals, numerals = 'VIII') { 
	return `King ${name} ${numerals}`;
}
```

- 参数存在于自己的作用域中，它们是否能引用函数体的作用域？
  - 不能

```
// 调用时不传第二个参数会报错
function makeKing(name = 'Henry', numerals = defaultNumeral) { 
	let defaultNumeral = 'VIII'; 
	return `King ${name} ${numerals}`; 
}
```

## **10.6** 参数扩展与收集 

- ECMAScript 6新增了扩展操作符，

  使用它可以做什么？

  - 操作和组合集合数据

- 扩展操作符最有用的场景就是什么？
  - 函数定义中的参数列表
- 扩展操作符充分利用这门语言的什么特点？
  - 弱类型
  - 参数长度可变
- 扩展操作符可以用于什么？
  - 调用函数时传参
  - 定义函数参数。

### **10.6.1** 扩展参数

- 假设有如下函数定义，它会将所有传入的参数累加起来： 

```
let values = [1, 2, 3, 4]; 
function getSum() { 
	let sum = 0; 
	for (let i = 0; i < arguments.length; ++i) {
    	sum += arguments[i]; 
    }
    return sum; 
}
```

- 对可迭代对象应用扩展操作符，

  并将其作为一个参数传入，会发生什么？

  - 将可迭代对象拆分，

  - 并将迭代返回的每个值单独传入。 

```
console.log(getSum(...values)); // 10
```

- 在对数组使用扩展操作符传参的时候，

  是否可以在其前面或后面再传其他的值？

  为什么？

  - 可以，
  - 因为数组的长度已知

```
console.log(getSum(-1, ...values)); // 9 console.log(getSum(...values, 5)); // 15 console.log(getSum(-1, ...values, 5)); // 14 console.log(getSum(...values, ...[5,6,7])); // 28
```

```
let values = [1,2,3,4] 
function countArguments() { 
	console.log(arguments.length); 
}
countArguments(-1, ...values); // 5 countArguments(...values, 5); // 5 countArguments(-1, ...values, 5); // 6 countArguments(...values, ...[5,6,7]); // 7
```

- 在普通函数和箭头函数中是否可以将扩展操作符用于命名参数？
  - 可以
- 是否可以同时使用默认参数和扩展操作符？
  - 可以

```
function getProduct(a, b, c = 1) { 
	return a * b * c;
}
let getSum = (a, b, c = 0) => {
	return a + b + c; 
}
console.log(getProduct(...[1,2])); // 2 console.log(getProduct(...[1,2,3])); // 6 console.log(getProduct(...[1,2,3,4])); // 6 

console.log(getSum(...[0,1])); // 1 console.log(getSum(...[0,1,2])); // 3 console.log(getSum(...[0,1,2,3])); // 3
```

### **10.6.2** 收集参数

- 如何把不同长度的独立参数组合为一个数组？
  - 使用扩展操作符

```
function getSum(...values) {
	// 顺序累加values中的所有值
    // 初始值的总和为0 
    return values.reduce((x, y) => x + y, 0);
}
console.log(getSum(1,2,3)); // 6
```

- 收集参数的前面如果还有命名参数，则会怎么处理？
  - 只会收集其余的参数；
- 如果没有传入，则会得到一个什么？
  - 空数组。
- 为什么只能把收集参数作为最后一个参数？
  - 因为收集参数的结果可变，所以 

```
// 不可以 
function getProduct(...values, lastValue) {}

// 可以
function ignoreFirst(firstValue, ...values) { 
	console.log(values);
}
ignoreFirst(); // [] 
ignoreFirst(1); // []
ignoreFirst(1,2); // [2] 
ignoreFirst(1,2,3); // [2, 3]
```

- 箭头函数是否支持arguments对象？
  - 不支持
- 箭头函数是否支持收集参数的定义方式？
  - 支持
- 箭头函数如何实现与使用arguments一样的逻辑？

```
let getSum = (...values) => { 
	return values.reduce((x, y) => x + y, 0); 
}
console.log(getSum(1,2,3)); // 6
```

- 使用收集参数是否影响arguments对象？
  - 不影响
- arguments反映什么参数？
  - 调用时传给函数的参数

```
function getSum(...values) { 	

	console.log(arguments.length); // 3 	
    
	console.log(arguments); // [1, 2, 3] 
	
	console.log(values); // [1, 2, 3]
}
console.log(getSum(1,2,3))
```

## **10.7**　函数声明与函数表达式

- 函数声明在什么时候生成函数定义？
  - 在任何代码执行之前
- 函数表达式在什么时候生成函数定义？
  - 代码执行到它那一行

```
// 没问题
console.log(sum(10, 10));

function sum(num1, num2) {
 	return num1 + num2;
}
```

- 为什么以上代码可以正常运行？

  - 因为函数声明会在任何代码执行之前

    先被读取

  - 并添加到执行上下文。

- 这个过程叫作什么？

  - 函数声明提升

- 在执行代码时，JavaScript引擎会怎么处理函数声明？

  - 先执行一遍扫描
  - 把发现的函数声明提升到源代码树的顶部。

- 如果函数定义出现在调用它们的代码之后，引擎会怎么做？

  - 把函数声明提升到顶部

- 如果把前面代码中的函数声明改为等价的函数表达式，

  那么执行的时候就会发生什么？

  - 出错

```
// 会出错
console.log(sum(10, 10));

let sum = function(num1, num2) {
 	return num1 + num2;
};
```

- 上面的代码为什么会出错？

  - 是因为这个函数定义包含在一个变量初始化语句中，
  - 而不是函数声明中。

- 代码如果没有执行到加粗的那一行，

  那么执行上下文中是否有函数的定义？

  - 没有

- 这并是否是因为使用let而导致的？
  - 不是
- 使用var关键字是否会碰到同样的问题？
  - 会

```
console.log(sum(10, 10));

var sum = function(num1, num2) {
 	return num1 + num2;
}
```

- 在使用函数表达式初始化变量时，是否可以给函数一个名称？
  - 可以

```
let sum = function sum() {}
```

## **10.8** 函数作为值

- 函数是否可以用在任何可以使用变量的地方？
  - 可以
  - 因为函数名在ECMAScript中就是变量
- 是否可以把函数作为参数传给另一个函数？
  - 可以
- 是否可以在一个函数中返回另一个函数？
  - 可以

```
function callSomeFunction(someFunction, someArgument) {
	return someFunction(someArgument); 
}
```

- 任何函数都可以像下面这样作为参数传递： 

```
function add10(num) {
	return num + 10;
}

let result1 = callSomeFunction(add10, 10);

console.log(result1); // 20 

function getGreeting(name) {
	return "Hello, " + name; 
}

let result2 = callSomeFunction(getGreeting, "Nicholas"); 

console.log(result2); // "Hello, Nicholas"
```

- 如果是访问函数而不是调用函数，那必须做什么？

  - 不带括号

- 如果有一个包含对象的数组，

  如何按照任意对象属性对数组进行排序？ 

  - 定义一个函数接收两个参数：
    - 两个要比较的值

  - 定义一个根据属性名创建的函数 

```
function createComparisonFunction(propertyName) {

    return function (object1, object2) {

        let value1 = object1[propertyName];

        let value2 = object2[propertyName];

        if (value1 < value2) {
            return -1;
            
        } else if (value1 > value2) {
            return 1;
            
        } else {
            return 0;
        }
    };
}
```

- 如何使用这个函数？

```
let data = [{
    name: "Zachary",
    age: 28
}, {
    name: "Nicholas",
    age: 29
}];

data.sort(createComparisonFunction("name"));

console.log(data[0].name); // Nicholas 

data.sort(createComparisonFunction("age"));

console.log(data[0].name); // Zachary
```

- 默认情况下，sort()方法要对这两个对象执行什么？
  - 执行toString()，
  - 然后再决定它们的顺序，

## **10.9** 函数内部 

- 在ECMAScript 5中，函数内部存在哪两个特殊的对象？
  - arguments
  - this
- ECMAScript 6函数内部又新增了什么属性？
  - new.target 属性

### **10.9.1** **arguments**

- arguments对象是一个什么对象？
  - 类数组对象
- arguments对象包含什么？
  - 调用函数时传入的所有参数。
- arguments对象只有以什么关键字定义函数时才会有？
  - function关键字

- arguments对象主要用于什么？
  - 包含函数参数， 

- arguments对象的callee属性，是什么？
  - 一个指向arguments对象所在函数的指针

```
function factorial(num) {
    if (num <= 1) {
        return 1;
    } else {
        return num * factorial(num - 1);
    }
}
```

- 这个函数要正确执行就必须保证什么？
  - 函数名是factorial
- 这导致了什么问题？
  - 紧密耦合

- 如何让函数逻辑与函数名解耦？
  - 使用arguments.callee

```
function factorial(num) {
    if (num <= 1) {
        return 1;
    } else {
        return num * arguments.callee(num - 1);
    }
}
```

- 使用arguments.callee意味着什么？
  - 无论函数叫什么名称，都可以引用正确的函数。

```
let trueFactorial = factorial;

factorial = function () {
    return 0;
};

console.log(trueFactorial(5)); // 120 

console.log(factorial(5)); // 0
```

- 如果像factorial()最初的版本那样不使用arguments.callee，

  那么像上面这样调用trueFactorial()就会返回什么？

  - 0。

### **10.9.2** **this** 

- 在标准函数中，this引用的是什么？

  - 把函数当成方法调用的

    上下文对象，

- 在网页的全局上下文中调用函数时，this指向什么？

  - windows

```
window.color = 'red';

let o = {
    color: 'blue'
};

function sayColor() {
    console.log(this.color);
}

sayColor(); // 'red'

o.sayColor = sayColor; 

o.sayColor(); // 'blue'
```

- 这个this引用哪个对象必须到什么时候才能确定？
  - 函数被调用时
- this值在代码执行的过程中是否可能会变？
  - 是
- 在箭头函数中，this引用的是什么？
  - 定义箭头函数的上下文。

```
window.color = 'red';

let o = {
    color: 'blue'
};

let sayColor = () => console.log(this.color);

sayColor(); // 'red'

o.sayColor = sayColor; 

o.sayColor(); // 'red'
```

- 在对sayColor()的两次调用中，

  为什么this引用的都是window对象，

  - 因为这个箭头函数是在window上下文中定义的：

-  箭头函数中的this会保留什么上下文？
  - 定义该函数时的上下文

```
function King() {
	// this引用King的实例 
    this.royaltyName = 'Henry'; 
    
    setTimeout(() => 
    	console.log(this.royaltyName), 1000);
}

function Queen() {
	// this引用window对象 
    this.royaltyName = 'Elizabeth'; 
    
    setTimeout(function () {
        console.log(this.royaltyName);
    }, 1000);
}

new King(); // Henry 
new Queen(); // undefined
```

### **10.9.3** **caller** 

- ECMAScript 5也会给函数对象上添加一个什么属性？
  - caller
- caller属性引用的是什么？
  - 调用当前函数的函数，
  - 如果是在全局作用域中调用的则为null

```
function outer() {
    inner();
}

function inner() {
    console.log(inner.caller);
}
outer();
```

- 以上代码会显示什么？
  - outer()函数的源代码。
- inner.caller指向什么？
  - outer()
- 如何降低耦合度？
  - 通过arguments.callee.caller来引用同样的值：

```
function outer() {
    inner();
}

function inner() {
    console.log(arguments.callee.caller);
}
outer();
```

- 在严格模式下访问arguments.callee会发生什么？
  - 报错
- 在非严格模式下arguments.callee是什么？
  - 始终是undefined
- 为什么？
  - 为了分清arguments.caller和函数的caller

- 严格模式下是否能给函数的caller属性赋值？
  - 不能

### **10.9.4** **new.target**

- ECMAScript中的函数可以作为什么实例化一个新对象？
  - 构造函数
- 如何检测函数是否使用new关键字调用？
  - 使用new.target属性
- 如果函数是正常调用的，则new.target的值是什么？
  - undefined
- 如果是使用new关键字调用的，则new.target将引用什么？
  - 被调用的构造函数

```
function King() {
    if (!new.target) {
        throw 'King must be instantiated using "new"'
    }
    
    console.log('King instantiated using "new"');
}

new King(); // King instantiated using "new" 

King(); 
// Error: King must be instantiated using "new"
```

