# 第 8 章 对象、类与面向对象编程

## 8.1 理解对象

- 创建自定义对象的通常方式是什么？
  - 创建Object的一个新实例，
  - 然后再给它添加属性和方法

```
let person = new Object(); 
person.name = "Nicholas"; 
person.age = 29; 
person.job = "Software Engineer"; 
person.sayName = function() { 			
	console.log(this.name); 
};
```

- 前面的例子如果使用对象字面量则可以这样写：

```
let person = { 
	name: "Nicholas", 
	age: 29, 
	job: "Software Engineer", 
	sayName() { 
		console.log(this.name); 
	} 
};
```



### 8.1.1 属性的类型

- 属性分哪两种？
  - 数据属性
  - 访问器属性。

#### \01. 数据属性 

- 数据属性有哪4个特性描述它们的行为？

  - [[Configurable]]：表示属性
    - 是否可以通过delete删除并重新定义，
    
    - 是否可以修改它的特性，
    
    - 是否可以把它改为访问器属性。
    
    - 默认情况下是true
    
  - [[Enumerable]]：表示属性
    - 是否可以通过for-in循环返回。
    
    - 默认情况下是true 
    
  - [[Writable]]：表示属性的值
    - 是否可以被修改。
    
    - 默认情况下 是true
    
  - [[Value]]：包含属性实际的值。
    - 读取和写入属性值的位置。
    - 默认值为undefined。
  
- 将属性显式添加到对象之后，

  [[Configurable]]、[[Enumerable]]、[[Writable]]、[[Value]]特性会被设置为什么值？

  - [[Configurable]]、[[Enumerable]]、[[Writable]]
    - 都会被设置为true
  - [[Value]]特性会被设置为指定的值。

```
let person = { name: "Nicholas" };
```

- [[Value]]特性会被设置为什么？
  - "Nicholas"
- 之后对这个值的任何修改都会保存在哪？
  - [[Value]]特性
- 要修改属性的默认特性，就必须使用什么方法？
  - Object.defineProperty()
- Object.defineProperty()方法接收哪3个参数？
  - 要给其添加属性的对象、
  - 属性的名称 
  - 一个描述符对象
- 描述符对象上的属性可以包含什么？
  - configurable、
  - enumerable、
  - writable
  - value，
  - 跟相关特性的名称一一对应
  - 根据要修改的特性，可以设置其中一个或多个值。 

```
let person = {}; 
Object.defineProperty(person, "name", {
	writable: false,
	value: "Nicholas" 
}); 
console.log(person.name); // "Nicholas" person.name = "Greg"; 
console.log(person.name); // "Nicholas"
```

- name属性的值是否能再修改？
  - 不能
- 在非严格模式下尝试给这个属性重新赋值会执行什么操作？
  - 会被忽略。
- 在严格模式下，尝试修改只读属性的值会执行什么操作？
  - 抛出错误
- 创建不可配置的属性

```
let person = {}; 
Object.defineProperty(person, "name", { 	
	configurable: false,
	value: "Nicholas" 
}); 
console.log(person.name); // "Nicholas" 
delete person.name;
console.log(person.name); // "Nicholas"
```

- 把configurable设置为false，意味着什么？
  - 这个属性不能从对象上删除
  - 非严格模式下对这个属性调用delete没有效果，
  - 严格模式下会抛出错误
- 一个属性被定义为不可配置之后，是否能再变回可配置的？
  - 不能
- 再次调用Object.defineProperty()并修改任何不可配置属性会发生什么？
  - 导致错误

```
let person = {}; 
Object.defineProperty(person, "name", {
	configurable: false, 
	value: "Nicholas" 
});
// 抛出错误 
Object.defineProperty(person, "name", { 
	configurable: true, 
	value: "Nicholas"
});
```

- 是否可以对同一个属性多次调用Object.defineProperty()？

  - 可以 

- 在调用Object.defineProperty()时，

  configurable、enumerable、writable的值如果不指定，

  则都默认为什么？

  - false

#### \02. 访问器属性

- 访问器属性是否包含数据值？

  - 不包含

- 它们包含什么？

  - 一个获取（getter）函数
  - 一个设置（setter）函数，

- 这两个函数是否必需的？

  - 不是

- 在什么时候会调用获取函数？

  - 读取访问器属性时

- 获取函数的责任是什么？

  - 返回一个有效的值。

- 在写入访问器属性时，会执行什么操作？

  - 调用设置函数并传入新值，

- 设置函数决定什么？

  - 对数据做出什么修改。

- 访问器属性有哪4个特性描述它们的行为？

  - [[Configurable]]：表示属性
    - 是否可以通过delete删除并重新定义，
    - 是否可以修改它的特性
    - 是否可以把它改为数据属性。
    - 默认情况下是true。 
  - [[Enumerable]]：表示属性
    - 是否可以通过for-in循环返回。
    - 默认情况下，是true。 

  - [[Get]]：获取函数，在读取属性时调用。
    - 默认值为undefined。 

  - [[Set]]：设置函数，在写入属性时调用。
    - 默认值为undefined。 

- 访问器属性是否能直接定义？

  - 不能
  - 必须使用Object.defineProperty()。

```
// 定义一个对象，包含伪私有成员year_和公共成员edition let book = { 
	year_: 2017, 
	edition: 1 
};
Object.defineProperty(book, "year", { 
	get() { 
		return this.year_; 
	},
	set(newValue) { 
		if (newValue > 2017) {
			this.year_ = newValue; 
			this.edition += newValue - 2017; 
		} 
	} 
});
book.year = 2018;
console.log(book.edition); // 2
```

- year_ 中的下划线常用来表示什么？
  - 该属性并不希望在对象方法的外部被访问。
- 另一个属性year被定义为一个什么属性？
  - 访问器属性，
- 其中获取函数会执行什么操作？
  - 返回year_的值，
- 设置函数会执行什么操作？
  - 做一些计算以决定正确的版本（edition）。
- 获取函数和设置函数是否都要定义？
  - 不一定
- 只定义获取函数意味着什么？
  - 属性是只读的，尝试修改属性会被忽略。
  - 在严格模式下，
    - 尝试写入只定义了获取函数的属性会抛出错误。
- 只有一个设置函数的属性是否可以读取？
  - 不能读取的，
    - 非严格模式下读取会返回undefined，
    - 严格模式下会抛出错误。
- 在不支持Object.defineProperty()的浏览器中是否可以修改[[Configurable]]或[[Enumerable]]？
  - 不能 

### 8.1.2 定义多个属性

- 如何在一个对象上同时定义多个属性？
  - 使用Object.defineProperties()方法
- Object.defineProperties()接收哪两个参数？
  - 要为之添加或修改属性的对象
  - 另一个描述符对象，
    - 其属性与要添加或修改的属性一一 对应。

```
let book = {}; 
Object.defineProperties(book, {
	year_: { value: 2017 },
	edition: { value: 1 },
	year: { 
		get() { return this.year_; },
		set(newValue) { 
			if (newValue > 2017) { 
				this.year_ = newValue; 
				this.edition += newValue - 2017; 
			}
		} 
	} 
});
```

- 上述代码中数据属性的configurable、enumerable、writable特性值是什么？
  - false

### 8.1.3 读取属性的特性

- 如何取得指定属性的属性描述符？
  - 使用Object.getOwnPropertyDescriptor()方法
- 这个方法接收哪两个参数？
  - 属性所在的对象
  - 要取得其描述符的属性名
- 返回值是什么？
  - 一个对象
- 对于访问器属性包含什么？
  - configurable、enumerable、get、set属性
- 对于数据属性包含什么？
  - configurable、enumerable、writable、value属性。

```
let book = {}; 
Object.defineProperties(book, {
	year_: { value: 2017 },
	edition: { value: 1 },
	year: { 
		get: function() { return this.year_; },
		set: function(newValue){ 
			if (newValue > 2017) { 
				this.year_ = newValue; 
				this.edition += newValue - 2017; 
			} 
		} 
	} 
}); 
let descriptor = Object.getOwnPropertyDescriptor(book, "year_");
console.log(descriptor.value); // 2017 console.log(descriptor.configurable); // false console.log(typeof descriptor.get); // "undefined" 

let descriptor = Object.getOwnPropertyDescriptor(book, "year"); console.log(descriptor.value); // undefined console.log(descriptor.enumerable); // false console.log(typeof descriptor.get); // "function"
```

- Object.getOwnPropertyDescriptors()静态方法会执行什么操作？
  - 会在每个自有属性上调用Object.getOwnPropertyDescriptor()
  - 并在一个新对象中返回它们。

```
let book = {}; 
Object.defineProperties(book, { 
	year_: { value: 2017 },
	edition: { value: 1 },
	year: { 
		get: function() { 
		return this.year_; 
	},
		set: function(newValue){ 
			if (newValue > 2017) { 
				this.year_ = newValue; 
				this.edition += newValue - 2017;
			} 
		} 
    } 
}); console.log(Object.getOwnPropertyDescriptors(book)); 
// { 
// 	edition: { 
// 		configurable: false, 
// 		enumerable: false,
// 		value: 1, 
// 		writable: false 
// 	}, 
// 	year: { 
// 		configurable: false, 
// 		enumerable: false,
// 		get: f(), 
// 		set: f(newValue), 
// 	},
// 	year_: { 
// 		configurable: false, 
// 		enumerable: false, 
// 		value: 2017, 
// 		writable: false 
// 	}
// }
```

### 8.1.4 合并对象

- 把源对象所有的本地属性一起复制到目标对象上。

  这种操作也被称为什么？

  - “混入”（mixin）

- Object.assign()方法接收什么参数？

  - 一个目标对象
  - 一个或多个源对象

- Object.assign()执行什么操作？

  - 将每个源对象中可枚举属性和自有属性复制到目标对象

- Object.assign()什么样的属性会被复制？

  - 以字符串和符号为键的

- 对每个符合条件的属性，Object.assign()方法会执行什么操作？

  - 使用源对象上的[[Get]]取得属性的值，
  - 然后使用目标对象上的[[Set]]设置属性的值

```
let dest, src, result;
/*** 简单复制 */
dest = {}; 
src = { id: 'src' }; 
result = Object.assign(dest, src); 
// Object.assign修改目标对象 
// 也会返回修改后的目标对象 
console.log(dest === result); // true console.log(dest !== src); // true console.log(result); // { id: src } console.log(dest); // { id: src } 

/*** 多个源对象 */
dest = {}; 
result = Object.assign(dest, { a: 'foo' }, 
{ b: 'bar' }); 
console.log(result); // { a: foo, b: bar }

/*** 获取函数与设置函数 */
dest = { 
	set a(val) { 
		console.log(`Invoked dest setter with param ${val}`); 
	} 
};

src = { 
	get a() { 
		console.log('Invoked src getter'); 
		return 'foo';
    } 
};
Object.assign(dest, src); 
// 调用src的获取方法
// 调用dest的设置方法并传入参数"foo"
// 因为这里的设置函数不执行赋值操作 
// 所以实际上并没有把值转移过来
console.log(dest); // { set a(val) {...} }
```

- Object.assign()实际上对每个源对象执行的是什么？

  - 浅复制。

- 浅复制意味着什么？

  - 只会复制对象的引用 

- 如果多个源对象都有相同的属性，则使用哪个值？

  - 最后一个复制的值。

- 从源对象访问器属性取得的值，比如获取函数，

  会作为什么值赋给目标对象？

  - 一个静态值

- 能否在两个对象间转移获取函数和设置函数？

  - 不能 

```
let dest, src, result; 
/*** 覆盖属性 */ 
dest = { id: 'dest' };
result = Object.assign(dest, 
	{ 
		id: 'src1',
   		a: 'foo' 
   	}, 
    { 
    	id: 'src2', 
    	b: 'bar' 
    }); 
// Object.assign会覆盖重复的属性 console.log(result); 
// { id: src2, a: foo, b: bar } 

// 可以通过目标对象上的设置函数观察到覆盖的过程： 
dest = { 
	set id(x) { 
		console.log(x); 
	} 
};
Object.assign(dest, 
	{ id: 'first' }, 
	{ id: 'second' }, 
	{ id: 'third' }
); 
// first
// second 
// third 

/*** 对象引用 */ 
dest = {}
src = { a: {} }; 
Object.assign(dest, src); 
// 浅复制意味着只会复制对象的引用 
console.log(dest); // { a :{} } 
console.log(dest.a === src.a); // true
```

- 如果赋值期间出错，则会发生什么？
  - 操作会中止并退出，
  - 同时抛出错误。
  
- Object.assign()没有“回滚”之前赋值的概念，

  因此它是一个尽力而为、可能只会完成什么的方法？

  - 部分复制

```
let dest, src, result; 
/*** 错误处理 */ 
dest = {}; 
src = { 
	a: 'foo', 
	get b() { 
		// Object.assign()在调用这个获取函数时会抛出错误
		throw new Error(); 
	},
	c: 'bar' 
};
try { 
	Object.assign(dest, src); 
} catch(e) {} 

// Object.assign()没办法回滚已经完成的修改 
// 因此在抛出错误之前，目标对象上已经完成的修改会继续存在：
console.log(dest); // { a: foo }
```



### 8.1.5 对象标识及相等判定

- 在ECMAScript 6之前，有些特殊情况即使是===操作符也无能为力： 

```
// 这些是===符合预期的情况 
console.log(true === 1); // false 
console.log({} === {}); // false
console.log("2" === 2); // false 
// 这些情况在不同JavaScript引擎中表现不同，但仍被认为相等 
console.log(+0 === -0); // true 
console.log(+0 === 0); // true 
console.log(-0 === 0); // true 
// 要确定NaN的相等性，必须使用极为讨厌的isNaN() console.log(NaN === NaN); // false console.log(isNaN(NaN)); // true
```

- Object.is()必须接收几个参数？
  - 两个参数

```
console.log(Object.is(true, 1)); // false console.log(Object.is({}, {})); // false console.log(Object.is("2", 2)); // false 
// 正确的0、-0、+0相等/不等判定 console.log(Object.is(+0, -0)); // false console.log(Object.is(+0, 0)); // true console.log(Object.is(-0, 0)); // false 
// 正确的NaN相等判定 
console.log(Object.is(NaN, NaN)); // true
```

- 如何检查超过两个值？
  - 递归地利用相等性传递

```
function recursivelyCheckEqual(x, ...rest) { 	
	return Object.is(x, rest[0]) && 
		(rest.length < 2 || 	
		recursivelyCheckEqual(...rest)); 
}
```



### 8.1.6 增强的对象语法 

#### \01. 属性值简写 

- 属性名和变量名是一样的

```
let name = 'Matt'; 
let person = { name: name };
console.log(person); // { name: 'Matt' }
```

- 简写属性名是什么？
  - 只要使用变量名（不用再写冒号）
    - 就会自动被解释为同名的属性键
- 如果没有找到同名变量，则会发生什么？
  - 抛出ReferenceError。 

```
let name = 'Matt'; 
let person = { name };
console.log(person); // { name: 'Matt' }
```

- 代码压缩程序会在不同作用域间做什么，

  以防止找不到引用？

  - 保留属性名

```
function makePerson(name) { 
	return { name }; 
}
let person = makePerson('Matt'); console.log(person.name); // Matt
```

- 在这里，参数标识符只限定于函数作用域，

  编译器会做什么？

  - 保留初始的name标识符

- 如果使用Google Closure编译器压缩，会执行什么操作？
  - 那么函数参数会被缩短，而属性名不变：

```
function makePerson(a) { 
	return { name: a }; 
}
var person = makePerson("Matt"); console.log(person.name); // Matt
```

#### \02. 可计算属性

- 在引入可计算属性之前，

  如果想使用变量的值作为属性，那么必须做什么？

  - 先声明对象，
  - 然后使用中括号语法来添加属性

- 能否在对象字面量中直接动态命名属性？

  - 不能

```
const nameKey = 'name'; 
const ageKey = 'age'; 
const jobKey = 'job'; 
let person = {}; 
person[nameKey] = 'Matt'; 
person[ageKey] = 27; 
person[jobKey] = 'Software engineer'; console.log(person); 
// { name: 'Matt', age: 27, job: 'Software engineer' }
```

- 中括号包围的对象属性键运行时将其作为什么来求值？
  - JavaScript表达式

```
const nameKey = 'name'; 
const ageKey = 'age'; 
const jobKey = 'job'; 
let person = { 
	[nameKey]: 'Matt', 
	[ageKey]: 27, 
	[jobKey]: 'Software engineer' 
};
console.log(person); 
// { name: 'Matt', age: 27, job: 'Software engineer' }
```

- 可计算属性本身是否可以是复杂的表达式，

  在实例化时再求值？

  - 可以
    - 因为被当作JavaScript表达式求值

```
const nameKey = 'name'; 
const ageKey = 'age'; 
const jobKey = 'job'; 
let uniqueToken = 0; 

function getUniqueKey(key) { 
	return `${key}_${uniqueToken++}`; 
}
let person = { 
	[getUniqueKey(nameKey)]: 'Matt', 	
	[getUniqueKey(ageKey)]: 27, 
	[getUniqueKey(jobKey)]: 'Software engineer' };
	
console.log(person); 
// { name_0: 'Matt', age_1: 27, job_2: 'Software engineer'
```

- 可计算属性表达式中抛出任何错误是否会中断对象创建？
  - 是
- 如果表达式抛出错误，之前完成的计算是否能回滚？
  - 不能

#### \03. 简写方法名

- 在给对象定义方法时，通常都要怎么做？
  - 写一个方法名、冒号，
  - 然后再引用一个匿名函数表达式，

```
let person = { 
	sayName: function(name) { 
		console.log(`My name is ${name}`); 
	} 
};
person.sayName('Matt'); // My name is Matt
```

- 缩短方法声明：

```
let person = { 
	sayName(name) { 
		console.log(`My name is ${name}`); 
	}
};
person.sayName('Matt'); // My name is Matt
```

- 简写方法名对获取函数和设置函数是否适用？
  - 是

```
let person = { 
	name_: '', 
	get name() { 
		return this.name_; 
	},
	set name(name) { 
		this.name_ = name; 
	},
	sayName() { 
		console.log(`My name is ${this.name_}`);
	} 
};
person.name = 'Matt'; 
person.sayName(); // My name is Matt
```

- 简写方法名与可计算属性键是否相互兼容？
  - 是

```
const methodKey = 'sayName'; 
let person = { 
	[methodKey](name) { 
		console.log(`My name is ${name}`); 
	} 
}
person.sayName('Matt'); // My name is Matt
```

 

### 8.1.7 对象解构 

- 对象解构语法，可以做什么？

  - 实现一个或多个赋值操作

- 对象解构是什么？

  - 使用与对象匹配的结构

    来实现对象属性赋值。 

- 是不使用对象解构的：

```
// 不使用对象解构 
let person = { 
	name: 'Matt', 
	age: 27 
};
let personName = person.name, 
personAge = person.age; 
console.log(personName); // Matt console.log(personAge); // 27
```

- 使用对象解构的：

```
// 使用对象解构 
let person = { 
	name: 'Matt', 
	age: 27 
};
let { 
	name: personName, 
	age: personAge 
} = person; 
console.log(personName); // Matt
console.log(personAge); // 27
```

- 使用解构，可以在一个类似对象字面量的结构中，做什么？
  - 声明多个变量，
  - 同时执行多个赋值操作。
- 如果想让变量直接使用属性的名称，那么应该怎么做？
  - 使用简写语法

```
let person = { 
	name: 'Matt', 
	age: 27 
};
let { name, age } = person; 
console.log(name); // Matt 
console.log(age); // 27
```

- 解构赋值是否一定与对象的属性匹配？
  - 不一定
- 赋值的时候是否可以忽略某些属性？
  - 可以
- 如果引用的属性不存在，则该变量的值就是？
  - undefined

```
let person = { 
	name: 'Matt', 
	age: 27 
};
let { name, job } = person; 
console.log(name); // Matt 
console.log(job); // undefined
```

- 是否可以在解构赋值的同时定义默认值？
  - 可以
  - 这适用于引用的属性不存在于源对象中的情况

```
let person = { 
	name: 'Matt', 
	age: 27 
};
let { 
	name, 
	job = 'Software engineer' 
} = person; 
console.log(name); // Matt 
console.log(job); // Software engineer
```

- 解构在内部执行什么操作？
  - 使用函数ToObject()（不能在运行时环境中直接访问）
  - 把源数据结构转换为对象。
- 在对象解构的上下文中，原始值会被当成什么？
  - 对象。
- null和undefined是否能被解构？
  - 不能
    - 否则会抛出错误

```
let { length } = 'foobar';
console.log(length); // 6 

let { constructor: c } = 4; 
console.log(c === Number); // true 

let { _ } = null; // TypeError 
let { _ } = undefined; // TypeError
```

- 解构是否要求变量必须在解构表达式中声明？
  - 不要求
- 如果是给事先声明的变量赋值，则赋值表达式必须做什么？
  - 包含在一对括号中

```
let personName, personAge; 
let person = { name: 'Matt', age: 27 };
({name: personName, age: personAge} = person); console.log(personName, personAge); // Matt, 27
```

#### \01. 嵌套解构

- 解构对于引用嵌套的属性或赋值目标是否有限制？
  - 没有
- 如何复制对象属性？
  - 通过解构

```
let person = { 
	name: 'Matt', 
	age: 27, 
	job: { title: 'Software engineer' } 
};
let personCopy = {}; 
({
	name: personCopy.name, 
	age: personCopy.age, 
	job: personCopy.job 
} = person); 

// 因为一个对象的引用被赋值给personCopy，所以修改 
// person.job对象的属性也会影响personCopy 
person.job.title = 'Hacker';
console.log(person); 
// { 
//		name: 'Matt', 
//		age: 27, 
//		job: { title: 'Hacker' } 
// } 
console.log(personCopy); 
// { 
//		name: 'Matt', 
//		age: 27, 
//		job: { title: 'Hacker' } 
// } 
```

- 解构赋值如何实现匹配嵌套的属性？
  - 使用嵌套结构

```
let person = { 
	name: 'Matt', 
	age: 27, 
	job: { title: 'Software engineer' } 
};
// 声明title变量并将person.job.title的值赋给它 
let {
	job: { 
		title
     }
} = person; 
console.log(title); // Software engineer
```

- 在什么情况下不能使用嵌套解构？
  - 在外层属性没有定义的情况下
    - 无论源对象还是目标对象都一样

```
let person = { 
	job: {
    	title: 'Software engineer' 
    } 
};
let personCopy = {}; 

// foo在源对象上是undefined 
({
	foo: { 
		bar: personCopy.bar 
	} 
} = person); 
// TypeError: Cannot destructure property 'bar' of 'undefined' or 'null'. 

// job在目标对象上是undefined 
({
	job: { 
		title: personCopy.job.title 
	} 
} = person); 
// TypeError: Cannot set property 'title' of undefined
```

#### \02. 部分解构 

- 需要注意的是，涉及多个属性的解构赋值是一个什么操作？

  - 输出无关的顺序化操作

- 如果一个解构表达式涉及多个赋值，开始的赋值成功而后面 

  的赋值出错，则整个解构赋值会发生什么？

  - 只会完成一部分

```
let person = { 
	name: 'Matt',
	age: 27 
};
let personName, personBar, personAge; 
try { 
// person.foo是undefined，因此会抛出错误 
({
	name: personName, 
	foo: { bar: personBar }, 
	age: personAge} = person); 
} catch(e) {}
console.log(personName, personBar, personAge);
// Matt, undefined, undefined
```

#### \03. 参数上下文匹配

- 在函数参数列表中是否可以进行解构赋值？
  - 可以
- 对参数的解构赋值是否会影响arguments对象？
  - 不会
- 可以在什么中声明在函数体内使用局部变量？
  - 函数签名

```
let person = { 
	name: 'Matt', 
	age: 27 
};
function printPerson(foo, {name, age}, bar) {
	console.log(arguments); 
	console.log(name, age); 
}
function printPerson2(foo, {name: personName, age: personAge}, bar) {
	console.log(arguments); 
	console.log(personName, personAge); 
}
printPerson('1st', person, '2nd'); 
// ['1st', { name: 'Matt', age: 27 }, '2nd']
// 'Matt', 27 

printPerson2('1st', person, '2nd'); 
// ['1st', { name: 'Matt', age: 27 }, '2nd']
// 'Matt', 27
```

## **8.2** 创建对象

- 虽然使用Object构造函数或对象字面量可以方便地创建对象，但这些方式有什么明显不足？

  - 创建具有同样接口的多个对象

    需要重复编写很多代码

### 8.2.1 概述 

### 8.2.2 工厂模式 

- 工厂模式用于什么？
  - 抽象创建特定对象的过程

```
function createPerson(name, age, job) { 
	let o = new Object(); 
	o.name = name;
    o.age = age; 
    o.job = job; 
    o.sayName = function() { 		
    	console.log(this.name); 
    };
    return o;
}
let person1 = createPerson("Nicholas", 29, "Software Engineer"); 
let person2 = createPerson("Greg", 27, "Doctor");
```

- 工厂模式没有解决什么问题？

  - 对象标识问题

    （即新创建的对象是什么类型）。 

### 8.2.3 构造函数模式 

- ECMAScript中的构造函数是用于什么？
  - 创建特定类型对象
- 如何自定义构造函数？
  - 以函数的形式为自己的对象类型定义属性和方法

```
function Person(name, age, job){ 
	this.name = name; 
	this.age = age; 
	this.job = job; 
	this.sayName = function() { 
		console.log(this.name); 
	}; 
}let person1 = new Person("Nicholas", 29, "Software Engineer"); 
let person2 = new Person("Greg", 27, "Doctor"); person1.sayName(); // Nicholas 
person2.sayName(); // Greg
```

- 构造函数模式和工程模式的区别？

  - 没有显式地创建对象。 

  - 属性和方法直接赋值给了this。 

  - 没有return。 

- 按照惯例，构造函数名称有什么规定？

  - 首字母都是要大写的，
    - 非构造函数则以小写字母开头。

- 要创建Person的实例，应使用什么操作符？

  - new操作符。

- 以这种方式调用构造函数会执行哪些操作？

  - (1) 在内存中创建一个新对象。 

  - (2) 这个新对象内部的[[Prototype]]特性

    被赋值为构造函数的prototype属性。 

  - (3) 构造函数内部的this

    被赋值为这个新对象（即this指向新对象）。 

  - (4) 执行构造函数内部的代码（给新对象添加属性）。 

  - (5) 如果构造函数返回非空对象，
    - 则返回该对象；
    - 否则，返回刚创建的新对象

- person1和person2分别保存着Person的不同实例。 

  这两个对象都有一个什么属性指向Person？

  - constructor属性

- constructor本来是用于什么？

  - 标识对象类型的

- 一般认为什么操作符是确定对象类型更可靠的方式？

  - instanceOf操作符

- 前面例子中的每个对象都是谁的实例？

  - Object的实例，
  - 同时也是Person的实例

```
console.log(person1 instanceof Object); // true console.log(person1 instanceof Person); // true console.log(person2 instanceof Object); // true console.log(person2 instanceof Person); // true
```

- 定义自定义构造函数可以确保什么？
  - 实例被标识为特定类型，
- person1和person2为什么被认为是Object的实例？
  - 因为所有自定义对象都继承自Object
- 构造函数是否一定要写成函数声明的形式？还有哪些形式?
  - 不一定
  - 赋值给变量的函数表达式也可以表示构造函数

```
let Person = function(name, age, job) {
	this.name = name; 
	this.age = age; 
	this.job = job;
    this.sayName = function() { 	
    	console.log(this.name); 
    }; 
}
let person1 = new Person("Nicholas", 29, "Software Engineer"); 
let person2 = new Person("Greg", 27, "Doctor"); person1.sayName(); // Nicholas 
person2.sayName(); // Greg 
console.log(person1 instanceof Object); // true console.log(person1 instanceof Person); // true console.log(person2 instanceof Object); // true console.log(person2 instanceof Person); // true
```

- 在实例化时，如果不想传参数，那么可以怎么做？
  - 构造函数后面的括号可加可不加。 

- 只要有什么操作符，就可以调用相应的构造函数？
  - new操作符

```
function Person() {
	this.name = "Jake"; 
	this.sayName = function() { 
		console.log(this.name); 
	}; 
}
let person1 = new Person(); 
let person2 = new Person; 

person1.sayName(); // Jake 
person2.sayName(); // Jake 

console.log(person1 instanceof Object); // true console.log(person1 instanceof Person); // true console.log(person2 instanceof Object); // true console.log(person2 instanceof Person); // true
```

#### \01. 构造函数也是函数 

- 构造函数与普通函数唯一的区别就是什么？
  - 调用方式不同
- 构造函数是否是函数？
  - 是
- 任何函数只要怎么调用就是构造函数？
  - 使用new操作符调用
- 不使用new操作符调用的函数就是什么函数？
  - 普通函数

```
// 作为构造函数 
let person = new Person("Nicholas", 29, "Software Engineer"); 
person.sayName(); // "Nicholas" 

// 作为函数调用 
Person("Greg", 27, "Doctor"); // 添加到window对象 window.sayName(); // "Greg"

// 在另一个对象的作用域中调用 
let o = new Object(); 
Person.call(o, "Kristen", 25, "Nurse"); o.sayName(); // "Kristen"
```

- 没有使用new操作符调用Person()，结果会发生什么？

  - 会将属性和方法添加到window对象。

- 为什么window对象上有了一个sayName()方法？

  -  因为在没有明确设置this值的情况下 

    - this始终指向Global对象

      （在浏览器中就是window对象）。

- 通过call() （或apply()）调用函数，同时执行什么操作？
  - 将特定对象指定为作用域。
  
- 为什么所有属性和sayName()方法都会添加到对象o上面？
  - 因为将o对象指定为Person()内部的this值

#### \02. 构造函数的问题 

- 构造函数的主要问题在于什么？

  - 其定义的方法会在每个实例上都创建一遍。

- person1和person2都有名为sayName()的方法，

  但这两个方法是否同一个Function实例？

  - 不是

- ECMAScript中的函数是什么类型？
  - 对象类型
- 每次定义函数时，都会做什么？
  - 初始化一个对象。

```
function Person(name, age, job){ 
	this.name = name; 
	this.age = age; 
	this.job = job;
	this.sayName = new Function("console.log(this.name)");// 逻辑等价 
}
```

- 为什么不同实例上的函数虽然同名却不相等
  - 函数会带来不同的作用域链和标识符解析。

```
console.log(person1.sayName == person2.sayName); // false
```

- 是否有必要定义两个不同的Function实例？
  - 没必要
  - 因为都是做一样的事
  
- this对象可以把函数与对象的绑定推迟到什么时候？
  - 运行时

- 如何解决两个不同的Function实例的问题？
  - 可以把函数定义转移到
  
    构造函数外部

```
function Person(name, age, job){ 
	this.name = name; 
	this.age = age;
    this.job = job; 
    this.sayName = sayName; 
}
function sayName() { 
	console.log(this.name); 
}
let person1 = new Person("Nicholas", 29, "Software Engineer"); 
let person2 = new Person("Greg", 27, "Doctor"); 

person1.sayName(); // Nicholas 
person2.sayName(); // Greg
```

- 如果这个对象需要多个方法，

  那么就要在全局作用域中定义多个函数。

  这会导致什么？

  - 自定义类型引用的代码不能很好地聚集一起。

- 这个新问题可以通过什么模式来解决？
  - 原型模式

### 8.2.4 原型模式 

- 每个函数都会创建一个什么属性？

  - prototype

- prototype属性是一个什么？

  - 对象

- prototype包含什么？

  - 由特定引用类型的实例共享的

    属性和方法。

- prototype对象就是什么？

  - 通过调用构造函数创建的

    对象的原型。

- 使用原型对象的好处是什么？

  - 在原型对象定义的属性和方法

    可以被对象实例共享。

- 原来在构造函数中

  直接赋给对象实例的值，

  可以直接赋值给谁？

  - 它们的原型，

```
function Person() {} 

Person.prototype.name = "Nicholas"; Person.prototype.age = 29; 
Person.prototype.job = "Software Engineer"; Person.prototype.sayName = function() {
console.log(this.name);
};

let person1 = new Person(); 
person1.sayName(); // "Nicholas" 

let person2 = new Person(); 
person2.sayName(); // "Nicholas" 

console.log(person1.sayName == person2.sayName); // true
```

- 使用函数表达式也可以： 

```
let Person = function() {}; 

Person.prototype.name = "Nicholas"; Person.prototype.age = 29; 
Person.prototype.job = "Software Engineer"; Person.prototype.sayName = function() { console.log(this.name); };

let person1 = new Person(); 
person1.sayName(); // "Nicholas" 

let person2 = new Person();
person2.sayName(); // "Nicholas" 

console.log(person1.sayName == person2.sayName); // true
```

#### \01. 理解原型 

- 只要创建一个函数，

  就会这个函数创建一个什么属性？

  - prototype属性（指向原型对象）。

- 默认情况下，所有原型对象自动获得一个名为什么的属性？

  - constructor
    - 指回与之关联的构造函数。

- 在自定义构造函数时，原型对象默认只会获得什么属性？

  - constructor属性

- 原型对象其他的所有方法都继承自谁？

  - Object

- 每次调用构造函数创建一个新实例，

  这个实例的内部的什么指针就会被赋值为

  构造函数的原型对象？

  - [[Prototype]]指针。

- 脚本中是否有访问这个[[Prototype]]特性的标准方式？

  - 没有

- 通过什么属性可以访问对象的原型？
  - \__proto__属性，
  
- 实例与构造函数原型之间是否有直接的联系？
  - 有
  
- 实例与构造函数之间是否有直接的联系？
  - 没有

```
/*** 构造函数可以是函数表达式 
* 也可以是函数声明，因此以下两种形式都可以：
* function Person() {} 
* let Person = function() {}
*/ 

function Person() {} 

/**
* 声明之后，构造函数就有了一个
* 与之关联的原型对象： 
*/ 
console.log(typeof Person.prototype); console.log(Person.prototype); 
// {
// 		constructor: f Person(),
// 		__proto__: Object 
// } 

/**
* 如前所述，构造函数有一个prototype属性 
* 引用其原型对象，而这个原型对象也有一个 
* constructor属性，引用这个构造函数
* 换句话说，两者循环引用： 
*/ 
console.log(Person.prototype.constructor === Person); // true

/**
* 正常的原型链都会终止于Object的原型对象 
* Object原型的原型是null 
*/
console.log(Person.prototype.__proto__ === Object.prototype); // true console.log(Person.prototype.__proto__.constructor === Object); // true console.log(Person.prototype.__proto__.__proto__ === null); // true console.log(Person.prototype.__proto__); 
// {
// 		constructor: f Object(),
// 		toString: ... 
// 		hasOwnProperty: ...
// 		isPrototypeOf: ... 
// 		... 
// } 

let person1 = new Person(), 
person2 = new Person(); 
/**
* 构造函数、原型对象和实例 
* 是3个完全不同的对象： 
*/ 
console.log(person1 !== Person); // true console.log(person1 !== Person.prototype); // true
console.log(Person.prototype !== Person); // true 

/**
* 实例通过__proto__链接到原型对象， 
* 它实际上指向隐藏特性[[Prototype]] 
*
* 构造函数通过prototype属性链接到原型对象 
*
* 实例与构造函数没有直接联系，与原型对象有直接联系
*/ 
console.log(person1.__proto__ === Person.prototype); // true conosle.log(person1.__proto__.constructor === Person); // true 

/**
* 同一个构造函数创建的两个实例 
* 共享同一个原型对象： 
*/ 
console.log(person1.__proto__ === person2.__proto__); // true 

/**
* instanceof检查实例的原型链中 
* 是否包含指定构造函数的原型： 
*/
console.log(person1 instanceof Person); // true console.log(person1 instanceof Object); // true console.log(Person.prototype instanceof Object); // true
```

![image-20220323161724717](C:\Users\KEVIN\Desktop\Written-Examination-JS\Javascript高级程序设计（第4版）\第 8 章 对象、类与面向对象编程\第 8 章 对象、类与面向对象编程.assets\image-20220323161724717.png)

- 为什么这两个实例都没有属性和方法，

  但person1.sayName()可以正常调用。

  - 这是由于对象属性查找机制

- 可以使用什么方法确定两个对象之间的原型关系？

  - isPrototypeOf()

- isPrototypeOf()会在什么情况下返回true？

  - 传入参数的[[Prototype]]指向调用它的对象时

```
console.log(Person.prototype.isPrototypeOf(person1)); // true console.log(Person.prototype.isPrototypeOf(person2)); // true
```

- Object.getPrototypeOf()返回什么？
  - 返回参数的内部特性[[Prototype]]的值

```
console.log(Object.getPrototypeOf(person1) == Person.prototype); // true console.log(Object.getPrototypeOf(person1).name); // "Nicholas"
```

- 使用Object.getPrototypeOf()可以方便地取得什么？
  - 一个对象的原型，
- setPrototypeOf()方法，可以做什么？
  - 向实例的私有特性[[Prototype]]写入一个新值。
    - 可以重写一个对象的原型继承关系

```
let biped = {
	numLegs: 2 
};
let person = { 
	name: 'Matt' 
};

Object.setPrototypeOf(person, biped); 

console.log(person.name); // Matt console.log(person.numLegs); // 2 console.log(Object.getPrototypeOf(person) === biped); // true
```

-  Object.setPrototypeOf()可能会有什么问题？
  - 严重影响代码性能。 

- 为避免使用Object.setPrototypeOf()可能造成的性能下降，可以做什么？
  - 通过Object.create()来创建一个新对象，
  - 同时为其指定原型：

```
let biped = { numLegs: 2 };
let person = Object.create(biped); 
person.name = 'Matt'; 
console.log(person.name); // Matt console.log(person.numLegs); // 2 console.log(Object.getPrototypeOf(person) === biped); // true
```

#### \02. 原型层级

- 在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索开始于哪里？

  - 对象实例本身

- 如果在这个实例上没有找到这个属性，

  则搜索会进入哪里？

  - 原型对象，

- constructor属性只存在于哪里？
  - 原型对象

- 通过实例对象是否可以访问到constructor属性？

  - 可以 

- 是否可以通过实例读取原型对象上的值

  - 可以

- 是否可以通过实例重写这些值？

  - 不可以

- 如果在实例上添加了一个与原型对象中同名的属性，

  那就会在实例上创建这个属性，

  这个属性会有什么问题？

  - 遮住原型对象上的属性。

```
function Person() {} 

Person.prototype.name = "Nicholas"; 
Person.prototype.age = 29; 
Person.prototype.job = "Software Engineer"; 
Person.prototype.sayName = function() { 
	console.log(this.name);
};

let person1 = new Person();
let person2 = new Person();

person1.name = "Greg"; 

console.log(person1.name); // "Greg"，来自实例 console.log(person2.name); // "Nicholas"，来自原型
```

- 如果在实例上把这个属性设置为null，

  是否会恢复它和原型的联系？

  - 不会恢复

- 如何完全删除实例上的这个属性， 

  - 使用delete操作符 

```
function Person() {} 

Person.prototype.name = "Nicholas"; Person.prototype.age = 29; 
Person.prototype.job = "Software Engineer"; Person.prototype.sayName = function() { 		
	console.log(this.name); 
};

let person1 = new Person();
let person2 = new Person(); 

person1.name = "Greg"; 
console.log(person1.name); // "Greg"，来自实例 console.log(person2.name); // "Nicholas"，来自原型

delete person1.name; 
console.log(person1.name); // "Nicholas"，来自原型
```

- hasOwnProperty()方法用于什么？

  - 确定某个属性

    - 是在实例上
    
    - 还是在原型对象上。

- hasOwnProperty方法是继承自谁的？

  - Object

- hasOwnProperty方法会在什么情况下返回true？

  - 属性存在于调用它的

    对象实例上时


```
function Person() {} 

Person.prototype.name = "Nicholas"; Person.prototype.age = 29; 
Person.prototype.job = "Software Engineer"; Person.prototype.sayName = function() { 		
	console.log(this.name);
};

let person1 = new Person();
let person2 = new Person(); console.log(person1.hasOwnProperty("name")); 
// false

person1.name = "Greg"; 
console.log(person1.name); // "Greg"，来自实例 console.log(person1.hasOwnProperty("name")); // true 

console.log(person2.name); // "Nicholas"，来自原型 console.log(person2.hasOwnProperty("name")); // false 

delete person1.name; 
console.log(person1.name); // "Nicholas"，来自原型 console.log(person1.hasOwnProperty("name")); // false
```

- Object.getOwnPropertyDescriptor()方法 

  只对什么属性有效？

  - 实例属性

- 如何取得原型属性的描述符？

  - 在原型对象上调用Object.getOwnPropertyDescriptor()。 


#### \03. 原型和**in**操作符

- 有哪两种方式使用in操作符？

  - 单独使用
  - 在for-in循环中使用。

- 在单独使用时，in操作符会在什么情况下返回true？

  - 可以通过对象访问

    指定属性时

    - 无论该属性是在实例上还是在原型上。


```
function Person() {} 
Person.prototype.name = "Nicholas"; Person.prototype.age = 29;
Person.prototype.job = "Software Engineer"; Person.prototype.sayName = function() { 		
	console.log(this.name); 
};
let person1 = new Person(); 
let person2 = new Person(); 
console.log(person1.hasOwnProperty("name"));
// false 
console.log("name" in person1); // true 

person1.name = "Greg"; 
console.log(person1.name); // "Greg"，来自实例 console.log(person1.hasOwnProperty("name")); // true 
console.log("name" in person1); // true 

console.log(person2.name); // "Nicholas"，来自原型 console.log(person2.hasOwnProperty("name")); // false 
console.log("name" in person2); // true 

delete person1.name;
console.log(person1.name); // "Nicholas"，来自原型 console.log(person1.hasOwnProperty("name")); // false 
console.log("name" in person1); // true
```

- 如何要确定某个属性是否存在于原型上？

  - 同时使用hasOwnProperty()和 in 操作符：


```
function hasPrototypeProperty(object, name){
	return !object.hasOwnProperty(name)
    && (name in object);
}
```

- 只要in操作符且hasOwnProperty()返回什么。

  就说明该属性是一个原型属性？

  - in操作符返回true
  - hasOwnProperty()返回false

```
function Person() {} 
Person.prototype.name = "Nicholas"; Person.prototype.age = 29; 
Person.prototype.job = "Software Engineer"; Person.prototype.sayName = function() { 
	console.log(this.name); 
};

let person = new Person(); console.log(hasPrototypeProperty(person, "name")); // true 

person.name = "Greg"; console.log(hasPrototypeProperty(person, "name")); // false
```

- 在for-in循环中使用in操作符时，什么样的属性会返回？

  - 可以通过对象访问，且可以被枚举的属性
    - 包括实例属性和原型属性

- 如何获得对象上所有可枚举的实例属性？
  - 使用Object.keys()方法。

- Object.keys()方法，接收什么作为参数？

  - 一个对象

- Object.keys()方法返回什么？

   - 包含该对象所有可枚举属性

      名称的字符串数组。


```
function Person() {} 
Person.prototype.name = "Nicholas"; Person.prototype.age = 29; 
Person.prototype.job = "Software Engineer"; Person.prototype.sayName = function() { 
	console.log(this.name); 
}

let keys = Object.keys(Person.prototype); console.log(keys); // "name,age,job,sayName" 

let p1 = new Person(); 
p1.name = "Rob";
p1.age = 31; 

let p1keys = Object.keys(p1); 
console.log(p1keys); // "[name,age]
```

- 如何列出所有实例属性，无论是否可以枚举？

  - 使用Object.getOwnPropertyNames()：

```
let keys = Object.getOwnPropertyNames(Person.prototype); console.log(keys); 
// "[constructor,name,age,job,sayName]"
```

- Object.keys()和Object.getOwnPropertyNames()

  在适当的时候都可用来代替什么？

  - for-in循环。 

- Object.getOwnPropertySymbols()方法是什么？

  - 与Object.getOwnPropertyNames()类似，

    只是针对符号而已： 

```
let k1 = Symbol('k1'), 
k2 = Symbol('k2'); 
let o = { 
	[k1]: 'k1', 
	[k2]: 'k2' 
};
console.log(Object.getOwnPropertySymbols(o)); 
// [Symbol(k1), Symbol(k2)]
```

#### \04. 属性枚举顺序

- for-in和Object.keys()的枚举顺序是怎样的？

  - 不确定的，
    - 取决于JavaScript引擎， 可能因浏览器而异。

- Object.getOwnPropertyNames()、

  Object.getOwnPropertySymbols() 

  Object.assign()

  的枚举顺序是怎样的？

  - 确定性的。

    - 以升序枚举数值键， 

    - 以插入顺序枚举字符串和符号键。

    - 在对象字面量中定义的键
      - 以它们逗号分隔的顺序插入。

```
let k1 = Symbol('k1'), 
k2 = Symbol('k2'); 

let o = { 
	1: 1, 
	first: 'first', 
	[k1]: 'sym2', 
	second: 'second', 
	0: 0 
};

o[k2] = 'sym2'; 
o[3] = 3; 
o.third = 'third'; 
o[2] = 2; 

console.log(Object.getOwnPropertyNames(o)); 
// ["0", "1", "2", "3", "first", "second", "third"] 

console.log(Object.getOwnPropertySymbols(o)); 
// [Symbol(k1), Symbol(k2)]
```

 

### 8.2.5 对象迭代

- 对象迭代有哪两个静态方法？
  - Object.values() 
  - Object.entries()

- Object.values()返回什么？
  - 对象值的数组，

- Object.entries()返回什么？
  - 键/值对 的数组。


```
const o = { 
	foo: 'bar', 
	baz: 1,
	qux: {}
};
console.log(Object.values(o)); 
// ["bar", 1, {}]
console.log(Object.entries((o))); 
// [["foo", "bar"], ["baz", 1], ["qux", {}]]
```

- 非字符串属性会被转换为什么输出？
  - 字符串

- 这两个方法执行对象的什么复制？
  - 浅复制


```
const o = { qux: {} };
console.log(Object.values(o)[0] === o.qux);
// true
console.log(Object.entries(o)[0][1] === o.qux); // true
```

- 符号属性是否会被忽略？
  - 是 


```
const sym = Symbol(); 
const o = { 
	[sym]: 'foo' 
};
console.log(Object.values(o)); // [] console.log(Object.entries((o))); // []
```

#### \01. 其他原型语法

- 每次定义一个属性或方法，

  都会把什么重写一遍？

  - Person.prototype

- 如何减少代码冗余，从视觉上更好地封装原型功能？

  - 通过一个包含所有属性和方法的对象字面量

    来重写原型


```
function Person() {} 

Person.prototype = { 
	name: "Nicholas", 
	age: 29, 
	job: "Software Engineer", 
	sayName() { 
		console.log(this.name);
	} 
};
```

- 上述例子有什么问题？

  - Person.prototype的constructor属性

    就不指向Person了。

- 在创建函数时，会创建它的prototype对象

  同时执行什么操作？

  - 给这个原型对象的constructor属性赋值

- 重写了默认的prototype对象，

  其constructor属性是否指向原来的构造函数？

  - 不
    - 指向新对象（Object构造函数）

- instanceof操作符是否还能可靠地返回值？

  - 能

- 是否能靠constructor属性来识别类型？

  - 不能


```
let friend = new Person(); 

console.log(friend instanceof Object); // true console.log(friend instanceof Person); // true 

console.log(friend.constructor == Person); // false 
console.log(friend.constructor == Object); // true
```

- constructor属性现在等于什么？

  - Object
  - 而不是Person了。

- 如何改变constructor的值？
  - 在重写原型对象时

    专门设置constructor的值：

```
function Person() { }

Person.prototype = {
	constructor: Person, 
	name: "Nicholas", 
	age: 29, 
	job: "Software Engineer", 
	sayName() { 
		console.log(this.name); 
	}
};
```

- 以这种方式恢复的constructor属性

  会创建一个[[Enumerable]]为什么的属性？

  - true

- 原生的constructor属性默认是否可枚举？

  - 不可枚举

- 那改为使用什么方法来定义constructor属性？

  - Object.defineProperty()方法


```
function Person() {}

Person.prototype = {
	name: "Nicholas", 
	age: 29, 
	job: "Software Engineer", 
	sayName() { 
		console.log(this.name); 
	} 
};

// 恢复constructor属性 
Object.defineProperty(Person.prototype,
"constructor", { 
	enumerable: false, 
	value: Person 
});
```

#### \02. 原型的动态性

- 从原型上搜索值的过程是什么样的？

  - 动态的

- 如果实例在修改原型之前已经存在，

  任何时候对原型对象所做的修改

  是否会在实例上反映出来？

  - 会

```
let friend = new Person();

Person.prototype.sayHi = function() {
	console.log("hi"); 
};

friend.sayHi(); // "hi"，没问题！
```

- 因为实例和原型之间的链接是什么？

  - 指针 

- 实例的[[Prototype]]指针是在什么时候自动赋值的？

  - 调用构造函数时

- 实例的[[Prototype]]指针

  如果把原型修改为不同的对象

  是否会变？

  - 不会

- 实例是否有指向原型的指针？

  - 有

- 实例是否有指向构造函数的指针？
  - 没有

```
function Person() {} 

let friend = new Person(); 

Person.prototype = { 
	constructor: Person, 
	name: "Nicholas", 
	age: 29, 
	job: "Software Engineer", 
	sayName() { console.log(this.name); }
};

friend.sayName(); // 错误
```

- 为什么在调用friend.sayName()的时候会导致错误。
  - 因为firend指向的原型还是最初的原型，
    - 而这个原型上并没有sayName属性。

![image-20220323193623478](第 8 章 对象、类与面向对象编程.assets/image-20220323193623478.png)

![image-20220323193639591](第 8 章 对象、类与面向对象编程.assets/image-20220323193639591.png)

- 在什么时候创建的实例才会引用新的原型？
  - 重写原型之后

- 重写原型之前创建的实例会引用哪个原型？

  - 最初的原型。

#### \03. 原生对象原型

- 所有原生引用类型的构造函数 

  （包括Object、Array、String等）

  都在哪里定义了实例方法？

  - 原型上

- 数组实例的sort()方法在哪里定义的？
  - Array.prototype上定义的，

- 字符串包装对象的substring()方法在哪里定义的？
  - String.prototype上定义的 

```
console.log(typeof Array.prototype.sort); // "function"
console.log(typeof String.prototype.substring); // "function"
```

- 通过原生对象的原型可以做什么？
  - 取得所有默认方法的引用，
  - 给原生类型的实例定义新的方法。

- 是否可以修改原生对象原型，
  - 可以


```
String.prototype.startsWith = function (text) { 
	return this.indexOf(text) === 0;
};

let msg = "Hello world!";

console.log(msg.startsWith("Hello")); // true
```

- 在读取msg的属性时，后台会自动创建什么？

  - String的包装实例， 

- 为什么不推荐在产品环境中修改原生对象原型？

  - 可能造成误会，

  - 可能引发命名冲突

    （比如一个名称在某个浏览器实现中不存在，

    在另一个实现中却存在）。

  - 可能意外重写原生的方法。

- 推荐的做法是什么？

  - 创建一个自定义的类，

    继承原生类型

#### \04. 原型的问题

- 原型模式弱化了什么能力？导致了什么？

  - 向构造函数传递

    初始化参数的能力

  - 导致所有实例默认都取得相同的属性值。

- 原型的最主要问题源自它的什么特性？

  - 共享特性 

- 原型上的所有属性是在哪里共享的？

  - 实例间
    - 这对函数来说比较合适。

- 如何遮蔽原型上的属性？

  - 通过在实例上添加同名属性

- 真正的问题来自什么属性？

  - 包含引用值的属性

```
function Person() {} 

Person.prototype = {
	constructor: Person, 
	name: "Nicholas", 
	age: 29, 
	job: "Software Engineer", 
	friends: ["Shelby", "Court"], 
	sayName() { console.log(this.name); } 
};

let person1 = new Person(); 
let person2 = new Person(); 

person1.friends.push("Van"); 

console.log(person1.friends); // "Shelby,Court,Van" 

console.log(person2.friends); // "Shelby,Court,Van" 

console.log(person1.friends === person2.friends); // true
```

- 为什么新加的这个字符串也会在（指向同一个数组的）

  person2.friends上反映出来？

  - 由于这个friends属性

    存在于Person.prototype

    而非person1上

- 为什么实际开发中不单独使用原型模式？

  - 因为不同的实例应该有属于自己的属性副本。


## 8.3 继承

- ECMAScript唯一支持的继承方式是什么？
  - 继承

- 继承通过什么实现？
  - 通过原型链实现 

### **8.3.1** 原型链

- 原型链基本思想是什么？

  - 通过原型

    继承多个引用类型的属性和方法。

- 构造函数、原型和实例的关系是什么？

  - 构造函数有一个prototype属性指向原型，
  - 原型有一个constructor属性指向构造函数，
  - 实例有一个[[prototype]]内部指针指向原型。

- 如果原型是另一个类型的实例呢？

  - 这个原型本身有一个内部指针指向另一个原型，
  - 另一个原型也有一个指针指向另一个构造函数。

- 实现原型链的代码模式是什么？

```
function SuperType() { 
	this.property = true; 
}
SuperType.prototype.getSuperValue = function() { 
	return this.property;
};

function SubType() { 
	this.subproperty = false;
}

// 继承SuperType 
SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function () { 
	return this.subproperty; 
};

let instance = new SubType(); console.log(instance.getSuperValue()); // true
```

![image-20220324082515059](\第 8 章 对象、类与面向对象编程.assets\image-20220324082515059.png)

- 这个例子中实现继承的关键是什么？
  - SubType没有使用默认原型，
  - 而是替换成了一个新的对象。
- 原型链扩展了什么？
  - 原型搜索机制。

- 在读取实例上的属性时，会进行什么操作？
  - 首先会在实例上搜索这个属性。
  - 如果没找到，则会继承搜索实例的原型。
  - 在通过原型链实现继承之后，
    - 搜索就可以继承向上，搜索原型的原型。
- 对属性和方法的搜索会一直持续到哪里？
  - 原型链的末端


#### \01. 默认原型

- 默认情况下，所有引用类型都继承自谁？

  - Object

- 任何函数的默认原型都是一个什么的实例？

  - Object
  - 实例有一个内部指针指向哪里？
    - Object.prototype。

- 为什么自定义类型能够继承

  包括toString()、valueOf()在内的所有默认方法？

  - 因为所有引用类型都继承自object

- 因此前面的例子还有额外一层继承关系。

![image-20220324082957857](\第 8 章 对象、类与面向对象编程.assets\image-20220324082957857.png)

#### \02. 原型与继承关系 

- 原型与实例的关系可以通过哪两种方式来确定？

  - 使用instanceof操作符，

    - 如果一个实例的原型链中

      出现过相应的构造函数，

      - 返回true。

  - 使用isPrototypeOf()方法

    - 只要原型链中包含这个原型，
      - 返回true

```
console.log(instance instanceof Object); // true console.log(instance instanceof SuperType); // true 
console.log(instance instanceof SubType); // true
```

```
console.log(Object.prototype.isPrototypeOf(instance)); // true console.log(SuperType.prototype.isPrototypeOf(instance)); // true console.log(SubType.prototype.isPrototypeOf(instance)); // true
```

#### \03. 关于方法

- 子类有时候需要覆盖父类的方法，

  或者增加父类没有的方法。

  这些方法必须在什么时候添加到原型上？

  - 在原型赋值之后

```
function SuperType() { 
	this.property = true;
}
SuperType.prototype.getSuperValue = function() {
	return this.property; 
};

function SubType() { 
	this.subproperty = false;
}

// 继承SuperType 
SubType.prototype = new SuperType(); 

// 新方法 
SubType.prototype.getSubValue = function () {
	return this.subproperty; 
};

// 覆盖已有的方法 
SubType.prototype.getSuperValue = function () {
	return false; 
};
let instance = new SubType(); console.log(instance.getSuperValue()); // false
```

- 以对象字面量方式

  创建原型方法

  会破坏什么？

  - 之前的原型链，
  - 因为这相当于重写了原型链。

```
function SuperType() { 
	this.property = true; 
}
SuperType.prototype.getSuperValue = function() {
	return this.property;
};

function SubType() { 
	this.subproperty = false;
}

// 继承SuperType 
SubType.prototype = new SuperType(); 

// 通过对象字面量添加新方法，这会导致上一行无效 SubType.prototype = { 
	getSubValue() { 
		return this.subproperty; 
	},
	someOtherMethod() { 
		return false; 
	} 
};

let instance = new SubType(); console.log(instance.getSuperValue()); // 出错！
```

#### \04. 原型链的问题 

- 原型链主要问题出现在哪里？
  - 原型中包含引用值

- 为什么属性会在构造函数中定义

  而不会定义在原型上？

  - 原型中包含的引用值会在

    所有实例间共享

- 在使用原型实现继承时，原型变成了另一个类型的什么？

  - 实例

- 原先的实例属性成为了什么属性？

  - 原型属性


```
function SuperType() { 
	this.colors = ["red", "blue", "green"]; 
}

function SubType() {} 

// 继承SuperType 
SubType.prototype = new SuperType(); 

let instance1 = new SubType();
instance1.colors.push("black");
console.log(instance1.colors); 
// "red,blue,green,black" 

let instance2 = new SubType(); 
console.log(instance2.colors); 
// "red,blue,green,black"
```

- 原型链的第二个问题是什么？

  - 子类型在实例化时

    不能给父类型的构造函数传参

- 我们是否可以在不影响

  所有对象实例的情况下

  把参数传进父类的构造函数？

  - 不可以

- 原型链是否会被单独使用？

  - 基本不会


### 8.3.2 盗用构造函数 

- 基本思路是什么？

  - 在子类构造函数中

    调用父类构造函数。

- 函数是什么？

  - 在特定上下文中执行代码的

    简单对象

- 如何以新创建的对象为上下文

  执行构造函数？

  - 使用apply()和call()方法

```
function SuperType() { 
	this.colors = ["red", "blue", "green"];
}

function SubType() { 
	// 继承SuperType 
	SuperType.call(this);
}

let instance1 = new SubType(); instance1.colors.push("black"); 
console.log(instance1.colors);
// "red,blue,green,black"

let instance2 = new SubType(); console.log(instance2.colors); 
// "red,blue,green"
```

- 上述代码的结果是什么？
  - 每个实例都会有自己的colors属性


#### \01. 传递参数

- 盗用构造函数的一个优点是什么？
  - 可以在子类构造函数中向
  
    父类构造函数传参

```
function SuperType(name){ 
	this.name = name; 
}

function SubType() { 
	// 继承SuperType并传参 
	SuperType.call(this, "Nicholas");
    // 实例属性
    this.age = 29; 
}

let instance = new SubType(); console.log(instance.name); // "Nicholas" console.log(instance.age); // 29
```

#### \02. 盗用构造函数的问题 

- 盗用构造函数的主要缺点是什么？
  - 必须在构造函数中定义方法
    - 因此函数不能重用
  - 子类不能访问父类原型上定义的方法
    - 因此所有类型只能使用构造函数模式
- 盗用构造函数是否能单独使用？
  - 基本上不能 


### 8.3.3 组合继承

- 组合继承综合了什么？
  - 原型链
  - 盗用构造函数
- 组合继承基本的思路是什么？
  - 通过原型链
    - 继承原型上的属性和方法，
  - 通过盗用构造函数
    - 继承实例属性。
- 组合继承是否可以把方法定义在原型上以实现重用？
  - 可以
- 组合继承是否可以让每个实例都有自己的属性？
  - 可以

```
function SuperType(name){ 
	this.name = name; 
	this.colors = ["red", "blue", "green"]; 
}

SuperType.prototype.sayName = function() { 	
	console.log(this.name);
};

function SubType(name, age){ 
	// 继承属性 
	SuperType.call(this, name); 
	this.age = age; 
}

// 继承方法 
SubType.prototype = new SuperType();

SubType.prototype.sayAge = function() {
	console.log(this.age); 
};

let instance1 = new SubType("Nicholas", 29); 

instance1.colors.push("black"); 

console.log(instance1.colors); 
// "red,blue,green,black" 

instance1.sayName(); // "Nicholas"; instance1.sayAge(); // 29

let instance2 = new SubType("Greg", 27); 

console.log(instance2.colors); 
// "red,blue,green" 

instance2.sayName(); // "Greg"; 
instance2.sayAge(); // 27
```

- 哪种继承是JavaScript中使用最多的继承模式？

  - 组合继承

- 组合继承保留了什么能力？

  - instanceof操作符和 isPrototypeOf()方法

    识别合成对象的能力。

### 8.3.4 原型式继承 

- 原型式继承的出发点是什么？

  - 即使不自定义类型 

    也可以通过原型

    实现对象之间的信息共享。

```
function object(o) { 
	function F() {}
	F.prototype = o; 
	return new F(); 
}
```

- 这个object()函数会执行什么操作？

  - 创建一个临时构造函数，

  - 将传入的对象

    赋值给临时构造函数的原型，

  - 返回临时类型的一个实例

- 本质上，object()是对传入的对象执行了一次什么？

  - 一次浅复制。

```
let person = { 
	name: "Nicholas", 
	friends: ["Shelby", "Court", "Van"] 
};

let anotherPerson = object(person); anotherPerson.name = "Greg"; anotherPerson.friends.push("Rob");

let yetAnotherPerson = object(person); yetAnotherPerson.name = "Linda"; yetAnotherPerson.friends.push("Barbie"); 

console.log(person.friends); 
// "Shelby,Court,Van,Rob,Barbie"
```

- 原型式继承适用于哪种情况？
  
  - 想在一个对象的基础上再创建一个新对象。
  
- 原型式继承怎么用？
  - 把这个对象传给object()
  - 对返回的对象进行适当修改。

- ECMAScript 5通过增加什么方法

  将原型式继承的概念规范化了？

  - Object.create()

- Object.create()方法接收哪两个参数？

  - 作为新对象原型的对象，
  - 给新对象定义额外属性的对象（可选

- 在只有一个参数时，

  Object.create()与object()方法效果有何区别？

  - 效果相同

```
let person = { 
	name: "Nicholas", 
	friends: ["Shelby", "Court", "Van"]
};

let anotherPerson = Object.create(person); anotherPerson.name = "Greg"; anotherPerson.friends.push("Rob"); 

let yetAnotherPerson = Object.create(person); yetAnotherPerson.name = "Linda";
yetAnotherPerson.friends.push("Barbie");

console.log(person.friends); 
// "Shelby,Court,Van,Rob,Barbie"
```

-  Object.create()的第二个参数与什么方法的第二个参数一样？

  - Object.defineProperties()
  - 每个新增属性都通过各自的描述符来描述。
  
- 以这种方式添加的属性是否会遮蔽

  原型对象上的同名属性？

  - 是

```
let person = { 
	name: "Nicholas", 
	friends: ["Shelby", "Court", "Van"] 
};

let anotherPerson = Object.create(person, { 
	name: {
		value: "Greg" 
	}
});

console.log(anotherPerson.name); // "Greg"
```

- 原型式继承非常适合什么情况？
  - 不需要单独创建构造函数
- 属性中包含的引用值始终会在相关对象间做什么？
  - 共享
    - 跟使用原型模式是一样的

### 8.3.5 寄生式继承

- 寄生式继承背后的思路是什么？
  - 创建一个实现继承的函数，
  - 以某种方式增强对象
  - 返回这个对象。
- 基本的寄生继承模式如下

```
function createAnother(original){

	let clone = object(original);
    
	// 通过调用函数创建一个新对象 
	clone.sayHi = function() { 
		// 以某种方式增强这个对象 
		console.log("hi"); 
	};
	
	return clone; // 返回这个对象 
}
```

- 如何使用createAnother()函数？

```
let person = { 
	name: "Nicholas",
	friends: ["Shelby", "Court", "Van"] 
};

let anotherPerson = createAnother(person);

anotherPerson.sayHi(); // "hi"
```

- 寄生式继承同样适合什么场景？
  - 主要关注对象
  - 且不在乎类型和构造函数
- object()函数是否是寄生式继承所必需的？
  - 不是
  - 任何返回新对象的函数都可以在这里使用。 
- 通过寄生式继承给对象添加函数会导致什么问题？
  - 函数难以重用
    - 与构造函数模式类似。 

### 8.3.6 寄生式组合继承

- 组合继承存在什么问题？
  - 效率问题
- 最主要的效率问题是什么？
  - 父类构造函数会被调用两次：
    - 一次在创建子类原型时调用，
    - 一次在子类构造函数中调用。
- 本质上，子类原型最终要包含父类对象的什么？
  - 所有实例属性
- 如何优化效率？
  - 寄生式组合继承

```
function SuperType(name) { 
	this.name = name; 
	this.colors = ["red", "blue", "green"]; 
}

SuperType.prototype.sayName = function() { 
	console.log(this.name);
};

function SubType(name, age){ 
	// 第二次调用SuperType() 
	SuperType.call(this, name); 
	
	this.age = age;
}

// 第一次调用SuperType() 
SubType.prototype = new SuperType(); 
SubType.prototype.constructor = SubType; 

SubType.prototype.sayAge = function() { 
	console.log(this.age);
};
```

![image-20220324092850397](\第 8 章 对象、类与面向对象编程.assets\image-20220324092850397.png)

- 寄生式组合继承基本思路是什么？

  - 使用寄生式继承，来继承父类原型
  - 将返回的新对象，赋值给子类原型。

- 寄生式组合继承的基本模式是什么？

```
function inheritPrototype(subType, superType) {
	// 创建对象
	let prototype = object(superType.prototype);
	
    prototype.constructor = subType; // 增强对象
    
 	subType.prototype = prototype; // 赋值对象
}
```

- inheritPrototype()函数接收哪两个参数？
  - 子类构造函数
  - 父类构造函数。
  
- 在inheritPrototype()函数内部，执行了什么操作？

  - 创建父类原型的一个副本
  - 给prototype对象设置constructor属性
  - 将新对象赋值给子类型的原型。

- 为什么要给返回的prototype对象设置constructor属性，
  - 解决由于重写原型导致

    默认constructor丢失的问题。

```
function SuperType(name) {
 	this.name = name;
 	this.colors = ["red", "blue", "green"];
}

SuperType.prototype.sayName = function() {
 	console.log(this.name);
};

function SubType(name, age) {
 	SuperType.call(this, name);
 	this.age = age;
}

inheritPrototype(SubType, SuperType);

SubType.prototype.sayAge = function() {
	console.log(this.age);
};
```

- 这里调用了几次SuperType构造函数？

  - 一次

- instanceof操作符和isPrototypeOf()方法是否正常有效？

  - 是
  - 因为原型链保持不变

- 哪种继承可以算是引用类型继承的最佳模式？

  - 寄生式组合继承

  

## 8.4 类

### 8.4.1 类定义 

- 定义类有哪两种主要方式？
  - 类声明
  - 类表达式
- 这两种方式都使用什么？
  - class关键字加大括号

```
// 类声明
class Person {} 
// 类表达式 
const Animal = class {};
```

- 类表达式在它们被求值前是否能引用？
  - 不能
- 类定义是否能提升？
  - 不能

```
console.log(FunctionExpression); // undefined 

var FunctionExpression = function() {}; 

console.log(FunctionExpression); // function() {} 


console.log(FunctionDeclaration); 
// FunctionDeclaration() {}

function FunctionDeclaration() {} 

console.log(FunctionDeclaration); 
// FunctionDeclaration() {} 


console.log(ClassExpression); // undefined 

var ClassExpression = class {}; 

console.log(ClassExpression); // class {}


console.log(ClassDeclaration); 
// ReferenceError: ClassDeclaration is not defined 

class ClassDeclaration {} 

console.log(ClassDeclaration); 
// class ClassDeclaration {}
```

- 函数受函数作用域限制，而类受什么作用域限制？
  - 块作用域

```
{ 
	function FunctionDeclaration() {}
    
	class ClassDeclaration {}
}

console.log(FunctionDeclaration); 
// FunctionDeclaration() {} 

console.log(ClassDeclaration);
// ReferenceError: ClassDeclaration is not defined
```

#### 类的构成 

- 空的类定义是否有效？
  - 是
- 默认情况下，类定义中的代码都在什么模式下执行？
  - 严格模式 

- 多数编程风格都建议类名的首字母怎么写？

  - 要大写，
  - 以区别于通过它创建的实例

```
// 空类定义，有效 
class Foo {}

// 有构造函数的类，有效
class Bar { 
	constructor() {}
}

// 有获取函数的类，有效 
class Baz { 
	get myBaz() {} 
}

// 有静态方法的类，有效
class Qux { 
	static myQux() {} 
}
```

- 类表达式的名称是是否是可选的？

  - 是

- 在把类表达式赋值给变量后，

  可以通过什么属性取得类表达式的名称字符串？

  - name属性

- 是否能在类表达式作用域外部访问
  
  类表达式的名称标识符？
  
  - 不能

```
let Person = class PersonName {
	identify() { 
		console.log(Person.name, PersonName.name);
    } 
}

let p = new Person(); 

p.identify(); // PersonName PersonName

console.log(Person.name); // PersonName 

console.log(PersonName);
// ReferenceError: PersonName is not defined
```

 

### 8.4.2 类构造函数 

- constructor关键字用于什么？

  - 在类定义块内部

    创建类的构造函数。

- 在使用new操作符创建类的新实例时，

  应该调用什么函数？

  - constructor函数

- 构造函数的定义是否是必需的？

  - 不是

- 不定义构造函数相当于什么？

  - 将构造函数定义为空函数。

#### \01. 实例化 

- 使用new和类

  意味着应该使用什么函数进行实例化？

  - constructor函数

- 使用new调用类的构造函数会执行什么操作？

  - (1) 在内存中创建一个新对象。 

  - (2) 这个新对象内部的[[Prototype]]指针被赋值为

    构造函数的prototype属性。 

  - (3) 构造函数内部的this被赋值为这个新对象

    （即this指向新对象）

  - (4) 执行构造函数内部的代码 

  - (5) 如果构造函数返回非空对象，
    - 返回该对象；
    - 否则，返回刚创建的新对象。

```
class Animal {} 

class Person { 
	constructor() { 
		console.log('person ctor'); 
	} 
}

class Vegetable {
	constructor() { 
		this.color = 'orange'; 
	} 
}

let a = new Animal(); 

let p = new Person(); // person ctor 

let v = new Vegetable(); 

console.log(v.color); // orange
```

- 类实例化时传入的参数会用作谁的参数？
  - 构造函数
- 如果不需要参数，则什么是可选的？
  - 类名后面的括号

```
class Person { 
	constructor(name) { 
		console.log(arguments.length);
        
		this.name = name || null; 
	}
}

let p1 = new Person; // 0 

console.log(p1.name); // null 


let p2 = new Person(); // 0 

console.log(p2.name); // null 


let p3 = new Person('Jake'); // 1 

console.log(p3.name); // Jake
```

- 默认情况下，类构造函数会在执行之后返回什么？

  - this对象

- 构造函数返回的对象会被用作什么？

  - 实例化的对象

- 如果没有引用新创建的this对象，那么这个对象会被怎样？

  - 被销毁。

- 如果返回的不是this对象， 而是其他对象，

  那么这个对象是否会通过instanceof操作符检测出跟类有关联？

  - 不会
    - 因为这个对象的原型指针并没有被修改。 

```
class Person {
	constructor(override) { 
		this.foo = 'foo';
		
       	if (override) { 
       		return { bar: 'bar' }; 
       	}
    }
}

let p1 = new Person(), 

p2 = new Person(true); 

console.log(p1); // Person{ foo: 'foo' } 

console.log(p1 instanceof Person); // true

console.log(p2); // { bar: 'bar' } 

console.log(p2 instanceof Person); // false
```

- 类构造函数与构造函数的主要区别是什么？

  - 调用类构造函数必须使用new操作符

  - 普通构造函数如果不使用new调用，

    - 那么就会以全局的this（通常是window）

      作为内部对象。

- 调用类构造函数时如果忘了使用new则会发生什么？
  - 抛出错误

```
function Person() {} // 把window作为this来构建实例

class Animal {} 

let p = Person(); 

let a = Animal(); 
// TypeError: class constructor Animal cannot be invoked without 'new'
```

- 类构造函数实例化之后是否可以在实例上引用它？
  - 可以

```
class Person {} 

// 使用类创建一个新实例
let p1 = new Person(); 

p1.constructor(); 
// TypeError: Class constructor Person cannot be invoked without 'new' 

// 使用对类构造函数的引用创建一个新实例 
let p2 = new p1.constructor();
```

#### \02. 把类当成特殊函数

- ECMAScript中是否有正式的类这个类型？

  - 没有

- 从各方面来看， ECMAScript类就是一种什么？

  - 特殊函数

- 通过typeof操作符检测类标识符，结果表明它是一个什么？

  - 函数

```
class Person {} 

console.log(Person); // class Person {} 

console.log(typeof Person); // function
```

- 类标识符有prototype属性，

  这个原型有一个constructor属性指向谁？
  
  - 类自身 

```
class Person{} 

console.log(Person.prototype); 
// { constructor: f() } 

console.log(Person === Person.prototype.constructor); // true
```

- 与普通构造函数一样，

  可以使用什么检查构造函数原型

  是否存在于实例的原型链中？

  - instanceof操作符

```
class Person {} 

let p = new Person(); 

console.log(p instanceof Person); // true
```

- instanceof操作符能够确定对象和类的什么关系？

  - 确定这个对象是不是类的实例

- 在类的上下文中，

  类本身在使用new调用时就会被当成什么？

  - 构造函数。

- 类中定义的constructor方法是否会被当成构造函数？
  - 不会
- 在对constructor使用instanceof操作符时会返回什么？
  - false

```
class Person {}

let p1 = new Person();

console.log(p1.constructor === Person); // true 

console.log(p1 instanceof Person); // true 

console.log(p1 instanceof Person.constructor); // false

let p2 = new Person.constructor(); 

console.log(p2.constructor === Person); // false

console.log(p2 instanceof Person); // false 

console.log(p2 instanceof Person.constructor); // true
```

- 是否可以把类作为参数传递？
  - 是

```
// 类可以像函数一样在任何地方定义，比如在数组中 let classList = [
	class { 
		constructor(id) {
    		this.id_ = id; 
    		
    		console.log(`instance ${this.id_}`); 
    	} 
	} 
];

function createInstance(classDefinition, id) {
	return new classDefinition(id); 
}

let foo = createInstance(classList[0], 3141); 
// instance 3141
```

-  类是否可以立即实例化？
  - 可以

```
// 因为是一个类表达式，所以类名是可选的
let p = new class Foo { 
	constructor(x) { 
		console.log(x);
    } 
}('bar'); // bar 

console.log(p); // Foo {}
```



### 8.4.3 实例、原型和类成员 

#### \01. 实例成员 

- 每次通过new调用类标识符时，都会执行什么函数？

  - 类构造函数

- 在类构造函数内部，

  可以为新创建的实例（this）添加什么属性？

  - “自有”属性

- 在构造函数执行完毕后，是否可以给实例继续添加新成员？
  - 可以 

- 每个实例都对应一个唯一的成员对象，这意味着什么？
  - 所有成员都不会在原型上共享

```
class Person { 
	constructor() {
    	// 这个例子先使用对象包装类型定义一个字符串
        // 为的是在下面测试两个对象的相等性 
        this.name = new String('Jack'); 
        
        this.sayName = () => 
        	console.log(this.name); 
        	
        this.nicknames = ['Jake', 'J-Dog'];
     } 
}

let p1 = new Person(), 
p2 = new Person(); 

p1.sayName(); // Jack 

p2.sayName(); // Jack 

console.log(p1.name === p2.name); // false 

console.log(p1.sayName === p2.sayName); // false 

console.log(p1.nicknames === p2.nicknames); // false 

p1.name = p1.nicknames[0];

p2.name = p2.nicknames[1]; 

p1.sayName(); // Jake

p2.sayName(); // J-Dog
```

#### \02. 原型方法与访问器

- 为了在实例间共享方法，类定义语法把什么方法作为原型方法？
  - 在类块中定义的方法

```
class Person {
	constructor() { 
		// 添加到this的所有内容都会存在于不同的实例上 	
		this.locate = () => 
			console.log('instance');
    }
    
    // 在类块中定义的所有内容都会定义在类的原型上
    locate() { 
    	console.log('prototype');
    }
}

let p = new Person(); 

p.locate(); // instance 

Person.prototype.locate(); // prototype
```

- 是否可以把方法定义在

  类构造函数中或者类块中

  - 可以

- 是否能在类块中

  给原型添加

  原始值或对象

  作为成员数据？
  
  - 不能

```
class Person { 
	name: 'Jake';
}
// Uncaught SyntaxError: Unexpected token
```

- 类方法是否可以使用

  字符串、符号、计算的值作为键？

  - 可以
    - 因为类方法等同于对象属性

```
const symbolKey = Symbol('symbolKey'); 

class Person { 

	stringKey() { 
		console.log('invoked stringKey');
     }
     
     [symbolKey]() { 
     	console.log('invoked symbolKey');
     }
     
     ['computed' + 'Key']() { 
     	console.log('invoked computedKey');
      }
}

let p = new Person(); 

p.stringKey(); // invoked stringKey

p[symbolKey](); // invoked symbolKey 

p.computedKey(); // invoked computedKey
```

- 类定义是否支持获取和设置访问器？
  - 支持

```
class Person { 

	set name(newName) { 
		this.name_ = newName;
    }
    
    get name() {
    	return this.name_;
    }
}

let p = new Person(); 

p.name = 'Jake'; 

console.log(p.name); // Jake
```

#### \03. 静态类方法

- 是否可以在类上定义静态方法？
  - 可以
- 静态方法通常用于什么？
  - 执行不特定于实例的操作，
  - 也不要求存在类的实例。
- 静态成员每个类上可以有几个？
  - 只能有一个。 

- 静态类成员在类定义中使用什么关键字作为前缀？
  - static关键字
- 在静态成员中，this引用什么？
  - 类自身

```
class Person { 

	constructor() { 
	
		// 添加到this的所有内容都会存在于不同的实例上
        
		this.locate = () => 
			console.log('instance', this); 
		}
		
		// 定义在类的原型对象上
        
		locate() { 
			console.log('prototype', this); 
		}
		
		// 定义在类本身上 
		
		static locate() { 
			console.log('class', this);
        }
}

let p = new Person();

p.locate(); // instance, Person {} 

Person.prototype.locate();
// prototype, {constructor: ... } 

Person.locate(); // class, class Person {}
```

- 静态类方法非常适合作为什么？
  - 实例工厂

```
class Person { 

	constructor(age) { 
		this.age_ = age; 
	}
	
	sayAge() {
    	console.log(this.age_); 
    }
    
    static create() { 
    	// 使用随机年龄创建并返回一个Person实例
        return new Person(Math.floor(Math.random()*100)); 
    }
}

console.log(Person.create()); 
// Person { age_: ... }
```

#### \04. 非函数原型和类成员

- 虽然类定义是否显式支持

  在原型或类上

  添加成员数据？

  - 不显式支持

- 在类定义外部是否可以手动添加成员数据？

  - 可以

```
class Person { 

	sayName() { 
		console.log(`${Person.greeting} ${this.name}`); 
		
	}
}

// 在类上定义数据成员 
Person.greeting = 'My name is'; 

// 在原型上定义数据成员 
Person.prototype.name = 'Jake'; 

let p = new Person(); 

p.sayName(); // My name is Jake
```

- 类定义中为什么没有显式支持添加数据成员？

  - 因为在共享目标上添加

    可变数据成员

    是一种反模式。

- 一般来说，对象实例应该独自拥有什么数据？
  - 通过this引用的数据

#### \05. 迭代器与生成器方法

### 8.4.4 继承

#### \01. 继承基础 

- ES6类是否支持单继承？

  - 支持

- 使用什么关键字，就可以继承

  任何拥有[[Construct]]和原型的对象？

  - extends关键字

- 这意味着不仅可以继承一个类，

  也可以继承什么？

  - 普通的构造函数（保持向后兼容）

```
class Vehicle {} 

// 继承类 
class Bus extends Vehicle {} 

let b = new Bus(); 

console.log(b instanceof Bus); // true 

console.log(b instanceof Vehicle); // true 

function Person() {} 

// 继承普通构造函数 
class Engineer extends Person {} 

let e = new Engineer(); 

console.log(e instanceof Engineer); // true 

console.log(e instanceof Person); // true
```

- 派生类都会通过什么访问到类和原型上定义的方法？
  - 原型链
- this的值会反映什么？
  - 调用相应方法的实例或者类

```
class Vehicle { 

	identifyPrototype(id) { 
		console.log(id, this); 
	}
	
	static identifyClass(id) { 
		console.log(id, this);
    }
}

class Bus extends Vehicle {} 

let v = new Vehicle();

let b = new Bus(); 

b.identifyPrototype('bus'); // bus, Bus {} 

v.identifyPrototype('vehicle'); 
// vehicle, Vehicle {} 

Bus.identifyClass('bus'); // bus, class Bus {} 

Vehicle.identifyClass('vehicle');
// vehicle, class Vehicle {}
```

- extends关键字是否可以在类表达式中使用？
  - 可以
- let Bar = class extends Foo {} 是否是有效的语法？
  - 是

#### \02. 构造函数、**HomeObject**和**super()**

- 派生类的方法可以通过什么关键字引用它们的原型？

  - super关键字

- super关键字只能在哪里使用？

  - 派生类

  - 仅限于

    - 类构造函数

    - 实例方法
    - 静态方法

    内部。

- 在类构造函数中使用super可以做什么？
  - 调用父类构造函数

```
class Vehicle { 

	constructor() { 
		this.hasEngine = true;
    }
}

class Bus extends Vehicle {

	constructor() { 
	
	// 不要在调用super()之前引用this，
	// 否则会抛出ReferenceError 
	
	super(); // 相当于super.constructor() 	
    
	console.log(this instanceof Vehicle); // true 
	
	console.log(this); // Bus { hasEngine: true } 
	}
}

new Bus();
```

- 在静态方法中可以通过super做什么？
  - 调用继承的类上定义的静态方法

```
class Vehicle { 

	static identify() { 
		console.log('vehicle');
     }
     
}
class Bus extends Vehicle { 

	static identify() { 
		super.identify();
     }
     
}

Bus.identify(); // vehicle
```

- ES6给类构造函数和静态方法添加了什么？
  - 内部特性[[HomeObject]]
- [[HomeObject]]特性是一个指针，指向什么？
  - 定义该方法的对象
- [[HomeObject]]指针是否是自动赋值的？
  - 是
- [[HomeObject]]只能在哪里访问?
  - JavaScript引擎内部 
- 谁始终会定义为[[HomeObject]]的原型？
  - super
- super只能在哪里使用？
  - 派生类构造函数
  - 派生类静态方法

```
class Vehicle {

	constructor() { 
	
		super(); 
		// SyntaxError: 'super' keyword unexpected 
	}
	
}
```

- 是否能单独引用super关键字？
  - 不能
- 如何使用super关键字？
  - 用它调用构造函数，
  - 用它引用静态方法。

```
class Vehicle {}

class Bus extends Vehicle { 

	constructor() { 
	
		console.log(super); 
		// SyntaxError: 'super' keyword unexpected here 
	}
}
```

- 调用super()会执行什么操作？
  - 调用父类构造函数，
  - 并将返回的实例赋值给this

```
class Vehicle {} 

class Bus extends Vehicle {
	constructor() { 
		super(); 
		console.log(this instanceof Vehicle); 
	}
}
new Bus(); // true
```

- super()的行为如同调用构造函数，

  如何给父类构造函数传参？

  - 手动传入

```
class Vehicle { 

	constructor(licensePlate) { 
	
		this.licensePlate = licensePlate;
     }
}

class Bus extends Vehicle { 

	constructor(licensePlate) { 
	
		super(licensePlate); 
	}
}

console.log(new Bus('1337H4X')); 
// Bus { 
//		licensePlate: '1337H4X'
// }
```

- 如果没有定义类构造函数，在实例化派生类时执行什么操作？
  - 会调用super()
    - 会传入所有传给派生类的参数。

```
class Vehicle {

	constructor(licensePlate) { 
	
		this.licensePlate = licensePlate; 
	}
}

class Bus extends Vehicle {} 

console.log(new Bus('1337H4X')); 
// Bus { licensePlate: '1337H4X' }
```

-  在类构造函数中，是否能在调用super()之前引用this？
  - 不能

```
class Vehicle {} 

class Bus extends Vehicle { 

	constructor() { 
	
		console.log(this); 
	}
}

new Bus(); 
// ReferenceError: Must call super constructor in derived class

// before accessing 'this' or returning from derived constructor
```

- 如果在派生类中显式定义了构造函数，则必须做什么？
  - 要么调用super()，
  - 要么返回一个对象

```
class Vehicle {} 

class Car extends Vehicle {} 

class Bus extends Vehicle { 

	constructor() { 
	
		super(); 
	} 
}

class Van extends Vehicle { 

	constructor() { 
	
		return {}; 
	}
}

console.log(new Car()); // Car {} 

console.log(new Bus()); // Bus {} 

console.log(new Van()); // {}
```

#### \03. 抽象基类

- new.target保存什么？
  - 通过new关键字调用的类或函数。
- 通过在实例化时检测new.target是不是抽象基类，可以做什么？
  - 阻止对抽象基类的实例化

```
// 抽象基类 
class Vehicle { 

	constructor() { 
	
		console.log(new.target); 
		
		if (new.target === Vehicle) {
		
        	throw new Error('Vehicle cannot be directly instantiated'); 
        }
    }
}

// 派生类 
class Bus extends Vehicle {}

new Bus(); // class Bus {} 

new Vehicle(); 
// class Vehicle {} 
// Error: Vehicle cannot be directly instantiated
```

- 通过在抽象基类构造函数中进行检查，可以要求什么？
  - 派生类必须定义某个方法。

- 为什么可以通过this关键字来检查相应的方法？

  - 因为原型方法

    在调用类构造函数之前就已经存在了

```
// 抽象基类 
class Vehicle { 

	constructor() { 
	
		if (new.target === Vehicle) {
		
        	throw new Error('Vehicle cannot be directly instantiated'); 
        }
        
        if (!this.foo) { 
        
        	throw new Error('Inheriting class must define foo()'); 
        }
        
        console.log('success!');
     }
}

// 派生类 
class Bus extends Vehicle { 
	foo() {}
}

// 派生类 
class Van extends Vehicle {}

new Bus(); // success! 

new Van(); 
// Error: Inheriting class must define foo()
```

#### \04. 继承内置类型 

- 扩展内置类型

```
class SuperArray extends Array { 

	shuffle() { 
	
		// 洗牌算法 
		for (let i = this.length - 1; i > 0; i--) {
		
        	const j = Math.floor(
        		Math.random() * (i + 1)); 
        		
        	[this[i], this[j]] = [this[j], this[i]]; 		 }
     } 
}

let a = new SuperArray(1, 2, 3, 4, 5); 

console.log(a instanceof Array); // true 

console.log(a instanceof SuperArray); // true 

console.log(a); // [1, 2, 3, 4, 5] 

a.shuffle(); 

console.log(a); // [3, 1, 4, 5, 2]
```

- 默认情况下，返回实例的类型与原始实例的类型是否是一致的？
  - 是一致的

```
class SuperArray extends Array {} 

let a1 = new SuperArray(1, 2, 3, 4, 5); 

let a2 = a1.filter(x => !!(x%2));

console.log(a1); // [1, 2, 3, 4, 5] 

console.log(a2); // [1, 3, 5] 

console.log(a1 instanceof SuperArray); // true 

console.log(a2 instanceof SuperArray); // true
```

- 如果想覆盖这个默认行为，则可以怎么做？
  - 覆盖Symbol.species访问器，
- Symbol.species访问器决定什么？
  - 在创建返回的实例时使用的类

```
class SuperArray extends Array { 

	static get [Symbol.species]() {
	
    	return Array; 
    }
}

let a1 = new SuperArray(1, 2, 3, 4, 5); 

let a2 = a1.filter(x => !!(x%2));

console.log(a1); // [1, 2, 3, 4, 5] 

console.log(a2); // [1, 3, 5] 

console.log(a1 instanceof SuperArray); // true

console.log(a2 instanceof SuperArray); // false
```

#### \05. 类混入

- 如果只是需要混入多个对象的属性，那么可以使用什么方法？
  - Object.assign()
- 下面代码中，extends关键字后面是什么？
  - 一个JavaScript表达式。
- 什么样的表达式是有效的？
  - 任何可以解析为一个类或一个构造函数的表达式
- 这个表达式会在什么时候被求值？
  - 求值类定义时

```
class Vehicle {} 

function getParentClass() { 
	console.log('evaluated expression'); 
	return Vehicle; 
}

class Bus extends getParentClass() {} // 可求值的表达式
```

- 混入模式可以通过什么实现？
  - 在一个表达式中连缀多个混入元素
- 这个表达式最终会解析为什么？
  - 一个可以被继承的类。
- 如果Person类需要组合A、B、C，则需要做什么？
  - 某种机制实现B继承A，C继承B，
  - 而Person再继承C，
  - 从而把A、B、C组合到这个超类中。
- 如何实现上述模式？
  - 定义一组“可嵌套”的函数，
  - 每个函数分别接收一个超类作为参数，
  - 而将混入类定义为这个参数的子类，并返回这个类。
  - 这些组合函数可以连缀调用，最终组合成超类表达式

```
class Vehicle {} 

let FooMixin = (Superclass) => 
	class extends Superclass { 
		foo() {
		 console.log('foo');
 	}
};
let BarMixin = (Superclass) => 
	class extends Superclass {
 		bar() {
 			console.log('bar');
 	}
};
let BazMixin = (Superclass) => 
	class extends Superclass {
		 baz() {
 			console.log('baz');
 	}
};

class Bus extends FooMixin(BarMixin(BazMixin(Vehicle))) {}

let b = new Bus();
b.foo(); // foo
b.bar(); // bar
b.baz(); // baz
```

- 如何把嵌套调用展开？
  - 通过写一个辅助函数

```
class Vehicle {}
let FooMixin = (Superclass) => 
	class extends Superclass {
 		foo() {
 			console.log('foo');
 	}
};
let BarMixin = (Superclass) => 
	class extends Superclass {
 		bar() {
 		console.log('bar');
 	}
};
let BazMixin = (Superclass) => 
	class extends Superclass {
 		baz() {
 		console.log('baz');
 	}
};
function mix(BaseClass, ...Mixins) {
 	return Mixins.reduce((accumulator, current) => 	
 		current(accumulator), BaseClass);
}

class Bus extends mix(Vehicle, FooMixin, BarMixin, BazMixin) {}

let b = new Bus();
b.foo(); // foo
b.bar(); // bar
b.baz(); // b
```

- 很多JavaScript框架（特别是React）已经抛弃什么模

  式，转向了什么模式？

  - 抛弃了混入模式

  - 转向了组合模式

    （把方法提取到独立的类和辅助对象中，

    然后把它们组合起来，但不使用继承）。

    

## 8.5 小结 

-  有哪些模式适用于创建对象？
  - 工厂模式
  - 构造函数模式
  - 原型模式
  - 
- 构造函数模式的特点是什么？
  - 可以自定义引用类型，
    - 可以使用new关键字创建自定义类型的实例。

- 构造函数模式的缺点是什么？
  - 其成员无法重用，包括函数
    - 让函数不能在多个对象实例间共享。

- 原型模式解决了什么问题？

  - 成员共享的问题，

- 原型模式如何实现共享？

  - 只要是添加到构造函数prototype上的属性和方法

    就可以共享

- 组合构造函数和原型模式通过什么定义实例属性？

  - 构造函数

- 组合构造函数和原型模式通过什么定义共享的属性和方法？

  - 原型

- JavaScript的继承主要通过什么来实现？

  - 原型链

- 原型链涉及什么？

  - 把构造函数的原型赋值为另一个类型的实例

- 原型链的问题是什么？

  - 所有继承的属性和方法都会在对象实例间共享，

    无法做到实例私有

- 盗用构造函数模式通过什么可以避免原型链的问题？

  - 在子类构造函数中调用父类构造函数，

- 盗用构造函数模式每个实例继承的属性都是私有的还是共享的？

  - 私有的

- 盗用构造函数模式要求类型只能通过什么模式来定义？

  - 构造函数模式
  - （因为子类不能访问父类原型上的方法）。

- 目前最流行的继承模式是什么？ 

  - 组合继承

- 组合继承是什么？

  - 通过原型链继承
    - 共享的属性和方法，
  - 通过盗用构造函数继承
    - 实例属性

- 原型式继承的特点是什么？

  - 可以无须明确定义构造函数而实现继承

- 型式继承本质上是对给定对象执行什么？

  - 浅复制

- 与原型式继承紧密相关的是什么继承？

  - 寄生式继承

- 寄生式继承是什么？

  - 基于一个对象创建一个新对象，
  - 增强这个新对象
  - 返回新对象。

- 寄生式继承模式也被用在什么继承中？用于什么？

  - 组合继承
  - 用于避免重复调用父类构造函数导致的浪费。 

- 什么继承被认为是实现基于类型继承的最有效方式？

  - 寄生组合继承

- ECMAScript 6新增的类很大程度上是基于什么机制的语法糖？

  - 既有原型机制

- 类的语法让开发者可以做什么？

  - 定义向后兼容的类，
  - 继承内置类型，
  - 继承自定义类型

- 类有效地跨越了什么之间的鸿沟？

  - 对象实例
  - 对象原型
  - 对象类

  
