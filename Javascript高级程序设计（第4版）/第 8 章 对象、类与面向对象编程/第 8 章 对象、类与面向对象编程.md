# 第 8 章 对象、类与面向对象编程

## 8.1 理解对象

- 创建自定义对象的通常方式是什么？
  - 创建Object的一个新实例，
  - 然后再给它添加属性和方法

```
let person = new Object(); 
person.name = "Nicholas"; 
person.age = 29; 
person.job = "Software Engineer"; 
person.sayName = function() { 			
	console.log(this.name); 
};
```

- 前面的例子如果使用对象字面量则可以这样写：

```
let person = { 
	name: "Nicholas", 
	age: 29, 
	job: "Software Engineer", 
	sayName() { 
		console.log(this.name); 
	} 
};
```



### 8.1.1 属性的类型

- 属性分哪两种？
  - 数据属性和访问器属性。

#### \01. 数据属性 

- 数据属性有哪4个特性描述它们的行为？

  - [[Configurable]]：表示属性

    - 是否可以通过delete删除并重新定义，

    - 是否可以修改它的特性，

    - 是否可以把它改为访问器属性。

    - 默认情况下是true

  - [[Enumerable]]：表示属性
    - 是否可以通过for-in循环返回。
    
    - 默认情况下是true 
    
  - [[Writable]]：表示属性的值
  
    - 是否可以被修改。
  
    - 默认情况下 是true
  
  - [[Value]]：包含属性实际的值。
    - 读取和写入属性值的位置。
    - 默认值为undefined。
  
- 样将属性显式添加到对象之后，[[Configurable]]、[[Enumerable]]和[[Writable]]、[[Value]]特性会被设置为什么值？

  - [[Configurable]]、[[Enumerable]]和[[Writable]]都会被设置为true
  - [[Value]]特性会被设置为指定的值。

```
let person = { name: "Nicholas" };
```

- [[Value]]特性会被设置为什么？
  - "Nicholas"
- 之后对这个值的任何修改都会保存在哪？
  - [[Value]]特性
- 要修改属性的默认特性，就必须使用什么方法？
  - Object.defineProperty()
- Object.defineProperty()方法接收哪3个参数？
  - 要给其添加属性的对象、
  - 属性的名称 
  - 一个描述符对象
- 描述符对象上的属性可以包含什么？
  - configurable、
  - enumerable、
  - writable
  - value，
  - 跟相关特性的名称一一对应
  - 根据要修改的特性，可以设置其中一个或多个值。 

```
let person = {}; 
Object.defineProperty(person, "name", {
	writable: false,
	value: "Nicholas" 
}); 
console.log(person.name); // "Nicholas" person.name = "Greg"; 
console.log(person.name); // "Nicholas"
```

- name属性的值是否能再修改？
  - 不能
- 在非严格模式下尝试给这个属性重新赋值会执行什么操作？
  - 会被忽略。
- 在严格模式下，尝试修改只读属性的值会执行什么操作？
  - 抛出错误
- 创建不可配置的属性

```
let person = {}; 
Object.defineProperty(person, "name", { 	
	configurable: false,
	value: "Nicholas" 
}); 
console.log(person.name); // "Nicholas" 
delete person.name;
console.log(person.name); // "Nicholas"
```

- 把configurable设置为false，意味着什么？
  - 这个属性不能从对象上删除
  - 非严格模式下对这个属性调用delete没有效果，
  - 严格模式下会抛出错误
- 一个属性被定义为不可配置之后，是否能再变回可配置的？
  - 不能
- 再次调用Object.defineProperty()并修改任何非writable属性会发生什么？
  - 导致错误

```
let person = {}; 
Object.defineProperty(person, "name", {
	configurable: false, 
	value: "Nicholas" 
});
// 抛出错误 
Object.defineProperty(person, "name", { 
	configurable: true, 
	value: "Nicholas"
});
```

- 虽然可以对同一个属性多次调用Object.defineProperty()， 

  但在把configurable设置为false之后就会受限制了

- 在调用Object.defineProperty()时，

  configurable、enumerable和 writable的值如果不指定，则都默认为什么？

  - false

#### \02. 访问器属性

- 访问器属性是否包含数据值？

  - 不包含

- 它们包含什么？

  - 一个获取（getter）函数
  - 一个设置（setter）函数，

- 这两个函数是否必需的？

  - 不是

- 在什么时候会调用获取函数？

  - 读取访问器属性时

- 获取函数的责任就是什么？

  - 返回一个有效的值。

- 在写入访问器属性时，会执行什么操作？

  - 调用设置函数并传入新值，

- 设置函数决定什么？

  - 对数据做出什么修改。

- 访问器属性有哪4个特性描述它们的行为？

  - [[Configurable]]：表示属性
    - 是否可以通过delete删除并重新定义，
    - 是否可以修改它的特性
    - 是否可以把它改为数据属性。
    - 默认情况下是true。 
  - [[Enumerable]]：表示属性
    - 是否可以通过for-in循环返回。
    - 默认情况下，是true。 

  - [[Get]]：获取函数，在读取属性时调用。
    - 默认值为undefined。 

  - [[Set]]：设置函数，在写入属性时调用。
    - 默认值为undefined。 

- 访问器属性是否能直接定义？

  - 不能
  - 必须使用Object.defineProperty()。

```
// 定义一个对象，包含伪私有成员year_和公共成员edition let book = { 
	year_: 2017, 
	edition: 1 
};
Object.defineProperty(book, "year", { 
	get() { 
		return this.year_; 
	},
	set(newValue) { 
		if (newValue > 2017) {
			this.year_ = newValue; 
			this.edition += newValue - 2017; 
		} 
	} 
});
book.year = 2018;
console.log(book.edition); // 2
```

- year_ 中的下划线常用来表示什么？
  - 该属性并不希望在对象方法的外部被访问。
- 另一个属性year被定义为一个什么属性？
  - 访问器属性，
- 其中获取函数会执行什么操作？
  - 简单地返回year_的值，
- 设置函数会执行什么操作？
  - 做一些计算以决定正确的版本（edition）。
- 获取函数和设置函数是否都要定义？
  - 不一定
- 只定义获取函数意味着什么？
  - 属性是只读的，尝试修改属性会被忽略。
  - 在严格模式下，
    - 尝试写入只定义了获取函数的属性会抛出错误。
- 只有一个设置函数的属性是否可以读取？
  - 不能读取的，
    - 非严格模式下读取会返回undefined，
    - 严格模式下会抛出错误。
- 在不支持Object.defineProperty()的浏览器中是否可以修改[[Configurable]]或[[Enumerable]]？
  - 不能 

### 8.1.2 定义多个属性

- 如何在一个对象上同时定义多个属性？
  - 使用Object.defineProperties()方法
- Object.defineProperties()接收哪两个参数？
  - 要为之添加或修改属性的对象
  - 另一个描述符对象，
    - 其属性与要添加或修改的属性一一 对应。

```
let book = {}; 
Object.defineProperties(book, {
	year_: { value: 2017 },
	edition: { value: 1 },
	year: { 
		get() { return this.year_; },
		set(newValue) { 
			if (newValue > 2017) { 
				this.year_ = newValue; 
				this.edition += newValue - 2017; 
			}
		} 
	} 
});
```

- 上述代码中数据属性的configurable、enumerable和writable特性值是什么？
  - false

### 8.1.3 读取属性的特性

- 如何取得指定属性的属性描述符？
  - 使用Object.getOwnPropertyDescriptor()方法
- 这个方法接收哪两个参数？
  - 属性所在的对象
  - 要取得其描述符的属性名
- 返回值是什么？
  - 一个对象
- 对于访问器属性包含什么？
  - configurable、enumerable、get和set属性
- 对于数据属性包含什么？
  - configurable、enumerable、writable和value属性。

```
let book = {}; 
Object.defineProperties(book, {
	year_: { value: 2017 },
	edition: { value: 1 },
	year: { 
		get: function() { return this.year_; },
		set: function(newValue){ 
			if (newValue > 2017) { 
				this.year_ = newValue; 
				this.edition += newValue - 2017; 
			} 
		} 
	} 
}); 
let descriptor = Object.getOwnPropertyDescriptor(book, "year_");
console.log(descriptor.value); // 2017 console.log(descriptor.configurable); // false console.log(typeof descriptor.get); // "undefined" 
let descriptor = Object.getOwnPropertyDescriptor(book, "year"); console.log(descriptor.value); // undefined console.log(descriptor.enumerable); // false console.log(typeof descriptor.get); // "function"
```

- Object.getOwnPropertyDescriptors()静态方法会执行什么操作？
  - 会在每个自有属性上调用Object.getOwnPropertyDescriptor()
  - 并在一个新对象中返回它们。

```
let book = {}; 
Object.defineProperties(book, { 
	year_: { value: 2017 },
	edition: { value: 1 },
	year: { 
		get: function() { 
		return this.year_; 
	},
		set: function(newValue){ 
			if (newValue > 2017) { 
				this.year_ = newValue; 
				this.edition += newValue - 2017;
			} 
		} 
    } 
}); console.log(Object.getOwnPropertyDescriptors(book)); 
// { 
// 	edition: { 
// 		configurable: false, 
// 		enumerable: false,
// 		value: 1, 
// 		writable: false 
// 	}, 
// 	year: { 
// 		configurable: false, 
// 		enumerable: false,
// 		get: f(), 
// 		set: f(newValue), 
// 	},
// 	year_: { 
// 		configurable: false, 
// 		enumerable: false, 
// 		value: 2017, 
// 		writable: false 
// 	}
// }
```

### 8.1.4 合并对象

- 把源对象所有的本地属性一起复制到目标对象上。这种 

  操作也被称为什么？

  - “混入”（mixin）

- Object.assign()方法接收什么参数？

  - 一个目标对象
  - 一个或多个源对象

- Object.assign()执行什么操作？

  - 将每个源对象中可枚举属性和自有属性复制到目标对象

- Object.assign()什么样的属性会被复制？

  - 以字符串和符号为键的

- 对每个符合条件的属性，这个方法会执行什么操作？

  - 使用源对象上的[[Get]]取得属性的值，
  - 然后使用目标对象上的[[Set]]设置属性的值

```
let dest, src, result;
/*** 简单复制 */
dest = {}; 
src = { id: 'src' }; 
result = Object.assign(dest, src); 
// Object.assign修改目标对象 
// 也会返回修改后的目标对象 
console.log(dest === result); // true console.log(dest !== src); // true console.log(result); // { id: src } console.log(dest); // { id: src } 
/*** 多个源对象 */
dest = {}; 
result = Object.assign(dest, { a: 'foo' }, 
{ b: 'bar' }); 
console.log(result); // { a: foo, b: bar }
/*** 获取函数与设置函数 */
dest = { 
	set a(val) { 
		console.log(`Invoked dest setter with param ${val}`); 
	} 
};
src = { 
	get a() { 
		console.log('Invoked src getter'); 
		return 'foo';
    } 
};
Object.assign(dest, src); // 调用src的获取方法
// 调用dest的设置方法并传入参数"foo"
// 因为这里的设置函数不执行赋值操作 
// 所以实际上并没有把值转移过来
console.log(dest); // { set a(val) {...} }
```

- Object.assign()实际上对每个源对象执行的是什么？

  - 浅复制。

- 浅复制意味着什么？

  - 只会复制对象的引用 

- 如果多个源对象都有相同的属性，则使用哪个值？

  - 最后一个复制的值。

- 从源对象访问器属性取得的值，比如获取函数，

  会作为什么值赋给目标对象？

  - 一个静态值

- 能否在两个对象间转移获取函数和设置函数？

  - 不能 

```
let dest, src, result; 
/*** 覆盖属性 */ 
dest = { id: 'dest' };
result = Object.assign(dest, 
	{ 
		id: 'src1',
   		a: 'foo' 
   	}, 
    { 
    	id: 'src2', 
    	b: 'bar' 
    }); 
// Object.assign会覆盖重复的属性 console.log(result); 
// { id: src2, a: foo, b: bar } 
// 可以通过目标对象上的设置函数观察到覆盖的过程： 
dest = { 
	set id(x) { 
		console.log(x); 
	} 
};
Object.assign(dest, 
	{ id: 'first' }, 
	{ id: 'second' }, 
	{ id: 'third' }
); 
// first
// second 
// third 
/*** 对象引用 */ 
dest = {}
src = { a: {} }; 
Object.assign(dest, src); 
// 浅复制意味着只会复制对象的引用 
console.log(dest); // { a :{} } console.log(dest.a === src.a); // true
```

- 如果赋值期间出错，则会发生什么？
  - 操作会中止并退出，
  - 同时抛出错误。
- Object.assign()没有“回滚”之前赋值的概念，因此它是一个尽力而为、可能只会完成什么的方法？
  - 部分复制

```
let dest, src, result; 
/*** 错误处理 */ 
dest = {}; 
src = { 
	a: 'foo', 
	get b() { 
		// Object.assign()在调用这个获取函数时会抛出错误
		throw new Error(); 
	},
	c: 'bar' 
};
try { 
	Object.assign(dest, src); 
} catch(e) {} 
// Object.assign()没办法回滚已经完成的修改 
// 因此在抛出错误之前，目标对象上已经完成的修改会继续存在：
console.log(dest); // { a: foo }
```



### 8.1.5 对象标识及相等判定

- 在ECMAScript 6之前，有些特殊情况即使是===操作符也无能为力： 

```
// 这些是===符合预期的情况 
console.log(true === 1); // false 
console.log({} === {}); // false
console.log("2" === 2); // false 
// 这些情况在不同JavaScript引擎中表现不同，但仍被认为相等 
console.log(+0 === -0); // true 
console.log(+0 === 0); // true 
console.log(-0 === 0); // true 
// 要确定NaN的相等性，必须使用极为讨厌的isNaN() console.log(NaN === NaN); // false console.log(isNaN(NaN)); // true
```

- Object.is()必须接收几个参数？
  - 两个参数

```
console.log(Object.is(true, 1)); // false console.log(Object.is({}, {})); // false console.log(Object.is("2", 2)); // false 
// 正确的0、-0、+0相等/不等判定 console.log(Object.is(+0, -0)); // false console.log(Object.is(+0, 0)); // true console.log(Object.is(-0, 0)); // false 
// 正确的NaN相等判定 
console.log(Object.is(NaN, NaN)); // true
```

- 如何检查超过两个值？
  - 递归地利用相等性传递

```
function recursivelyCheckEqual(x, ...rest) { 	
	return Object.is(x, rest[0]) && 
		(rest.length < 2 || 	
		recursivelyCheckEqual(...rest)); 
}
```



### 8.1.6 增强的对象语法 

#### \01. 属性值简写 

- 属性名和变量名是一样的

```
let name = 'Matt'; 
let person = { name: name };
console.log(person); // { name: 'Matt' }
```

- 简写属性名是什么？
  - 只要使用变量名（不用再写冒号）
    - 就会自动被解释为同名的属性键
- 如果没有找到同名变量，则会发生什么？
  - 抛出ReferenceError。 

```
let name = 'Matt'; 
let person = { name };
console.log(person); // { name: 'Matt' }
```

- 代码压缩程序会在不同作用域间做什么，

  以防止找不到引用？

  - 保留属性名

```
function makePerson(name) { 
	return { name }; 
}
let person = makePerson('Matt'); console.log(person.name); // Matt
```

- 在这里，参数标识符只限定于函数作用域，

  编译器会做什么？

  - 保留初始的name标识符

- 如果使用Google Closure编译器压缩，会执行什么操作？
  - 那么函数参数会被缩短，而属性名不变：

```
function makePerson(a) { 
	return { name: a }; 
}
var person = makePerson("Matt"); console.log(person.name); // Matt
```

#### \02. 可计算属性

- 在引入可计算属性之前，

  如果想使用变量的值作为属性，那么必须做什么？

  - 先声明对象，
  - 然后使用中括号语法来添加属性

- 能否在对象字面量中直接动态命名属性？

  - 不能

```
const nameKey = 'name'; 
const ageKey = 'age'; 
const jobKey = 'job'; 
let person = {}; 
person[nameKey] = 'Matt'; 
person[ageKey] = 27; 
person[jobKey] = 'Software engineer'; console.log(person); 
// { name: 'Matt', age: 27, job: 'Software engineer' }
```

- 中括号包围的对象属性键运行时将其作为什么来求值？
  - JavaScript表达式

```
const nameKey = 'name'; 
const ageKey = 'age'; 
const jobKey = 'job'; 
let person = { 
	[nameKey]: 'Matt', 
	[ageKey]: 27, 
	[jobKey]: 'Software engineer' 
};
console.log(person); 
// { name: 'Matt', age: 27, job: 'Software engineer' }
```

- 可计算属性本身是否可以是复杂的表达式，

  在实例化时再求值？

  - 可以
    - 因为被当作JavaScript表达式求值

```
const nameKey = 'name'; 
const ageKey = 'age'; 
const jobKey = 'job'; 
let uniqueToken = 0; 

function getUniqueKey(key) { 
	return `${key}_${uniqueToken++}`; 
}
let person = { 
	[getUniqueKey(nameKey)]: 'Matt', 	
	[getUniqueKey(ageKey)]: 27, 
	[getUniqueKey(jobKey)]: 'Software engineer' };
	
console.log(person); 
// { name_0: 'Matt', age_1: 27, job_2: 'Software engineer'
```

- 可计算属性表达式中抛出任何错误是否会中断对象创建？
  - 是
- 如果表达式抛出错误，之前完成的计算是否能回滚？
  - 不能

#### \03. 简写方法名

- 在给对象定义方法时，通常都要怎么做？
  - 写一个方法名、冒号，
  - 然后再引用一个匿名函数表达式，

```
let person = { 
	sayName: function(name) { 
		console.log(`My name is ${name}`); 
	} 
};
person.sayName('Matt'); // My name is Matt
```

- 缩短方法声明：

```
let person = { 
	sayName(name) { 
		console.log(`My name is ${name}`); 
	}
};
person.sayName('Matt'); // My name is Matt
```

- 简写方法名对获取函数和设置函数是否适用？
  - 是

```
let person = { 
	name_: '', 
	get name() { 
		return this.name_; 
	},
	set name(name) { 
		this.name_ = name; 
	},
	sayName() { 
		console.log(`My name is ${this.name_}`);
	} 
};
person.name = 'Matt'; 
person.sayName(); // My name is Matt
```

- 简写方法名与可计算属性键是否相互兼容？
  - 是

```
const methodKey = 'sayName'; 
let person = { 
	[methodKey](name) { 
		console.log(`My name is ${name}`); 
	} 
}
person.sayName('Matt'); // My name is Matt
```

 

### 8.1.7 对象解构 

- 对象解构语法，可以做什么？

  - 实现一个或多个赋值操作

- 对象解构是什么？

  - 使用与对象匹配的结构

    来实现对象属性赋值。 

- 是不使用对象解构的：

```
// 不使用对象解构 
let person = { 
	name: 'Matt', 
	age: 27 
};
let personName = person.name, 
personAge = person.age; 
console.log(personName); // Matt console.log(personAge); // 27
```

- 使用对象解构的：

```
// 使用对象解构 
let person = { 
	name: 'Matt', 
	age: 27 
};
let { 
	name: personName, 
	age: personAge 
} = person; 
console.log(personName); // Matt
console.log(personAge); // 27
```

- 使用解构，可以在一个类似对象字面量的结构中，做什么？
  - 声明多个变量，
  - 同时执行多个赋值操作。
- 如果想让变量直接使用属性的名称，那么应该怎么做？
  - 使用简写语法

```
let person = { 
	name: 'Matt', 
	age: 27 
};
let { name, age } = person; 
console.log(name); // Matt 
console.log(age); // 27
```

- 解构赋值是否一定与对象的属性匹配？
  - 不一定
- 赋值的时候是否可以忽略某些属性？
  - 可以
- 如果引用的属性不存在，则该变量的值就是？
  - undefined

```
let person = { 
	name: 'Matt', 
	age: 27 
};
let { name, job } = person; 
console.log(name); // Matt 
console.log(job); // undefined
```

- 是否可以在解构赋值的同时定义默认值？
  - 可以
  - 这适用于引用的属性不存在于源对象中的情况

```
let person = { 
	name: 'Matt', 
	age: 27 
};
let { 
	name, 
	job='Software engineer' 
} = person; 
console.log(name); // Matt 
console.log(job); // Software engineer
```

- 解构在内部执行什么操作？
  - 使用函数ToObject()（不能在运行时环境中直接访问）
  - 把源数据结构转换为对象。
- 在对象解构的上下文中，原始值会被当成什么？
  - 对象。
- null和undefined是否能被解构？
  - 不能
    - 否则会抛出错误

```
let { length } = 'foobar';
console.log(length); // 6 
let { constructor: c } = 4; 
console.log(c === Number); // true 
let { _ } = null; // TypeError 
let { _ } = undefined; // TypeError
```

- 解构是否要求变量必须在解构表达式中声明？
  - 不要求
- 如果是给事先声明的变量赋值，则赋值表达式必须做什么？
  - 包含在一对括号中

```
let personName, personAge; 
let person = { name: 'Matt', age: 27 };
({name: personName, age: personAge} = person); console.log(personName, personAge); // Matt, 27
```

#### \01. 嵌套解构

- 解构对于引用嵌套的属性或赋值目标是否有限制？
  - 没有
- 如何复制对象属性？
  - 通过解构

```
let person = { 
	name: 'Matt', 
	age: 27, 
	job: { title: 'Software engineer' } 
};
let personCopy = {}; 
({
	name: personCopy.name, 
	age: personCopy.age, 
	job: personCopy.job 
} = person); 
// 因为一个对象的引用被赋值给personCopy，所以修改 
// person.job对象的属性也会影响personCopy 
person.job.title = 'Hacker';
console.log(person); 
// { 
//		name: 'Matt', 
//		age: 27, 
//		job: { title: 'Hacker' } 
// } 
console.log(personCopy); 
// { 
//		name: 'Matt', 
//		age: 27, 
//		job: { title: 'Hacker' } 
// } 
```

- 解构赋值如何实现匹配嵌套的属性？
  - 使用嵌套结构

```
let person = { 
	name: 'Matt', 
	age: 27, 
	job: { title: 'Software engineer' } 
};
// 声明title变量并将person.job.title的值赋给它 
let { job: { title } } = person; console.log(title); // Software engineer
```

- 在什么情况下不能使用嵌套解构？
  - 在外层属性没有定义的情况下
    - 无论源对象还是目标对象都一样

```
let person = { 
	job: {
    	title: 'Software engineer' 
    } 
};
let personCopy = {}; // foo在源对象上是undefined 
({
	foo: { 
		bar: personCopy.bar 
	} 
} = person); 
// TypeError: Cannot destructure property 'bar' of 'undefined' or 'null'. 
// job在目标对象上是undefined 
({
	job: { 
		title: personCopy.job.title 
	} 
} = person); 
// TypeError: Cannot set property 'title' of undefined
```

#### \02. 部分解构 

- 需要注意的是，涉及多个属性的解构赋值是一个什么操作？

  - 输出无关的顺序化操作

- 如果一个解构表达式涉及多个赋值，开始的赋值成功而后面 

  的赋值出错，则整个解构赋值会发生什么？

  - 只会完成一部分

```
let person = { 
	name: 'Matt',
	age: 27 
};
let personName, personBar, personAge; 
try { 
// person.foo是undefined，因此会抛出错误 
({
	name: personName, 
	foo: { bar: personBar }, 
	age: personAge} = person); 
} catch(e) {}
console.log(personName, personBar, personAge);
// Matt, undefined, undefined
```

#### \03. 参数上下文匹配

- 在函数参数列表中是否可以进行解构赋值？
  - 可以
- 对参数的解构赋值是否会影响arguments对象？
  - 不会
- 可以在什么中声明在函数体内使用局部变量？
  - 函数签名

```
let person = { 
	name: 'Matt', 
	age: 27 
};
function printPerson(foo, {name, age}, bar) {
	console.log(arguments); 
	console.log(name, age); 
}
function printPerson2(foo, {name: personName, age: personAge}, bar) {
	console.log(arguments); 
	console.log(personName, personAge); 
}
printPerson('1st', person, '2nd'); 
// ['1st', { name: 'Matt', age: 27 }, '2nd']
// 'Matt', 27 
printPerson2('1st', person, '2nd'); 
// ['1st', { name: 'Matt', age: 27 }, '2nd']
// 'Matt', 27
```

## **8.2** 创建对象

- 虽然使用Object构造函数或对象字面量可以方便地创建对象，但这些方式有什么明显不足？

  - 创建具有同样接口的多个对象

    需要重复编写很多代码

### 8.2.1 概述 

### 8.2.2 工厂模式 

- 工厂模式用于什么？
  - 抽象创建特定对象的过程

```
function createPerson(name, age, job) { 
	let o = new Object(); 
	o.name = name;
    o.age = age; 
    o.job = job; 
    o.sayName = function() { 		
    	console.log(this.name); 
    };
    return o;
}
let person1 = createPerson("Nicholas", 29, "Software Engineer"); 
let person2 = createPerson("Greg", 27, "Doctor");
```

- 工厂模式没有解决什么问题？

  - 对象标识问题

    （即新创建的对象是什么类型）。 

### 8.2.3 构造函数模式 

- ECMAScript中的构造函数是用于什么？
  - 创建特定类型对象
- 如何自定义构造函数？
  - 以函数的形式为自己的对象类型定义属性和方法

```
function Person(name, age, job){ 
	this.name = name; 
	this.age = age; 
	this.job = job; 
	this.sayName = function() { 
		console.log(this.name); 
	}; 
}let person1 = new Person("Nicholas", 29, "Software Engineer"); 
let person2 = new Person("Greg", 27, "Doctor"); person1.sayName(); // Nicholas 
person2.sayName(); // Greg
```

- 构造函数模式和工程模式的区别？

  - 没有显式地创建对象。 

  - 属性和方法直接赋值给了this。 

  - 没有return。 

- 按照惯例，构造函数名称有什么规定？

  - 首字母都是要大写的，
    - 非构造函数则以小写字母开头。

- 要创建Person的实例，应使用什么操作符？

  - new操作符。

- 以这种方式调用构造函数会执行哪些操作？

  - (1) 在内存中创建一个新对象。 

  - (2) 这个新对象内部的[[Prototype]]特性

    被赋值为构造函数的prototype属性。 

  - (3) 构造函数内部的this

    被赋值为这个新对象（即this指向新对象）。 

  - (4) 执行构造函数内部的代码（给新对象添加属性）。 

  - (5) 如果构造函数返回非空对象，
    - 则返回该对象；
    - 否则，返回刚创建的新对象

- person1和person2分别保存着Person的不同实例。 

  这两个对象都有一个什么属性指向Person？

  - constructor属性

- constructor本来是用于什么？

  - 标识对象类型的

- 一般认为什么操作符是确定对象类型更可靠的方式？

  - instanceOf操作符

- 前面例子中的每个对象都是谁的实例？

  - Object的实例，
  - 同时也是Person的实例

```
console.log(person1 instanceof Object); // true console.log(person1 instanceof Person); // true console.log(person2 instanceof Object); // true console.log(person2 instanceof Person); // true
```

- 定义自定义构造函数可以确保什么？
  - 实例被标识为特定类型，
- person1和person2为什么被认为是Object的实例？
  - 因为所有自定义对象都继承自Object
- 构造函数是否一定要写成函数声明的形式？还有哪些形式?
  - 不一定
  - 赋值给变量的函数表达式也可以表示构造函数

```
let Person = function(name, age, job) {
	this.name = name; 
	this.age = age; 
	this.job = job;
    this.sayName = function() { 	
    	console.log(this.name); 
    }; 
}
let person1 = new Person("Nicholas", 29, "Software Engineer"); 
let person2 = new Person("Greg", 27, "Doctor"); person1.sayName(); // Nicholas 
person2.sayName(); // Greg 
console.log(person1 instanceof Object); // true console.log(person1 instanceof Person); // true console.log(person2 instanceof Object); // true console.log(person2 instanceof Person); // true
```

- 在实例化时，如果不想传参数，那么可以怎么做？
  - 构造函数后面的括号可加可不加。 

- 只要有什么操作符，就可以调用相应的构造函数？
  - new操作符

```
function Person() {
	this.name = "Jake"; 
	this.sayName = function() { 
		console.log(this.name); 
	}; 
}
let person1 = new Person(); 
let person2 = new Person; 
person1.sayName(); // Jake 
person2.sayName(); // Jake 
console.log(person1 instanceof Object); // true console.log(person1 instanceof Person); // true console.log(person2 instanceof Object); // true console.log(person2 instanceof Person); // true
```

#### \01. 构造函数也是函数 

- 构造函数与普通函数唯一的区别就是什么？
  - 调用方式不同
- 构造函数是否是函数？
  - 是
- 任何函数只要怎么调用就是构造函数？
  - 使用new操作符调用
- 不使用new操作符调用的函数就是什么函数？
  - 普通函数

```
// 作为构造函数 
let person = new Person("Nicholas", 29, "Software Engineer"); 
person.sayName(); // "Nicholas" 
// 作为函数调用 
Person("Greg", 27, "Doctor"); // 添加到window对象 window.sayName(); // "Greg"
// 在另一个对象的作用域中调用 
let o = new Object(); 
Person.call(o, "Kristen", 25, "Nurse"); o.sayName(); // "Kristen"
```

- 没有使用new操作符调用Person()，结果会发生什么？

  - 会将属性和方法添加到window对象。

- 为什么window对象上有了一个sayName()方法？

  -  因为在调用一个函数而没有明确设置this值的情况下 

    （即没有作为对象的方法调用，

    或者没有使用call()/apply()调用），

    - this始终指向Global对象

    - （在浏览器中就是window对象）。

- 最后展示的调用方式是通过call() （或apply()）调用函数，同时执行什么操作？
  - 将特定对象指定为作用域。
- 为什么所有属性和sayName()方法都会添加到对象o上面。
  - 因为这里的调用将o对象指定为Person()内部的this值

#### \02. 构造函数的问题 

- 构造函数的主要问题在于什么？

  - 其定义的方法会在每个实例上都创建一遍。

- person1和person2都有名为sayName()的方法，

  但这两个方法是否同一个Function实例？

  - 不是

- ECMAScript中的函数是什么类型？
  - 对象类型
- 每次定义函数时，都会做什么？
  - 初始化一个对象。

```
function Person(name, age, job){ 
	this.name = name; 
	this.age = age; 
	this.job = job;
	this.sayName = new Function("console.log(this.name)");// 逻辑等价 
}
```

- 为什么不同实例上的函数虽然同名却不相等
  - 函数会带来不同的作用域链和标识符解析。

```
console.log(person1.sayName == person2.sayName); // false
```

- 为什么没必要定义两个不同的Function实例？
  - 因为都是做一样的事

- this对象可以把函数与对象的绑定推迟到什么时候？
  - 运行时

- 如何解决两个不同的Function实例的问题？
  - 可以把函数定义转移到构造函数外部

```
function Person(name, age, job){ 
	this.name = name; 
	this.age = age;
    this.job = job; 
    this.sayName = sayName; 
}
function sayName() { 
	console.log(this.name); 
}
let person1 = new Person("Nicholas", 29, "Software Engineer"); 
let person2 = new Person("Greg", 27, "Doctor"); person1.sayName(); // Nicholas person2.sayName(); // Greg
```

- 如果这个对象需要多个方法，

  那么就要在全局作用域中定义多个函数。

  这会导致什么？

  - 自定义类型引用的代码不能很好地聚集一起。

- 这个新问题可以通过什么模式来解决？
  - 原型模式

### 8.2.5 对象迭代 

- 每个函数都会创建一个什么属性？

  - prototype

- prototype属性是一个什么？

  - 对象

- prototype包含什么？

  - 应该由特定引用类型的实例共享的属性和方法。

- prototype对象就是什么？

  - 通过调用构造函数

    创建的对象的原型。

- 使用原型对象的好处是什么？

  - 在它上面定义的属性和方法

    可以被对象实例共享。

- 原来在构造函数中

  直接赋给对象实例的值，

  可以直接赋值给谁？

  - 它们的原型，

```
function Person() {} 
Person.prototype.name = "Nicholas"; Person.prototype.age = 29; 
Person.prototype.job = "Software Engineer"; Person.prototype.sayName = function() {
console.log(this.name);
};
let person1 = new Person(); 
person1.sayName(); // "Nicholas" 
let person2 = new Person(); 
person2.sayName(); // "Nicholas" console.log(person1.sayName == person2.sayName); // true
```

- 使用函数表达式也可以： 

```
let Person = function() {}; 
Person.prototype.name = "Nicholas"; Person.prototype.age = 29; 
Person.prototype.job = "Software Engineer"; Person.prototype.sayName = function() { console.log(this.name); };
let person1 = new Person(); 
person1.sayName(); // "Nicholas" 
let person2 = new Person();
person2.sayName(); // "Nicholas" console.log(person1.sayName == person2.sayName); // true
```

#### \01. 理解原型 

- 只要创建一个函数，就会按照特定的规则为这个函数创 

  建一个什么属性？

  - prototype属性（指向原型对象）。

- 默认情况下，所有原型对象自动获得一个名为什么的属性？

  - constructor
    - 指回与之关联的构造函数。

- 在自定义构造函数时，原型对象默认只会获得什么属性？

  - constructor

- 原型对象其他的所有方法都继承自谁？

  - Object

- 每次调用构造函数创建一个新实例，

  这个实例的内部什么指针就会被赋值为

  构造函数的原型对象？

  - [[Prototype]]指针。

- 脚本中是否有访问这个[[Prototype]]特性的标准方式？

  - 没有

- 通过什么属性可以访问对象的原型？
  - \__proto__属性，
- 实例与构造函数原型之间是否有直接的联系？
  - 有
- 实例与构造函数之间是否有直接的联系？
  - 没有

```
/*** 构造函数可以是函数表达式 
* 也可以是函数声明，因此以下两种形式都可以：
* function Person() {} 
* let Person = function() {}
*/ 
function Person() {} 
/**
* 声明之后，构造函数就有了一个
* 与之关联的原型对象： 
*/ 
console.log(typeof Person.prototype); console.log(Person.prototype); 
// {
// 		constructor: f Person(),
// 		__proto__: Object 
// } 
/**
* 如前所述，构造函数有一个prototype属性 
* 引用其原型对象，而这个原型对象也有一个 
* constructor属性，引用这个构造函数
* 换句话说，两者循环引用： 
*/ 
console.log(Person.prototype.constructor === Person); // true
/**
* 正常的原型链都会终止于Object的原型对象 
* Object原型的原型是null */ console.log(Person.prototype.__proto__ === Object.prototype); // true console.log(Person.prototype.__proto__.constructor === Object); // true console.log(Person.prototype.__proto__.__proto__ === null); // true console.log(Person.prototype.__proto__); 
// {
// 		constructor: f Object(),
// 		toString: ... 
// 		hasOwnProperty: ...
// 		isPrototypeOf: ... 
// 		... 
// } 
let person1 = new Person(), 
person2 = new Person(); 
/**
* 构造函数、原型对象和实例 
* 是3个完全不同的对象： 
*/ 
console.log(person1 !== Person); // true console.log(person1 !== Person.prototype); // true console.log(Person.prototype !== Person); // true 
/**
* 实例通过__proto__链接到原型对象， 
* 它实际上指向隐藏特性[[Prototype]] 
*
* 构造函数通过prototype属性链接到原型对象 
*
* 实例与构造函数没有直接联系，与原型对象有直接联系
*/ 
console.log(person1.__proto__ === Person.prototype); // true conosle.log(person1.__proto__.constructor === Person); // true 
/**
* 同一个构造函数创建的两个实例 
* 共享同一个原型对象： 
*/ 
console.log(person1.__proto__ === person2.__proto__); // true 
/**
* instanceof检查实例的原型链中 
* 是否包含指定构造函数的原型： 
*/
console.log(person1 instanceof Person); // true console.log(person1 instanceof Object); // true console.log(Person.prototype instanceof Object); // true
```

![image-20220323161724717](C:\Users\KEVIN\Desktop\Written-Examination-JS\Javascript高级程序设计（第4版）\第 8 章 对象、类与面向对象编程\第 8 章 对象、类与面向对象编程.assets\image-20220323161724717.png)

- 为什么这两个实例都没有属性和方法，

  但person1.sayName()可以正常调用。

  - 这是由于对象属性查找机制的原因

- 可以使用什么方法确定两个对象之间的原型关系？

  - isPrototypeOf()

- isPrototypeOf()会在什么情况下返回true？

  - 传入参数的[[Prototype]]指向调用它的对象时

```
console.log(Person.prototype.isPrototypeOf(person1)); // true console.log(Person.prototype.isPrototypeOf(person2)); // true
```

- Object.getPrototypeOf()返回什么？
  - 返回参数的内部特性[[Prototype]]的值

```
console.log(Object.getPrototypeOf(person1) == Person.prototype); // true console.log(Object.getPrototypeOf(person1).name); // "Nicholas"
```

- 使用Object.getPrototypeOf()可以方便地取得什么？
  - 一个对象的原型，
- setPrototypeOf()方法，可以做什么？
  - 向实例的私有特性[[Prototype]]写入一个新值。
    - 可以重写一个对象的原型继承关系

```
let biped = {
	numLegs: 2 
};
let person = { 
	name: 'Matt' 
};
Object.setPrototypeOf(person, biped); console.log(person.name); // Matt console.log(person.numLegs); // 2 console.log(Object.getPrototypeOf(person) === biped); // true
```

-  Object.setPrototypeOf()可能会有什么问题？
  - 严重影响代码性能。 

- 为避免使用Object.setPrototypeOf()可能造成的性能下降，可以做什么？
  - 通过Object.create()来创建一个新对象，
  - 同时为其指定原型：

```
let biped = { numLegs: 2 };
let person = Object.create(biped); 
person.name = 'Matt'; 
console.log(person.name); // Matt console.log(person.numLegs); // 2 console.log(Object.getPrototypeOf(person) === biped); // true
```

#### \02. 原型层级

- 在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索开始于对象实例本身。
- 如果在这个实例上发现了给定的名称，
  - 则返回该名称对应的值。

- 如果没有找到这个属性，
  - 则搜索会沿着指针进入原型对象，
    - 然后在原型对象上找到属性后，再返回对应的值。
- 前面提到的constructor属性只存在于哪里？
  - 原型对象，
  - 因此通过实例对象也是可以访问到的。 
- 虽然可以通过实例读取原型对象上的值，
  - 但不可能通过实例重写这些值。
- 如果在实例上添加了一个与原型对象中同名的属性，
  - 那就会在实例上创建这个属性，
    - 这个属性会遮住原型对象上的属性。

```
function Person() {} 
Person.prototype.name = "Nicholas"; 
Person.prototype.age = 29; 
Person.prototype.job = "Software Engineer"; 
Person.prototype.sayName = function() { 
	console.log(this.name);
};
let person1 = new Person();
let person2 = new Person();
person1.name = "Greg"; 
console.log(person1.name); // "Greg"，来自实例 console.log(person2.name); // "Nicholas"，来自原型
```

- 只要给对象实例添加一个属性，
  - 这个属性就会遮蔽（shadow）原型 

- 对象上的同名属性，会屏蔽对它的访问。
- 即使在实例上把这个属性设置为null，
  - 也不会恢复它和原型的联系。
- 不过，使用delete操作符可以完全删除实例上的这个属性， 
  - 从而让标识符解析过程能够继续搜索原型对象。 

```
function Person() {} 
Person.prototype.name = "Nicholas"; Person.prototype.age = 29; 
Person.prototype.job = "Software Engineer"; Person.prototype.sayName = function() { 		
	console.log(this.name); 
};
let person1 = new Person();
let person2 = new Person(); 
person1.name = "Greg"; 
console.log(person1.name); // "Greg"，来自实例 console.log(person2.name); // "Nicholas"，来自原型 delete person1.name; 
console.log(person1.name); // "Nicholas"，来自原型
```

- hasOwnProperty()方法用于

  - 确定某个属性是在实例上

    还是在原型对象上。

- 这个方法是继承自Object的，

  - 会在属性存在于调用它的对象实例上时返回true

```
function Person() {} 
Person.prototype.name = "Nicholas"; Person.prototype.age = 29; 
Person.prototype.job = "Software Engineer"; Person.prototype.sayName = function() { 		
	console.log(this.name);
};
let person1 = new Person();
let person2 = new Person(); console.log(person1.hasOwnProperty("name")); 
// false

person1.name = "Greg"; 
console.log(person1.name); // "Greg"，来自实例 console.log(person1.hasOwnProperty("name")); // true 
console.log(person2.name); // "Nicholas"，来自原型 console.log(person2.hasOwnProperty("name")); // false 

delete person1.name; 
console.log(person1.name); // "Nicholas"，来自原型 console.log(person1.hasOwnProperty("name")); // false
```

- 注意 ECMAScript的

  Object.getOwnPropertyDescriptor()方法 

  - 只对实例属性有效。

- 要取得原型属性的描述符，

  - 就必须直接在

    原型对象上调用Object.getOwnPropertyDescriptor()。 

#### \03. 原型和**in**操作符

- 有两种方式使用in操作符：

  - 单独使用
  - 在for-in循环中使用。

- 在单独使用时，

  - in操作符会在可以通过对象

    访问指定属性时

    返回true， 

  - 无论该属性是在实例上还是在原型上。

```
function Person() {} 
Person.prototype.name = "Nicholas"; Person.prototype.age = 29;
Person.prototype.job = "Software Engineer"; Person.prototype.sayName = function() { console.log(this.name); 
};
let person1 = new Person(); 
let person2 = new Person(); console.log(person1.hasOwnProperty("name"));
// false 
console.log("name" in person1); // true person1.name = "Greg"; 
console.log(person1.name); // "Greg"，来自实例 console.log(person1.hasOwnProperty("name")); // true 
console.log("name" in person1); // true console.log(person2.name); // "Nicholas"，来自原型 console.log(person2.hasOwnProperty("name")); // false 
console.log("name" in person2); // true 
delete person1.name;
console.log(person1.name); // "Nicholas"，来自原型 console.log(person1.hasOwnProperty("name")); // false 
console.log("name" in person1); // true
```

- 如果要确定某个属性是否存在于原型上

  - 则同时使用hasOwnProperty()

    和 in操作符：

```
function hasPrototypeProperty(object, name){
	return !object.hasOwnProperty(name)
    && (name in object);
}
```

- 只要通过对象可以访问，

  - in操作符就返回true， 

  - 而hasOwnProperty()只有属性存在于实例上时
    - 才返回true。

- 因此， 只要in操作符返回true且hasOwnProperty()返回false，就说明该属 

  性是一个原型属性。来看下面的例子： 

### 8.3.2 盗用构造函数 

### 8.3.3 组合继承

### 8.3.4 原型式继承 

### 8.3.5 寄生式继承

### 8.3.6 寄生式组合继承

## 8.4 类

### 8.4.1 类定义 

### 8.4.2 类构造函数 

### 8.4.3 实例、原型和类成员 

### 8.4.4 继承

## 8.5 小结 

 

