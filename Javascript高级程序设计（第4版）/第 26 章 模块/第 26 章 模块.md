# 第 **26** 章 模块

- 本章内容

  - 理解模块模式 

  - 凑合的模块系统 

  - 使用前ES6模块加载器 

  - 使用ES6模块 

## **26.1** 理解模块模式 

### **26.1.1** 模块标识符 

- 模块系统本质上是
  - 键/值实体，
- 每个模块都有个
  - 可用于引用它的标识符。
- 完善的模块系统
  - 一定不会存在模块标识冲突的问题，
  - 且系统中的任何模块都应该能够
    - 无歧义地引用其他模块。

- 原生浏览器模块标识符
  - 必须提供实际JavaScript文件的路径。
  - 除了文件路径，
    - Node.js还会搜索node_modules目录，
      - 用标识符去匹配包含index.js的目录

### **26.1.2** 模块依赖 

- 模块系统的核心是
  - 管理依赖。
- 本地模块向模块系统声明一组外部模块（依赖），
  - 这些外部模块对于当前模块正常运行是必需的。
  - 模块系统检视这些依赖，
    - 进而保证这些外部模块能够被加载
    - 并在本地模块运行时初始化所有依赖。 

- 每个模块都会与某个唯一的标识符关联，
  - 该标识符可用于检索模块。
  - 这个标识符通常是JavaScript文件的路径，
  - 但在某些模块系统中，
    - 这个标识符也可以是
      - 在模块本身内部声明的命名空间路径字符串

### **26.1.3** 模块加载 

- 当一个外部模块被指定为依赖时，
  - 本地模块期望在执行它时，
    - 依赖已准备好并已初始化。 

- 加载模块涉及执行其中的代码， 
  - 但必须是在所有依赖都加载并执行之后。
- 如果浏览器没有收到依赖模块的代码，
  - 则必须发送请求
  - 并等待网络返回。
- 收到模块代码之后，
  - 浏览器必须确定刚收到的模块是否也有依赖。
  - 然后递归地评估并加载所有依赖，
  - 直到所有依赖模块都加载完成。
- 只有整个依赖图都加载完成，
  - 才可以执行入口模块。 

### **26.1.4** 入口

- 相互依赖的模块必须指定一个模块作为入口（entry point），
  - 这也是代码执行的起点。
- 因为JavaScript是顺序执行的，并且是单线程的，
  - 所以代码必须有执行的起点。
- 入口模块也可能依赖其他模块，
  - 其他模块同样可能有自己的依赖。
- 于是模块化JavaScript应用程序的所有模块
  - 会构成依赖图。 

- 可以通过有向图来表示
  - 应用程序中各模块的依赖关系。
- 应用程序的模块依赖关系图。

![image-20220430212438411](第 26 章 模块.assets/image-20220430212438411.png)

- 因为模块是
  - 作为包含将立即执行的JavaScript代码的文件实现的，
  - 所以一种可能是按照依赖图的要求依次请求各个脚本。
- 对于前面的应用程序来说，
  - 下面的脚本请求顺序能够满足依赖图的要求： 

```
<script src="moduleE.js"></script>
<script src="moduleD.js"></script>
<script src="moduleC.js"></script>
<script src="moduleB.js"></script>
<script src="moduleA.js"></script>

```

- 模块加载是“阻塞的”，
  - 这意味着前置操作必须完成才能执行后续操作。 

- 每个模块在自己的代码到达浏览器之后完成加载，
  - 此时其依赖已经加载并初始化。
- 为一个应用程序而按顺序加载五个JavaScript文件并不理想，
  - 并且手动管理正确的加载顺序也颇为棘手。 

### **26.1.5** 异步依赖

- 因为JavaScript可以异步执行，
  - 所以如果能按需加载就好了。
- 可以让JavaScript通知模块系统在必要时加载新模块，
  - 并在模块加载完成后提供回调。
  - 在代码层面，可以通过下面的伪代码来实现：

```
// 在模块A里面 
load('moduleB').then(function (moduleB) {
    moduleB.doStuff();
});
```

- 模块A的代码使用了moduleB标识符
  - 向模块系统请求加载模块B，
  - 并以模块B作为参数调用回调。
- 模块B可能已加载完成，也可能必须重新请求和初始化，
  - 但这里的代码并不关心。
  - 这些事情都交给了模块加载器去负责。

- 如果重写前面的应用程序，只使用动态模块加载，
  - 那么使用一个\<script>标签即可完成模块A的加载。
  - 模块A会按需请求模块文件，
    - 而不会生成必需的依赖列表。
  - 这样有几个好处，其中之一就是性能，
    - 因为在页面加载时只需同步加载一个文件。

- 这些脚本也可以分离出来，
  - 比如给\<script>标签应用defer或async属性，
  - 再加上能够识别异步脚本何时加载和初始化的逻辑。
    - 此行为将模拟在ES6模块规范中实现的行为

### **26.1.6** 动态依赖 

- 有些模块系统要求开发者在模块开始列出所有依赖，
- 而有些模块系统则允许开发者在程序结构中动态添加依赖。
- 动态添加的依赖有别于模块开头列出的常规依赖，
  - 这些依赖必须在模块执行前加载完毕。 

- 下面是动态依赖加载的例子：

```
if (loadCondition) {
    require('./moduleA');
}
```

- 在这个模块中，是否加载moduleA
  - 是运行时确定的。
- 加载moduleA时
  - 可能是阻塞的，
  - 也可能导致执行，
    - 且只有模块加载后才会继续。

- 模块内部的代码在moduleA加载前都不能执行，
  - 因为moduleA的存在是后续模块行为正确的关键。 

- 动态依赖可以支持更复杂的依赖关系，
  - 但代价是增加了对模块进行静态分析的难度。 

### **26.1.7** 静态分析 

- 分析工具会检查代码结构
  - 并在不实际执行代码的情况下
    - 推断其行为。
- 对静态分析友好的模块系统
  - 可以让模块打包系统
    - 更容易将代码处理为较少的文件。

### **26.1.8** 循环依赖 

- 包括CommonJS、AMD和ES6在内的所有模块系统
  - 都支持循环依赖。
- 在包含循环依赖的应用程序中，
  - 模块加载顺序可能会出人意料。
- 在下面的模块代码中（其中使用了模块中立的伪代码），
  - 任何模块都可以作为入口模块
    - 即使依赖图中存在循环依赖： 

```
require('./moduleD');
require('./moduleB');
console.log('moduleA');

require('./moduleA');
require('./moduleC');
console.log('moduleB');

require('./moduleB');
require('./moduleD');
console.log('moduleC');

require('./moduleA');
require('./moduleC');
console.log('moduleD');
```

- 修改主模块中用到的模块
  - 会改变依赖加载顺序。
- 如果moduleA最先加载，
  - 则会打印如下输出，
  - 这表示模块加载完成时的绝对顺序：

```
moduleB 
moduleC 
moduleD
moduleA
```

- 以上模块加载顺序可以用图26-2的依赖图来表示，
  - 其中加载器会执行深度优先的依赖加载

![image-20220501073641110](第 26 章 模块.assets/image-20220501073641110.png)

- 如果moduleC最先加载，则会打印如下输出，
  - 这表示模块加载的绝对顺序

```
moduleD 
moduleA 
moduleB 
moduleC
```

![image-20220501073832065](第 26 章 模块.assets/image-20220501073832065.png)

## **26.2** 凑合的模块系统

- 为按照模块模式提供必要的封装，
  - ES6之前的模块有时候会使用
    - 函数作用域和
    - 立即调用函数表达式（IIFE)
  - 将模块定义封装在匿名闭包中。
  - 模块定义是立即执行的， 

```
(function () {
    // 私有Foo模块的代码 
    console.log('bar');
})(); 
// bar
```

- 如果把这个模块的返回值赋给一个变量，
  - 那么实际上就为模块创建了命名空间： 

```
var Foo = (function () {
    console.log('bar');
})();
// 'bar'
```

- 为了暴露公共API，模块IIFE会返回一个对象，
  - 其属性就是模块命名空间中的公共成员

```
var Foo = (function () {
    return {
        bar: 'baz',
        baz: function () {
            console.log(this.bar);
        }
    };
})();
console.log(Foo.bar); // 'baz'
Foo.baz(); // 'baz'
```

- 还有一种模式叫作“泄露模块模式”
  - （revealing module pattern）。
  - 这种模式只返回一个对象，
    - 其属性是私有数据和成员的引用

```
var Foo = (function () {
    var bar = 'baz';
    var baz = function () {
        console.log(bar);
    };
    return {
        bar: bar,
        baz: baz
    };
})();
console.log(Foo.bar); // 'baz' 
Foo.baz(); // 'baz'
```

- 在模块内部也可以定义模块，
  - 这样可以实现命名空间嵌套： 

```
var Foo = (function () {
    return {
        bar: 'baz'
    };
})();
Foo.baz = (function () {
    return {
        qux: function () {
            console.log('baz');
        }
    };
})();
console.log(Foo.bar); // 'baz'
Foo.baz.qux(); // 'baz'
```

- 为了让模块正确使用外部的值，
  - 可以将它们作为参数传给IIFE：

```
var globalBar = 'baz';
var Foo = (function (bar) {
    return {
        bar: bar,
        baz: function () {
            console.log(bar);
        }
    };
})(globalBar);
console.log(Foo.bar); // 'baz'
Foo.baz(); // 'baz'
```

- 因为这里的模块实现其实就是在创建JavaScript对象的实例，
  - 所以完全可以在定义之后再扩展模块

```
// 原始的Foo
var Foo = (function (bar) {
    var bar = 'baz';
    return {
        bar: bar
    };
})();
// 扩展Foo 
var Foo = (function (FooModule) {
    FooModule.baz = function () {
        console.log(FooModule.bar);
    }
    return FooModule;
})(Foo);
console.log(Foo.bar); // 'baz'
Foo.baz(); // 'baz'
```

- 无论模块是否存在，
  - 配置模块扩展以执行扩展也很有用

```
// 扩展Foo以增加新方法 
var Foo = (function (FooModule) {
    FooModule.baz = function () {
        console.log(FooModule.bar);
    }
    return FooModule;
})(Foo || {});

// 扩展Foo以增加新数据 
var Foo = (function (FooModule) {
    FooModule.bar = 'baz';
    return FooModule;
})(Foo || {});

console.log(Foo.bar); // 'baz'
Foo.baz(); // 'baz'
```

## **26.3** 使用**ES6**之前的模块加载器 

### **26.3.1 CommonJS** 

- CommonJS规范概述了
  - 同步声明依赖的模块定义。
- 这个规范主要用于
  - 在服务器端实现模块化代码组织，
  - 但也可用于定义在浏览器中使用的模块依赖。
- CommonJS模块语法
  - 不能在浏览器中直接运行。 

- Node.js的模块系统使用了CommonJS规范，
  - 实际上并不完全正确。
  - Node.js使用了轻微修改版本的CommonJS，
- 因为Node.js主要在服务器环境下使用，
  - 所以不需要考虑网络延迟问题。 

- 考虑到一致性，
  - 本节使用Node.js风格的模块定义语法。 

- CommonJS模块
  - 定义需要使用require()指定依赖，
  - 而使用exports对象定义自己的公共API。
- 下面的代码展示了简单的模块定义：

```
var moduleB = require('./moduleB');
module.exports = {
    stuff: moduleB.doStuff();
};
```

- moduleA通过使用模块定义的相对路径
  - 来指定自己对moduleB的依赖。
- 什么是“模块定义”，以及如何将字符串解析为模块，
  - 完全取决于模块系统的实现。
  - 比如在Node.js中，
    - 模块标识符
      - 可能指向文件，
      - 也可能指向包含index.js文件的目录。 

- 请求模块
  - 会加载相应模块，
- 而把模块赋值给变量也非常常见，
  - 但赋值给变量不是必需的。
- 调用require()意味着
  - 模块会原封不动地加载进来：

```
console.log('moduleA');
require('./moduleA'); // "moduleA"
```

- 无论一个模块在require()中被引用多少次，
  - 模块永远是单例。
- 在下面的例子中，moduleA只会被打印一次。
  - 这是因为无论请求多少次，
    - moduleA只会被加载一次

```
console.log('moduleA');
var a1 = require('./moduleA');
var a2 = require('./moduleA');
console.log(a1 === a2); // true
```

- 模块第一次加载后会被缓存，
  - 后续加载会取得缓存的模块
  - （如下代码所示）。
- 模块加载顺序
  - 由依赖图决定

```
console.log('moduleA');
require('./moduleA');
require('./moduleB'); // "moduleA" 
require('./moduleA');
```

- 在CommonJS中，模块加载是模块系统执行的同步操作。
  - 因此require()可以以编程方式嵌入在模块中： 

```
console.log('moduleA');
if (loadCondition) {
    require('./moduleA');
}
```

- 这里，moduleA只会在loadCondition求值为true时才会加载。这个加载 

  是同步的，因此if()块之前的任何代码都会在加载moduleA之前执行， 

  而if()块之后的任何代码都会在加载moduleA之后执行。同样，加载顺 

  序规则也会适用。因此，如果moduleA已经在前面某个地方加载过了， 

  这个条件require()就意味着只暴露moduleA这个命名空间而已